[{
  "_id": {
    "$oid": "5bdc96358d7091b8926f459b"
  },
  "uKey": 1,
  "name": "Основы верстки",
  "html": "<p>В этом модуле мы изучим основы верстки – процесса создания веб-страниц, из которых \nсостоят все сайты.</p><p>В верстке используется два языка – HTML и CSS.</p><ul><li>HTML – язык разметки текста, созданный специально для веб. Он содержит текст веб-страницы, написанный по определенным правилам. HTML расшифровывается как hypertext markup language (язык разметки гипертекста) и является общепринятым стандартом. </li><li> CSS – язык стилей. Если HTML содержит непосредственно текст веб-страницы, то CSS \nзадает ее внешний вид. Он тоже является общепринятым стандартом, который понимают все браузеры и расшифровывается как Cascading Style Sheets (обычно переводят как “таблицы каскадных стилей”)</li></ul><h3>Как работать с заданиями</h3><p>Все задания по верстке мы будем выполнять на сервисе <a href=\"http://jsfiddle.net\" target=\"_blank\">http://jsfiddle.net</a>. Это удобный эмулятор поведения браузера, в котором можно вписывать HTML и CSS и сразу видеть желаемый результат.</p><h3>Правила работы с jsfiddle</h3><ul><li>Для каждого задания создаете новый fiddle – для этого нужно открыть в браузере новую вкладку с адресом <a href=\"http://jsfiddle.net\" target=\"_blank\">http://jsfiddle.net</a>. Вписываете код HTML и CSS в соответствующие окошки и добиваетесь, чтобы в окошке result итоговая страница выглядела как требуется.</li><li>Сохраняете этот fiddle (нажимаете на верхней панели ссылку Save). Обратите внимание, что в адресной строке изменился URL</li><li>Зайдите в задание а панели Хуториума. Там будут кнопки “Комментировать” и “Отправить на проверку”. Сначала вставьте в качестве комментария ссылку с вашим fiddle, а затем отправьте задание на проверку.</li><li>Пока преподаватель проверяет ваш результат, можете начать делать следующее задание. Если у преподавателя появятся замечания, он опишет их в комментариях, и их нужно будет исправить. После исправления вашего fiddle нажмите кнопку Update в верхней панели. Ссылка снова изменится – и ее можно будет вставить в комментарий. Не забудьте снова отправить задание на проверку.</li></ul><p>Давайте посмотрим, как устроен HTML, и попробуем что-нибудь написать.</p>",
  "tasks": [
    {
      "name": "Простая плашка",
      "html": "<p>Весь текст в языке HTML должен находиться внутри специальных элементов, называемых <em>тегами</em>. Эти теги нужно писать по строго определенным правилам, которые называют синтаксисом языка. Если вы ошибетесь в синтаксисе любого тега – браузер отобразит страницу не так, как вы планировали.</p><p>Давайте посмотрим, как записывается типичный тег.</p><pre><code class=\"language-html\">&lt;div class=\"box1\"&gt;Привет!&lt;/div&gt;</code></pre><p>Синтаксис для задания тега состоит из трех частей:</p><ol><li>Открывающая часть (еще называют \"открывающий тег\"). Это кусок <code>&lt;div class=\"box1\"&gt;</code> Состоит из имени тега и атрибутов (подробнее ниже).</li><li>Закрывающая часть – <code>&lt;/div&gt;</code>. Состоит из слеша / и имени тега – который должен в точности соответствовать открывающему.</li><li>Контент, или содержимое – все, что находится между открывающей и закрывающей частью.</li></ol><p>Фактически, браузер отображает только контент тегов. Открывающая часть нужна, чтобы настроить это отображение, а закрывающая – чтобы сообщить браузеру, что тег кончился и эти настройки больше не действительны.</p><p>Давайте посмотрим на открывающую часть чуть подробнее. Она всегда заключена в угловые скобки &lt;&gt; и состоит из следующих частей:</p><ol><li>Имя тега. В HTML поддерживается строго определенный набор тегов. В нашем случае мы использовали тег <em>div</em>. Это самый распространенный элемент, представляет собой просто прямоугольник, растягивающийся на всю доступную ширину.</li><li>Набор атрибутов для данного тега. Все атрибуты состоят из пар вида <code>название_атрибута=\"значение\"</code>. В нашем случае мы задали только один атрибут <code>class</code>со значением <code>box1</code>. Но для одного тега можно задавать несколько атрибутов. Набор возможных атрибутов тоже строго ограничен правилами HTML –  а вот значения им можно присваивать любые.</li></ol><h2>Задание</h2><p>Напишите в jsfiddle (т.е. впишите в окно HTML) простой тег с любым текстовым содержимым внутри и атрибутом <code>class</code> со значением <code>box1</code>. Если вы не ошиблись в синтаксисе, в окошке <em>Result</em> будет отображено только это текстовое содержимое. </p><p>Если вы ошибетесь в синтаксисе – например, не закроете тег, забудете угловую скобку или не закроете кавычки – браузер будет воспринимать ваш код не как тег, а как простое текстовое содержимое – и отобразит его вместе с оставшимися кавычками и угловыми скобками.</p>",
      "tKey": 1
    },
    {
      "name": "Стилизация плашки",
      "html": "<p>В прошлом задании мы создали простую плашку и задали для нее атрибут <code>class</code>. Как вы заметили, атрибут <code>class</code> никак не повлиял на отображение плашки. Зачем он тогда нужен?</p><p>Одно из назначений атрибута <code>class</code> –  помогать при стилизации элементов. Мы можем создать в CSS (таблице стилей) несколько правил отображения и объявить их относящимися к определенному классу.</p><blockquote><p>Перед выполнением этого задания сделайте в jsfiddle копию от предыдущего задания. Важно не модифицировать предыдущее задание, чтобы оно осталось для проверки и доработок – а именно сделать копию. Для этого нажмите Fork (можно говорить \"форкнуть\") в верхней панели jsfiddle. В адресной строке поменяется URL – теперь этот fiddle можно модифицировать независимо от предыдущего.</p></blockquote><p>CSS – это другой язык со своим синтаксисом. В jsfiddle он задается в соседнем окошке (справа). Давайте посмотрим, как выглядит типовой набор  правил в CSS. </p><pre><code class=\"language-css\">.box1 {\n  background-color: black;\n  color: white;\n}</code></pre><blockquote><p>Сразу попробуйте вставить это правило в окно CSS в jsfiddle и посмотрите, что получится. Вообще, используйте такой подход по возможности чаще – сначала пробуйте и экспериментируйте, а потом читайте теорию.</p></blockquote><p>Вот из чего состоит наш набор правил:</p><ol><li>Селектор – определяет, к каким именно тегам html применять этот набор правил. В нашем случае селектор выглядит как <code>.box1</code>. Он означает требование применить набор правил ко всем тегам HTML, у которых задан <code>class=\"box1\"</code>. Обратите внимание – здесь очень важна точка <code>.box1</code>. Точка в CSS – означает класс в HTML. Если написать селектор без точки – просто <code>box1</code>, то набор правил будет применяться к тегам с таким названием – т.е. к элементам HTML вида <code>&lt;box1&gt;Привет&lt;/box1&gt;</code></li><li>Набор стилевых правил. Каждый стиль занимает отдельную строчку и заканчивается символом <code>;</code> (точка с запятой). Все стили, относящиеся к данному селектору – должны быть окружены фигурными скобками <code>{}</code>. Часто для экономии места открывающую фигурную скобку пишут в той же строке, что и селектор – <code>.box1 {</code>.</li></ol><p>Давайте еще разберемся, как устроено каждое  стилевое правило. Он всегда имеет вид <code>название_стиля: значение;</code>. Cтилей в CSS ограниченное количество, в дальнейшем их нужно будет изучать самостоятельно. </p><p>Возможные значения – естественно, зависят от конкретного стиля. Например, для цветовых стилей (color, background-color, border-color и т.п.) подойдут либо английские названия цветов <code>color:red;</code> или кодовые шестнадцатеричные представление цвета, например <code>background-color:#ff8800;</code>. Для стилей, которые предполагают размеры или расстояния (width, height, margin, padding, margin-top, font-size и т.п.) – в качестве значений чаще всего используется количество пикселей вот в таком виде:<code>height:100px;</code>.</p><h2>Задание</h2><p>Давайте зададим для нашей плашки с классом box1 набор вот таких правил :</p><ol><li>Цвет фона (background-color) – темно-серый (#333333);</li><li>Цвет шрифта (color) – белый (white)</li><li>Бордюр толщиной 4px, сплошной и оранжевого цвета. Можно использовать комбинированный способ задания правила: <code>border:4px solid orange;</code></li><li>Ширину <code>width</code> сделайте равной <code>300px</code></li></ol><blockquote><p>В фоне начните самостоятельно изучать все правила CSS – они пригодятся в дальнейшем. Они много где описаны, например – <a href=\"http://htmlbook.ru/css\">http://htmlbook.ru/css</a></p></blockquote>",
      "tKey": 2
    },
    {
      "name": "Несколько плашек и множественные классы",
      "html": "<p>Типовая HTML-страница состоит из множества тегов. Мы до этого момента имели дело только с одним – пора это исправить.</p><h3>Задание</h3><blockquote><p>Сделайте в HTML четыре плашки с тем же классом – box1 и немного разным текстом внутри.</p></blockquote><p>Это было просто. Теперь давайте создадим в CSS еще один набор стилей для класса <code>box2</code>. Самостоятельно поменяйте в нем несколько стилей, чтобы он выглядел по другому.</p><h3>Задание</h3><blockquote><p>Оставьте первым двум плашкам класс <code>box1</code>, а вторым двум – назначьте класс <code>box2</code>.</p></blockquote><p>А теперь давайте попробуем применить к одной и той же плашке несколько классов одновременно. Скажем, мы хотим иметь возможность делать некоторые плашки более крупного размера по высоте – и хотим иметь возможность применять это как к плашкам box1, так и к box2.</p><h3>Задание</h3><blockquote><p>Сделайте в CSS новый класс <code>tall</code> (высокий). Задайте для него правило, которое устанавливает высоту (height) в 50px. Примените это класс к первой и последней плашке – при этом их обычная стилизация должна сохраниться. Подсказка: чтобы применить к HTML-элементу сразу несколько CSS-классов, нужно написать их через пробел, например: <code>&lt;div class=\"box1 tall some_other_class\"&gt;Привет&lt;/div&gt;</code></p></blockquote>",
      "tKey": 3
    },
    {
      "name": "Вложенные теги",
      "html": "<p>До этого момента мы ставили все теги в HTML последовательно – один за другим. Контентом (содержимым) всех тегов был простой текст. </p><p>Теперь давайте немного усложним верстку и попробуем запихать несколько тегов внутрь другого.</p><pre><code class=\"language-html\">&lt;div class=\"box1\"&gt;\n   &lt;div class=\"box2\"&gt;Первый&lt;/div&gt;\n   &lt;div class=\"box2\"&gt;Еще один&lt;/div&gt;\n&lt;/div&gt;</code></pre><p>Естественно, внутрь каждого из вложенных тегов можно вкладывать сколько угодно других – то есть, структура веб-страницы представляет собой что-то вроде дерева с кучей вложенных элементов.</p><p>Обратите внимание на несколько важных моментов.</p><ol><li>В программировании принято обозначать вложенность отступом – несколькими пробелами от начала строки. Это касается HTML, CSS, Javascript и почти всех остальных языков. Это необязательное правило с точки зрения синтаксиса – браузеру нет дела до этих пробелов – но крайне обязательное с точки зрения удобства чтения кода. Так что привыкайте делать отступы с самого начала. Общепринятым стандартом на сегодняшний день является отступ в два пробела на каждый уровень вложенности.</li><li>Когда вы делаете вложенность, обращайте повышенное внимание на своевременное закрытие тегов – поначалу там легко запутаться.</li><li>Текстовое содержимое может без проблем чередоваться с содержимым других тегов – например, вот так: </li></ol><pre><code class=\"language-html\">&lt;div class=\"box1\"&gt;\n   небольшой текст\n   &lt;div class=\"box2\"&gt;Первый&lt;/div&gt;\n   еще текст\n   &lt;div class=\"box2\"&gt;Еще один&lt;/div&gt;\n&lt;/div&gt;</code></pre><h3>Семантически значимые названия классов</h3><p>CSS-классы (как в дальнейшем переменные, функции и другие сущности языков) можно называть любым способом. Браузеру все равно, как вы назовете класс – главное, чтобы он был одинаково написан и в HTML, и в CSS. </p><p>В результате начинающие разработчики называют классы как попало. В большом проекте это недопустимо. Другим программистам, которые будут читать и модифицировать ваш код, будет сложнее разобраться с ничего не значащими названиями, и они потратят больше времени.</p><p>Поэтому, начиная с этого момента – к каждому заданию будет предъявляться требование обдуманно называть классы на правильном английском языке.</p><h2>Задание</h2><blockquote><p>Сделайте и стилизуйте один тег с классом parent (\"родитель\"). У него должен быть светло-серый фон (background-color: #ddd;) и внутренний отступ (padding) в 20 пикселей (20px). Поместите внутрь родителя несколько тегов с классом box1 или box2 и прежней стилизацией. </p></blockquote>",
      "tKey": 4
    },
    {
      "name": "Блочная модель",
      "html": "<p>Важнейшим элементом для успешного применения HTML является понимание блочной модели и CSS-стиля <code>display</code>. </p><p>Давайте начнем со свойства display. Если говорить упрощенно, у каждого элемента HTML включен один из следующих режимов отображения:</p><ul><li><code>display:block;</code> – <em>блочные</em> элементы. У них два главных свойства –  они всегда занимают прямоугольную область, и стараются распахнуться на всю доступную ширину родительского элемента. У большинства HTML-тегов, включая <code>div</code>, этот режим включен автоматически.</li><li><code>display:inline;</code> – <em>инлайновые</em> элементы. Как правило, это элементы стилизации текста – например, тег курсива <code>&lt;i&gt;Этот текст – курсив&lt;/i&gt;</code>. Они не всегда занимают прямоугольник – потому что в длинном тексте инлайновый элемент может начаться в конце одной строки, а закончиться в начале следующей. В результате инлайновым элементам нельзя назначать CSS-свойства управления размером –  <code>width</code>, <code>height</code>, <code>padding</code>, <code>margin</code>.</li><li><code>display:inline-block;</code> – <em>инлайн-блочные</em> элементы. Основное отличие этих элементов от блочных – они не стремятся \"захватить\" всю доступную ширину родительского элемента, а берут столько ширины, сколько нужно. В результате такие элементы можно располагать горизонтально, т.е. в линию. Но при этом они всегда занимают прямоугольную область, и мы можем управлять свойствами <code>width</code>, <code>height</code>, <code>padding</code>, <code>margin</code>.</li></ul><h2>Задание</h2><blockquote><p>Сделайте форк от предыдущего задания. \nДобавьте всем вложенным HTML-элементам  класс <code>child</code>. В CSS назначьте классу стиль display:inline-block и добейтесь, чтобы вложенные элементы были расположены горизонтально.</p></blockquote><p>Изучите самостоятельно, как работают стили блочных моделей width, height, margin и padding.\n<a href=\"https://developer.mozilla.org/ru/docs/Web/CSS/box_model\">https://developer.mozilla.org/ru/docs/Web/CSS/box_model</a></p><h2>Задание</h2><blockquote><p>Сделайте, чтобы между вложенными элементами было ровно 20px по горизонтали, а отступ от краев родительского элемента составлял по 30 px.</p></blockquote><h3>Пробелы в верстке</h3><blockquote><p>может пригодиться при выполнении задания</p></blockquote><p>Обратите внимание, как браузер интерпретирует пробелы. Из-за отступов у нас в верстке появляется несколько пробелов, идущих подряд. Браузер это  учитывает, и \"схлопывает\" их до одного пробела. Когда мы имеем дело с блочными элементами, этот схлопнутый пробел практически не оказывает влияния на верстку. Но – когда мы стараемся расположить элементы по горизонтали, между ними влезают эти пробелы и влияют на расстояние:</p><pre><code class=\"language-html\">&lt;div class=\"parent\"&gt;\n  &lt;div class=\"child\"&gt;\n     Child 1\n  &lt;/div&gt;\n  &lt;div class=\"child\"&gt;\n     Child 2\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre><p>Возможным вариантом в этом случае является решение поместить открывающий тег на ту же строку, где расположен предыдущий закрывающий и таким образом исключить эти пробелы:</p><pre><code class=\"language-html\">&lt;div class=\"parent\"&gt;\n  &lt;div class=\"child\"&gt;\n     Child 1\n  &lt;/div&gt;&lt;div class=\"child\"&gt;\n     Child 2\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre>",
      "tKey": 5
    },
    {
      "name": "Ссылки, картинки и другие теги",
      "html": "<p>Мы пока пользовались только тегом <code>div</code>. С помощью стилизации можно добиться от него любого внешнего вида, поэтому во многих  случаях верстка может целиком состоять из одних <code>div</code>-ов.</p><p>Однако, когда требуется другой функционал помимо отображения и стилизации текста – применяются специальные теги со специфическим поведением.</p><p>Вот несколько примеров таких тегов:</p><ul><li><span>&lt;a&gt;</span> – ссылка</li><li><span>&lt;img&gt;</span> – картинка</li><li><span>&lt;input&gt;</span> – поле ввода</li></ul><p>Разберем подробнее два из них – ссылку и картинку.</p><h3>Ссылка</h3><p>Чтобы ссылка <span>&lt;a&gt;</span> (от английского anchor – якорь) работала как обычная веб-ссылка, необходимо задать ей атрибут <code>href</code> – и внутри него указать URL, на который должна вести ссылка. Вот пара примеров:</p><pre><code class=\"language-html\">&lt;a href=\"http://hutorium.ru\"&gt;Ссылка на Хуториум&lt;/a&gt;\n&lt;a href=\"http://hutorium.ru\"&gt;\n  &lt;div&gt;Внутри ссылки могут быть любые другие теги&lt;/div&gt;\n&lt;/a&gt;</code></pre><h3>Картинка</h3><p>У тега картинки <code>&lt;img /&gt;</code> тоже используется специфический атрибут – только не <code>href</code>, а <code>src</code>. Он должен содержать URL картинки, которую вы хотите показать на странице. У <code>&lt;img /&gt;</code> есть еще одна особенность – он использует только сокращенную форму записи тега. В сокращенной форме закрывающий тег отсутствует, а слеш ставится в конце закрывающего тега. Поэтому у тега <code>&lt;img /&gt;</code> не может быть внутреннего контента. Вот пример использования тега <code>&lt;img&gt;</code>:</p><pre><code class=\"language-html\">&lt;img src=\"http://80.211.25.188/img/bg3.jpg\" /&gt;</code></pre><h2>Задание</h2><blockquote><p>Создайте ссылку-картинку, которая ведет на сайт <a href=\"http://hutorium.ru\">http://hutorium.ru</a>. Картинка находится по адресу <a href=\"/img/bg3.jpg\">http://80.211.25.188/img/bg3.jpg</a>. Подсказка – в качестве содержимого ссылка может содержать любую сложную верстку и другие теги. Дополнительное требование – сделайте, чтобы выводимая картинка была шириной 200px. </p></blockquote>",
      "tKey": 6
    },
    {
      "name": "Абсолютное позиционирование",
      "html": "<p>Обычно браузер последовательно отображает все встречающиеся элементы в соответствии с блочной моделью. Каждый элемент занимает определенное место и \"сталкивает\" последующие теги вниз или вправо - в зависимости от имеющегося места и стиля <code>display</code>.</p><p>Но иногда в верстке требуется поместить какой-то элемент в строго определенную позицию – вне зависимости от расположения и размера остальных элементов. Для этого используется понятие <em>абсолютного позиционирования</em></p><p>Чтобы включить для какого-то элемента режим абсолютного позиционирования, у него должен быть установлен стиль <code>position:absolute;</code>. В этом случае элемент как бы \"выпадает\" из верстки, не занимает места и не зависит от размеров и положения соседних элементов.</p><p>Управлять положением абсолютно позиционированного элемента можно с помощью стилей <code>top</code>, <code>left</code>, <code>right</code>, <code>bottom</code> – которые задают отступы от краев родительского элемента.</p><blockquote><p>У родительского элемента при этом должен быть установлен стиль <code>position:relative</code> или <code>position:absolute</code>. Если такого стиля у родительского элемента нет – браузер попытается найти этот стиль у его родителя и далее по цепочке вверх. Отступ будет произведен от краев первого родителя с нужным стилем в этой цепочке.</p></blockquote><p>Изучите самостоятельно детали поведения <code>position:absolute</code> или других стилей позиционирования – например, на <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/position\">https://developer.mozilla.org/en-US/docs/Web/CSS/position</a></p><h2>Задание</h2><p>Сверстайте в редакторе вот такой блок</p><p><img alt=\"Сверстайте этот блок\" src=\"/img/tasks/position-absolute.png\"></p><h4>Пояснения к заданию:</h4><ul><li>Помните про требование осмысленности названий классов. Например, родительскому элементу хорошо подойдет класс <code>container</code>, а картинке – <code>side-image</code>.</li><li>Картинка должна отступать 20px от правого края родителя, и 20px – от нижнего края;</li><li>Текст не должен залезать под картинку – для этого можно правильно использовать свойство <code>padding</code> у родителя.</li><li>Текст можно взять отсюда: <a href=\"https://www.lipsum.com/\">https://www.lipsum.com/</a></li><li>Картинка лежит по адресу <a href=\"http://80.211.25.188/img/bg3.jpg\">http://80.211.25.188/img/bg3.jpg</a></li><li>Цвет фона родителя – #cccccc;</li><li>Отступ текста от краев - 20px; </li></ul>",
      "tKey": 7
    },
    {
      "name": "Использование CSS-фреймворков",
      "html": "<p>Обычно к проектам, которыми пользуются тысячи человек ежедневно, предъявляются повышенные требования к дизайну. Сначала интерфейс проекта рисует дизайнер, а затем разработчики верстают полученные картинки. </p><p>Но иногда требования к дизайну не являются принципиальными, не хватает времени или денег на дизайнера. Так часто бывает при разработке бек-офисов различных приложений – внутренних панелей инструментов, которыми пользуются только сотрудники компании. </p><p>В таких случаях часто используются CSS-фреймворки – наборы готовых стилей, сделанные профессиональными дизайнерами и верстальщиками. Вам остается только подключить фреймворк и назначать вашим элементам уже готовые названия классов.</p><p>Мы пока будем использовать <em>bootstrap</em> от компании Твиттер как наиболее распространенный и полный на данный момент. Вся информация о нем – на сайте <a href=\"https://getbootstrap.com/\">https://getbootstrap.com/</a>. </p><p>В дальнейшем рекомендуется обратить внимание на более современные фреймворки, большинство из которых реализует концепцию дизайна <a href=\"https://material.io\">https://material.io</a> от Google. Хорошим примером таких фреймворков являются <a href=\"https://materializecss.com/\">https://materializecss.com/</a> и <a href=\"https://material-ui.com/\">https://material-ui.com/</a> (последний гораздо сложнее в подключении и использовании).</p><p>Для подключения CSS-фреймворка нужно просто следовать инструкциям на сайте. В случае Bootstrap – от нас требуется всего лишь включить в наш HTML-файл следующий элемент:</p><pre><code class=\"language-html\">&lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css\" crossorigin=\"anonymous\"&gt;</code></pre><h2>Задание</h2><p>Сверстайте следующую картинку:</p><p><img alt=\"Переключалка табов\" src=\"/img/tasks/tabs.png\"></p><h4>Пояснения:</h4><ul><li>Для верхней плашки используйте элемент alert отсюда: <a href=\"https://getbootstrap.com/docs/4.1/components/alerts/\">https://getbootstrap.com/docs/4.1/components/alerts/</a></li><li>Для табов – элемент tabs <a href=\"https://getbootstrap.com/docs/4.1/components/navs/#tabs\">https://getbootstrap.com/docs/4.1/components/navs/#tabs</a></li><li>Обратите внимание, что требуется сделать активным именно второй таб.</li><li>Не забудьте подключить bootstrap!</li></ul>",
      "tKey": 8
    }
  ]
},{
  "_id": {
    "$oid": "5be0bcf48200f160a4c101ee"
  },
  "name": "Верстка сложного компонента",
  "html": "В этом юните мы постараемся сверстать более сложный компонент – использовав все знания из предыдущего юнита и научившись нескольким новым приемам.",
  "uKey": 2,
  "tasks": [
    {
      "name": "Блок навигации и сложные CSS-селекторы",
      "html": "<h2>Сложные селекторы</h2><p>До этого момента мы использовали только простые CSS-селекторы, которые стилизуют определенный класс или тег. Как правило, при сложной верстке этого функционала не хватает, поэтому в CSS часто используются <em>составные селекторы</em></p><p>Примеры составных селекторов:</p><pre><code class=\"language-css\">.app-bar a {\n  color:white;\n}\na.active {\n  color:red;\n}</code></pre><p>В первом примере селектор состоит из двух компонентов: класса <code>app-bar</code> и тега <code>a</code> (обратите внимание – <code>a</code> указано без точки, поэтому оно будет применяться к тегу a, а не классу a).</p><p>Компоненты <code>.app-bar</code> и <code>a</code> разделены пробелом – в составных селекторах это означает вложенность элементов в HTML. То есть, это правило применится ко всем элементам <code>a</code>, находящимся внутри элемента с классом <code>app-bar</code>. </p><p>Второй пример тоже состоит из двух компонентов – тега <code>a</code> (без точки) и класса <code>active</code>. Между ними нет пробела – это означает, что элемент HTML должен соответствовать сразу всем компонентам, чтобы правило применилось. То есть, стили сработают для всех ссылок (т.е. тегов <code>a</code>), которые обладают классом <code>active</code>, например:</p><pre><code class=\"language-html\">&lt;a class=\"active\"&gt;Активная ссылка&lt;/a&gt;</code></pre><p>Составной селектор может содержать сколько угодно компонентов, либо разделенных пробелами, либо нет. Например:</p><pre><code class=\"language-css\">.app-bar a.active {\n  color:white;\n}</code></pre><p>Это правило применится только к ссылкам с классом <code>active</code>, находящимся внутри элемента с классом <code>app-bar</code>.</p><h2>Задание</h2><p>Сверстать блок верхней навигации в соответствии с картинкой:\n<img alt=\"Блок навигации\" src=\"/img/tasks/navigation.png\"></p><p>Подсказки:</p><ul><li>Использовать элемент Base nav из бутстрапа (<code>&lt;ul class=\"nav\"&gt;</code>) <a href=\"https://getbootstrap.com/docs/4.1/components/navs/\">https://getbootstrap.com/docs/4.1/components/navs/</a></li><li>Поместить навигацию внутрь тега с классом <code>app-bar</code>. Application bar, или AppBar – общепринятое название для главного блока навигации приложения, поэтому мы называем класс так, чтобы с первого взгляда было понятно, о чем речь.</li><li>С помощью сложных правил стилизуйте цвет обычных и активных ссылок внутри <code>app-bar</code>. Обычная ссылка должна быть белой, активная – цвета <code>lightgreen</code>.</li></ul>",
      "tKey": 1
    },
    {
      "name": "Центрирование блочных элементов",
      "html": "<p>В предыдущем задании у нас была небольшая проблема – весь блок навигации оказался смещен к левому краю, а не располагался по центру, как хотелось бы.</p><p>Если центрировать обычный инлайновый контент (например, текст) можно просто с помощью стиля <code>text-align:center</code>, то с блочными элементами все несколько сложнее.</p><pre><code>HTML:\n&lt;div class=\"centered-text\"&gt;\nЭтот текст будет выведен по центру\n&lt;/div&gt;\nCSS:\n.centered-text {\n  text-align:center;\n}</code></pre><p>Если сформулировать задачу центрирования блока в более общем виде – то эта задача привязки контента к <code>сетке</code>. Сетка (grid) – это такая концепция от дизайнеров, по которой весь рисунок страницы как бы разбивается невидимыми  вертикальными и горизонтальными линиями на ячейки. Границы всех крупных блоков привязываются к этой сетке.</p><p>Сетка (grid) поддерживается почти всеми современными CSS- фреймворками, в том числе и bootstrap-ом.</p><p>Вкратце, вот детали этой реализации:</p><ul><li>Если мы хотим использовать сетку внутри какого-то элемента, ему нужно присвоить класс <code>row</code>. В этом случае он будет как бы разбит на 12 столбцов</li><li>Непосредственным потомкам элемента с классом <code>row</code> можно присваивать класс <code>col</code> и еще несколько других классов, которые определяет его ширину или отступ слева, например: <code>col col-md-5 col-sm-10 offset-sm-1</code></li><li>У этих классов есть суффиксы xs, sm, md, lg, xl. Они означают размер экрана, при котором будет применен данный класс (<code>xl</code> - самый широкий экран, <code>xs</code> – самый маленький). </li><li>В случае, если класса для данного экрана нет, бутстрап применит ближайший класс в сторону уменьшения. Например, если экран <code>md</code>, а заданы классы <code>col-sm-10 и col-xs-12</code>, то будет применен <code>col-sm-10</code>. Благодаря этому можно гибко управлять отображением и делать, чтобы в случае просмотра на маленьких экрана контент отображался немного по-другому.</li><li>Если нам не нужно заморачиваться версткой под мобильные, мы можеи просто использовать суффиксы xs – они сработают при любом размере экрана как самые маленькие.</li></ul><h2>Задание</h2><p>Отцентрируйте навигацию. Блок навигации должен занимать 8 колонок, и иметь отступ слева 2 колонки (тогда справа останется тоже 12-8-2 = 2 колонки, и навигация будет по центру). Временно покрасьте навигацию в другой цвет (backgdound-color), чтобы при проверке было видно ее центральное расположение.</p><p><img alt=\"Навигация по центру\" src=\"/img/tasks/navigation-centered.png\"></p>",
      "tKey": 2
    },
    {
      "name": "Центральная плашка со скруглением и тенью",
      "html": "<p>Обычно страница состоит из трех частей: </p><ul><li>Верхняя часть (ее называют header и чаще всего размещают там навигацию); </li><li>Центральная часть – ее называют контентом; </li><li>Нижняя часть – называют футером (footer) или подвалом.</li></ul><p>Навигацию мы сделали, теперь давайте возьмемся за центральную часть, в которой будет контент.</p><h2>Задание</h2><p>Сверстайте центральную плашку и серый фон вокруг нее. \n<img alt=\"Карточка товара\" src=\"/img/tasks/product-empty.png\"></p><p>Подсказки и требования:</p><ul><li>У плашки должны быть скругленные углы по 5 px и тень. С тенью лучше поэкспериментировать, а пока можно взять готовое значение <code>0 4px 6px 1px #999</code>;</li><li>Нужно, чтобы плашка располагалась строго под блоком меню, с точно таким же принципом выравнивания.</li><li>Обратите внимание, что от плашки вверх и вниз должен быть отступ по 20px;</li><li>Внутренния отступы в плашке должны составлять 10px по вертикали и 20px по горизонтали.</li><li>Заголовок внутри плашки должен быть обязательно сверстан тегом <code>h1</code>, размер шрифта для него нужно установить в 18px;</li><li>У плашки должна быть минимальная высота в 100px.</li></ul><h3>Конфликты в CSS правилах</h3><p>Часто бывает, что CSS содержит правила, противоречащие друг другу. Например, библиотека bootstrap задает для h1 один размер шрифта, а наши собственные стили – совершенно другой. Как браузер определяет, какой стиль применить?</p><p>Подробно ответ на вопрос описан в статье <a href=\"https://developer.mozilla.org/ru/docs/Web/CSS/Specificity\">https://developer.mozilla.org/ru/docs/Web/CSS/Specificity</a>. Изучите ее и найдите ответ на вопрос, как нам победить правила bootstrap для размера шрифта h1 и для внутренних отступов в плашке. </p><p>Учтите, что из-за специфики песочницы стили bootstrap применяются позже, чем наши собственные. То есть, у них несколько выше приоритет – что делает задачу немного сложнее и интереснее.  </p>",
      "tKey": 3
    },
    {
      "name": "Футер и семантические теги",
      "html": "<p>Нам осталось сверстать футер. В футере обычно располагается информация по авторским правам,  ссылки на ненужные документы и прочие вещи, которые на сайте вроде бы нужны, но никто не знает зачем.</p><p>Есть и противоположный подход – когда в футере располагают что-то вроде карты сайта и он представляет из себя удобною навигацию из нескольких колонок ссылок.</p><p>Для данного примера нас устроит первый подход.</p><h2>Семантические теги</h2><p>Для подавляющего большинства блоков мы использовали тег <code>div</code>. Последнее время становится более популярным использовать семантические элементы и называть теги так, чтобы они отражали суть своего контента. В результате поисковики понимают этот сайт чуть лучше, и это дает определенное конкурентное преимущество. </p><p>Подробно семантические теги описаны в статье <a href=\"https://developer.mozilla.org/ru/docs/Web/HTML/Element\">https://developer.mozilla.org/ru/docs/Web/HTML/Element</a></p><h2>Задание</h2><p>Сверстайте футер как на картинке. \n<img alt=\"Футер\" src=\"/img/tasks/footer.png\">\nТребования:</p><ul><li>Использовать для футера тег footer, и стилизацию проводить по имени тега, а не класса.</li><li>Переделать <code>div</code> центральной части на тег <code>main</code>;</li><li>Переделать наш app-bar с дива на тег <code>header</code>;</li><li>Для верстки значка копирайтов используйте выражение <code>&amp;copy;</code>. Если в дальнейшем возникнет необходимость использовать в HTML какие-то спецсимволы, ищите в гугле по ключу <em>html special symbols</em>, например  – <a href=\"https://www.google.com/search?q=html+symbols+double+quote\">https://www.google.com/search?q=html+symbols+double+quote</a></li></ul>",
      "tKey": 4
    },
    {
      "name": "Контент карточки",
      "html": "<h2>Задание</h2><p>Доделайте верстку карточки продукта, закончив необходимые детали. В итоге должна получиться финальная картинка:</p><p><img alt=\"Карточка продукта\" src=\"/img/tasks/product-final.png\"></p><h3>Подсказки и требования:</h3><ul><li>Для верстки характеристик продукта используйте таблицу <em>small table</em> из bootstrap: <a href=\"https://getbootstrap.com/docs/4.1/content/tables/#small-table\">https://getbootstrap.com/docs/4.1/content/tables/#small-table</a></li><li>Чтобы разместить фотографию и таблицу характеристик рядом, нужно снова использовать Grid (сочетание row и col). Фотография продукта должна занимать 4 колонки, а таблица – 8.</li><li>У фотографии продукта следующий URL: <a href=\"/img/tasks/product.jpg\">http://80.211.25.188/img/tasks/product.jpg</a> </li><li>Поскольку исходная картинка гораздо шире, чем выделенные под нее 4 колонки, нужно ограничить ее размер. Это удобно сделать с помощью стиля <code>max-width:100%;</code>, которое не даст картинке распахиваться шире, чем на 100% от ширины родителя.</li></ul>",
      "tKey": 5
    }
  ]
},{
  "_id": {
    "$oid": "5be0bd6fd4034f60ca95a716"
  },
  "name": "Интерактив на чистом Javascript",
  "html": "<p>До этого момента мы делали просто статичную верстку, используя языки HTML и CSS.Сейчас пришло время научиться делать компоненты интерактивными – реагирующими на поведение пользователя и меняющими свой внешний вид.</p><p>Мы будем делать это на языке программирования <code>javascript</code>, который вводится в третью вкладку нашего редактора.</p>",
  "uKey": 3,
  "tasks": [
    {
      "name": "Ключевые понятия javascript",
      "html": "<p>Если язык HTML состоял из тегов, а CSS – из наборов правил, то \"кирпичиками\" javascript являются операторы.</p><h2>Оператор присваивания и переменные</h2><p>Давайте посмотрим на пример важнейшего для понимания оператора – оператора присваивания.</p><pre><code class=\"language-javascript\">let myVariable;\nmyVariable = 10 + 5;</code></pre><p>Каждый оператор javascript должен занимать одну строку (это не обязательно, но так принято) и заканчиваться символом <code>;</code> (точка с запятой).</p><p>Значит, наш блок кода содержит два оператора. Первый из них – создает <em>переменную</em> (variable) с названием myVariable, а второй как раз является оператором присваивания. Изучите самостоятельно понятие переменной – например, тут <a href=\"https://learn.javascript.ru/variables\">https://learn.javascript.ru/variables</a></p><p>Оператор присваивания – записывает в левую часть выражение из правой. В нашем случае в переменную myVariable будет записано число, равное 15.</p><blockquote><p>Обратите внимание, что оператор присваивание выглядит как математическая запись равенства. Но по смыслу он кардинально отличается – фактически, для его обозначения больше подошла бы стрелка влево, поскольку он вычисляет выражение из правой части и помещает в левую.</p></blockquote><p>Переменные можно использовать в других вычислениях.</p><pre><code class=\"language-javascript\">let myVariable1, myVariable2, myVariable3;\nmyVariable1 = 10 + 5;\nmyVariable2 = myVariable1 * 2;\nmyVariable3 = myVariable1 + myVariable2;\nalert(myVariable3);</code></pre><p>Встроенная в javascript функция <code>alert</code>, которую мы тут использовали, умеет выводить на экран значение переменной. Подумайте самостоятельно, какое значение будет выведено – а затем вставьте код в окно <code>javascript</code> в jsFiddel и проверьте себя.</p><blockquote><p>Форкните верстку от предыдущего задания и вводите все предлагаемые куски кода в окошко javascript. Сама верстка понадобится нам при дальнейшем выполнении этого задания.</p></blockquote><h2>Типы данных</h2><p>Переменная может хранить не только числовые значения. но и некоторые другие. Самыми важными для понимания являются строковые значения, массивы и объекты.</p><h3>Строковые значения</h3><pre><code class=\"language-javascript\">let myVariable1, myVariable2, myVariable3;\nmyVariable1 = \"good\";\nmyVariable2 = \"morning\";\nmyVariable3 = myVariable1 + \" \" + myVariable2;\nalert(myVariable3)</code></pre><p>Что будет выведено на экране? Подумайте, а затем попробуйте и проверьте себя.</p><p>Строковые значения <em>всегда</em> должны быть заключены внутрь кавычек. Если видите кавычки – сразу можете считать, что имеете дело со строковым значением.</p><h3>Массивы</h3><p>Изучите массивы самостоятельно <a href=\"https://learn.javascript.ru/array\">https://learn.javascript.ru/array</a>, а затем попробуйте такой кусок кода:</p><pre><code class=\"language-javascript\">let items; \nitems = document.getElementsByTagName(\"li\");\nalert(items.length);</code></pre><p>Функция <code>document.getElementsByTagName(\"li\")</code> возвращает массив из всех элементов HTML с указанным тегом (в данном случае <code>li</code>). Подумайте, что будет выведено на экран, а затем вставьте код и проверьте себя.</p><h3>Объекты</h3><p>Изучите самостоятельно работу с объектами <a href=\"https://learn.javascript.ru/object\">https://learn.javascript.ru/object</a></p><p>Теперь давайте получим со страницы какой-нибудь объект и выведем  какое-нибудь его поле.</p><pre><code class=\"language-javascript\">let items; \nitems = document.getElementsByTagName(\"li\");\nlet item;\nitem = items[0];\nalert(item.innerHTML);</code></pre><p>Мы получили массив всех элементов с тегом <code>li</code>, выбрали первый из них, а затем вывели его внутренний HTML. Подумайте, что будет выведено на экране – затем вставьте код и  проверьте себя.</p><h2>Задание</h2><p>Нужно, чтобы на экране последовательно появилось два алерта. В первом хочется увидеть количество всех элементов на странице с классом \"nav\". Во втором – количество всех элементов на странице с классом \"nav nav-tabs\".</p><p>Подсказки:</p><ul><li>Раньше мы использовали функцию поиска по тегам <code>document.getElementsByTagName(сюда имя тега в кавычках)</code>. Существует аналогичная функция для поиска по имени класса – <code>document.getElementsByClassName</code>.</li></ul>",
      "tKey": 1
    },
    {
      "name": "Функции и события",
      "html": "<h2>Понятие функции</h2><p>С функциями мы уже сталкивались, просто не афишировали внимание – это <code>alert()</code>, <code>getDocumentsByTagName()</code> и <code>getDocumentsByClassName()</code>.</p><p>Часто многие последовательности операторов приходится вызывать несколько раз. Чтобы не писать код несколько раз, во всех языках программирования есть понятие функции – набора операторов, который удобно многократно вызывать.</p><p>Функции <code>alert()</code> или <code>document.getDocumentsByTagName()</code> – это встроенные функции. Они есть в языке с самого начала, и мы можем ими сразу пользоваться. Их реализация скрывает в себе достаточно серьезную логику и большую программу – но благодаря функции мы можем запускать весь этот комплекс действий одной строкой.</p><p>Синтаксис функции определяется круглыми скобками. Везде, где видите круглые скобки – это либо вызов существующей функции, либо задание новой.</p><h3>Пользовательские функции</h3><p>Мы можем создавать функции самостоятельно. Это полезно для блоков кода, которые мы планируем вызывать несколько раз или из разных мест.</p><pre><code class=\"language-javascript\">// Вот так мы задаем новую функцию\n// с названием makeTwoAlerts\nfunction makeTwoAlerts() {\n  alert(\"Первый алерт\");\n  alert(\"Второй алерт\");\n}\n\n// А вот так – вызываем ее \nmakeTwoAlerts()</code></pre><p>Обратите внимание, как различаются синтаксис задания новой функции и синтаксис вызова функции. В обоих случаях есть круглые скобки, но в остальном синтаксис различается. </p><p>Хорошенько усвойте и запомните синтаксис объявления(задания) и вызова функций <a href=\"https://learn.javascript.ru/function-basics\">https://learn.javascript.ru/function-basics</a></p><h3>Аргументы функции</h3><p>Кода мы вызывали функции <code>alert</code> или <code>document.getElementsByTagName</code>, мы при вызове указывали внутри круглых скобок определенные значения, которые влияли на работу функций.</p><p>Это очень удобный механизм. В результате функции становятся более универсальными и их можно более гибко применять. Этот механизм называется <em>аргументами</em>, или <em>параметрами</em> функции. Внимательно прочитайте его объяснение на <a href=\"https://learn.javascript.ru/function-basics\">https://learn.javascript.ru/function-basics</a></p><p>Давайте попробуем небольшой пример с аргументами:</p><pre><code class=\"language-javascript\">// Задаем функцию с аргументами\nfunction addTwoNumbersAndMakeAlert(n1, n2) {\n  let sum;\n  sum = n1 + n2;\n  alert(sum);\n}\n// Несколько раз вызываем ее с разными аргументами\naddTwoNumbersAndMakeAlert(1, 2);\naddTwoNumbersAndMakeAlert(3, 4);\naddTwoNumbersAndMakeAlert(5, 6);</code></pre><h3>Внимание! Распространенная ошибка!</h3><p>Аргументы и их правильное использование – довольно сложная концепция для понимания новичка. Важнейший момент для понимания – снаружи функции, т.е. при ее вызове, <em>абсолютно все равно</em>, как были названы аргументы.</p><p>Тем не менее, новички часто пытаются выполнить подобный код: </p><pre><code class=\"language-javascript\">function addTwoNumbersAndMakeAlert(n1, n2) {\n   ...\n}\naddTwoNumbersAndMakeAlert(n1, n2)</code></pre><p>Естественно, переменные <code>n1</code> и <code>n2</code> на стадии вызова не объявлены, и возникает ошибка. Еще раз обратите внимание на то, как работает вызов функции. Первое выражение, которое мы написали при вызове в круглых скобках, попадет внутри функции в автоматически созданную переменную n1.  Второе выражение – в переменную n2. Эти переменные носят временный характер и существуют только внутри функции. Снаружи – они недоступны.</p><pre><code class=\"language-javascript\">function addTwoNumbersAndMakeAlert(n1, n2) {\n   //n1 здесь будет равно 10, а n2=200\n   //снаружи функции n1 и n2 недоступны и вообще не существуют\n}\nlet a=10;\nlet b=200;\naddTwoNumbersAndMakeAlert(a, b)</code></pre><h3>События (events)</h3><p>В клиентской части веб-разработки, которой мы сейчас занимаемся, вызов большинства функций происходит в результате каких-то действий пользователя – нажатий на кнопки, ввода данных и т.п.</p><p>Для этого используется механизм событий. В браузере существует заранее определенный список событий (иногда немного отличающийся для разных HTML элементов), на которые мы можем реагировать.</p><p>Почитайте подробнее о событиях – <a href=\"https://developer.mozilla.org/ru/docs/Web/Events\">https://developer.mozilla.org/ru/docs/Web/Events</a></p><p>Ключевым в механизме событий является выполнение \"подписки\" на определенное событие. </p><ol><li>Сначала мы должны создать свою функцию с определенным именем – она будет вызываться каждый раз, как произойдет событие. Предназначенные для этого пользовательские функции часто называют <em>обработчиками событий</em> (event handlers)</li><li>Затем заполучить в какую-нибудь переменную HTML-элемент, на котором мы хотим реагировать на события;</li><li>В каждом HTML-элементе есть встроенная функция <code>addEventListener</code>, которая берет два аргумента – название события, и функцию-обработчик. Нам нужно вызвать этот <code>addEventListener</code> – и теперь все события указанного типа будут автоматически вызывать нашу функцию.</li></ol><pre><code>В HTML:\n&lt;button class=\"btn btn-primary\" id=\"my-custom-id\"&gt;Кликни меня&lt;/button&gt;\n\nВ javascript:\nfunction myButtonClickHandler(event) {\n  alert(\"Вызвана функция-обработчик!\");\n}\nlet button;\nbutton = document.getElementById(\"my-custom-id\");\nbutton.addEventListener(\"click\", myButtonClickHandler);</code></pre><h2>Задание</h2><p>Сверстайте две кнопки – зеленую и синюю по стилям бутстрапа <a href=\"https://getbootstrap.com/docs/4.1/components/buttons/\">https://getbootstrap.com/docs/4.1/components/buttons/</a>. Разместите их перед длинным текстом описания продукта. Клик по первой кнопке должен вывести количество элементов с классом <code>nav</code>. Клик по второй – количество элементов с классом <code>nav nav-tabs</code>.</p><h3>Подсказки и требования</h3><ul><li>Выводом должна заниматься одна функция. Давайте назовем ее showElementsLength.</li><li>В качестве аргумента она должна принимать имя класса и его использовать в своей внутренней работе. Аргумент – давайте назовем <code>className</code>.</li><li>В <code>javascript</code> все идентификаторы (названия функция, переменных и т.п.) принято именовать с помощью соглашения mixedCase, которое является модификацией <a href=\"https://ru.wikipedia.org/wiki/CamelCase\">https://ru.wikipedia.org/wiki/CamelCase</a>. При этом соглашении, если название должно состоять из нескольких слов – первое слово пишется с маленькой буквы, а остальные – с большой. Имейте в виду, что javascript различает большие и маленькие буквы. Для него <code>someVariable</code> и <code>SomeVariable</code> – абсолютно разные переменные.</li></ul>",
      "tKey": 2
    },
    {
      "name": "Изменение DOM-элементов",
      "html": "<p>До этого наш javascript-код только выводил на экран какую-то информацию. Давайте научимся влиять на элементы веб-страницы.</p><h2>Задание</h2><p>Сделайте, чтобы клик на первую ссылку меню (\"Услуги\") делал ее активной.</p><h3>Подсказки</h3><p>Вы уже знаете, как заполучить в переменную какой-нибудь HTML-элемент. Для этого есть функции <code>document.getElementsByClassName</code>, <code>document.getElementsByTagName</code>, <code>document.getElementById</code>. </p><p>Обратите внимание, что первые две функции возвращают массив элементов, а третья – сам элемент. То есть, если использовать одну из первых функций, элемент нужно будет в начале достать из массива.</p><pre><code class=\"language-javascript\">let htmlElement;\n\nlet someElements = document.getElementsByTagName(\"li\");\n// htmlElement нужно извлекать из массива\nhtmlElement = someElements[0];\n\n// Но если у html-элемента задан id, то можно найти элемент сразу:\nhtmlElement = document.getElementById(\"some_id\");</code></pre><p>Вы знаете, что нужно сделать, чтобы элемент выглядел активным – присвоить ему в HTML соответствующий класс.</p><p>Вы не знаете только, как можно из <code>javascript</code> считывать и модифицировать класс у HTML-элемента, давайте это исправим:</p><pre><code class=\"language-javascript\">// до этого мы как-то записали в переменную htmlElement нужный нам элемент\nalert(htmlElement.className);\nhtmlElement.className = \"nav-link active\";</code></pre><p>Еще один важный момент – если у ссылки, на которую кликают, установлено свойство <code>href</code> – то ваш клик не будет обработан. Точнее, он будет обработан, но вы не успеете заметить результат – так как браузер сразу же после обработки немедленно перейдет на URL, указанный в <code>href</code>.</p><p>Решением является остановить поведение по умолчанию для ссылки – чтобы клик по ней не приводил к навигации. Для этого в обработчике нашего события нужно вызвать функцию <code>event.preventDefault()</code></p>",
      "tKey": 3
    },
    {
      "name": "Циклы",
      "html": "<p>Теперь давайте сделаем, чтобы активироваться могли все ссылки меню, а не только первая.</p><p>Перечислять все элементу по одному и на каждый подписываться – утомительно и неправильно. А что, если в меню добавятся еще элементы? Нам придется каждый раз модифицировать код?</p><p>Для этого в javascript, как и практически во всех языках программирования, используются циклы.</p><p>Внимательно изучите, как работают циклы в javascript – <a href=\"https://javascript.ru/for\">https://javascript.ru/for</a> или <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for</a></p><p>Циклы очень удобно использовать для прохода по массиву. Благодаря циклу, мы сможем использовать один и тот же блок кода множество раз – по одному разу на каждый элемент массива. И при каждом прохождении нам будет доступно разное значение переменной-итератора, каждый раз на +1 больше. Это позволит нам удобно ссылаться на каждый следующий элемент массива.</p><p>Вот пример кода, который проходит по всем тегам <code>li</code> и ставит им класс \"active\" (имейте в виду, это только пример и совсем не то, что нам нужно!)</p><pre><code class=\"language-javascript\">let items = document.getElementsByTagName(\"li\");\nfor (let i=0; i &lt; items.length; i++) {\n  let item = items[i];\n  item.className = \"active\";\n}</code></pre><h2>Задание</h2><blockquote><p>Сделайте, чтобы клик по любому элементу меню делал его активным.</p></blockquote><h3>Подсказки и требования</h3><p>Назовите обработчик события <code>menuClickHandler</code>.</p><p>В цикле нам нужно будет \"навешивать\" этот обработчик на текущий элемент li. Когда мы находимся внутри цикла, мы знаем, что такое \"текущий элемент\". Но когда пользователь кликнет, и мы попадем в обработчик – обработчику уже не будет доступна переменная-итератор <code>i</code> из цикла – потому что цикл давным-давно закончился – мы ведь вешали обработчики сразу после загрузки страницы. Как из обработчика понять, какой именно элемент нам модифицировать?</p><p>Решение заключается в следующем. Когда мы вешаем обработчик с помощью встроенного браузерного метода <code>addEventListener</code>, браузер передаст нашему хэндлеру объект <code>event</code>, который содержит всю информацию о произошедшем событии – в том числе и о элементе, который был кликнут.</p><p>Важно понимать, что браузер будет передавать нашему хэндлеру этот объект в любом случае, даже если при задании обработчике события мы не указывали никаких аргументов. Просто в этом случае объект с событием будет нам недоступен.</p><pre><code class=\"language-javascript\">function menuClickHandler() {\n  //Поскольку мы не указали аргументов, нам неоткуда взять информацию о событии\n  ...\n}\n...\nsomeElement.addEventListener(\"click\", menuClickHandler);</code></pre><p>Поэтому нам нужно при объявлении хэндлера указать, что у него есть аргумент с любым названием. В этой переменной будет доступен объект типа event с нужной информацией.</p><pre><code class=\"language-javascript\">function menuClickHandler(eventHappened) {\n  //Ура! Объект события доступен в переменной eventHappened\n  alert(eventHappened);\n}\n...\nsomeElement.addEventListener(\"click\", menuClickHandler);</code></pre><p>И как же нам \"вытащить\" искомый <code>&lt;li&gt;</code> или <code>&lt;a&gt;</code>, который находится внутри него, из события? Объект класса <code>Event</code> детально описан здесь – <a href=\"https://developer.mozilla.org/ru/docs/Web/API/Event\">https://developer.mozilla.org/ru/docs/Web/API/Event</a>. Обратите особое внимание на свойства <code>target</code> и <code>currentTarget</code>. Разберитесь, в чем разница между этими свойствами, и в котором из них нужный нам элемент – в <code>eventHappened.target</code>или в <code>eventHappened.currentTarget</code></p>",
      "tKey": 4
    },
    {
      "name": "Доступ к дочерним и родительским элементам",
      "html": "<p>В результате выполнения прошлого задания у нас появился неожиданный эффект. Теперь кликать можно не только по ссылкам в меню – но и по ссылкам в переключалке табов – поскольку она тоже состоит из элементов li. </p><blockquote><p>Если у вас не работают клики по табам – скорее всего вы не удалили из них атрибуты <code>href</code>, как было сказано в одном из прошлых тасков. Клики работают, просто вы не успеваете этого заметить, тк страница быстро обновляется. Удалите из всех ссылок навигации атрибут href</p></blockquote><p>Может быть, обработка кликов в табах и неплохое поведение, но это точно не то, что было в техническом задании. Давайте избавимся от этого эффекта.</p><p>Для этого нам нужно научиться работать с \"деревом\" HTML-страницы, обращайсь к дочерним или родительским элементам. Это довольно просто. </p><p>Дочерние элементы находятся в свойстве <code>childNodes</code>, а родительский элемент – в <code>parentNode</code>.</p><pre><code class=\"language-javascript\">let someList = document.getElementById(\"some_id\");\nlet firstChildOfTheList = someList.childNodes[0];\nlet amountOfChildren = someList.childNodes.length;\n\n// Конечно, после этой команды значения в переменных parent и someList будут полностью эквивалентны\nlet parent = firstChildOfTheList.parentNode;</code></pre><h2>Задание</h2><p>Нужно сделать, чтобы по клику активировались только ссылки верхнего меню.</p><h3>Требования и подсказки</h3><p>Нужно вытащить в переменную <code>topMenu</code> блок меню (который <code>&lt;ul class=\"nav\"&gt;</code>). И цикл запустить не по всем элементам с тегом <code>&lt;li&gt;</code>, а по массиву <code>topMenu.childNodes</code>.</p>",
      "tKey": 5
    },
    {
      "name": "Деактивация соседних ссылок, отладка и querySelectorAll",
      "html": "<p>У нас есть одна проблема – когда мы кликаем по ссылке, остальные ссылки по-прежнему остаются активными. Естественно, это не то поведение, которого ожидает пользователь. </p><p>Нам нужно научиться деактивировать остальные вкладки, чтобы активной была только одна.</p><p>Давайте для начала напишем функцию, которая занимается деактивацией вкладок. В качестве аргумента она будет принимать nav – блок навигации, в котором нужно деактивировать все вкладки. Так мы сделаем ее универсальной, и в дальнейшем сможем применять для любых навигацинных блоков на странице.</p><p>Первое, что приходит в голову – воспользоваться свойством childNodes и сделать вот так:</p><pre><code class=\"language-javascript\">function deactivateAll(nav) {\n  let items = nav.childNodes;\n  for (let i = 0; i &lt; items.length; i++) {\n    let li = items[i];\n    let a = li.childNodes[0];\n    a.className = \"nav-link\";\n  }\n}</code></pre><p>Особенность бутстрапа в том, что для активации класс нужно назначить не элементу списка <code>&lt;li&gt;</code>, а вложенному в него элементу <code>&lt;a&gt;</code>. Поэтому мы вынуждены сначала получить указатель на <code>&lt;li&gt;</code>, а затем, опять с помощью childNodes – вложенному в него элементу <code>&lt;a&gt;</code>. </p><p>Попробуйте добавить к себе эту функцию и вызвать ее для верхнего меню сразу же после загрузки страницы:</p><pre><code class=\"language-javascript\">let topMenu = document.getElementsByTagName(\"ul\")[0];\ndeactivateAll(topMenu);</code></pre><p>Однако, ожидаемого результата мы не получим. Давайте научимся самостоятельно разбираться, в чем заключается проблема. Для этого нам понадобится <code>Inspector</code> – встроенный в Google Chrome инструмент для разработчиков.</p><p>Откройте jsfiddle в Хроме (если до этого работали в другом браузере). Нажмите F12, если вы работаете в Windows, или Alt-Cmd-i, если на Маке.</p><p>В появившейся панели откройте вкладку Console.  В консоли браузер пишет все проблемные места, связанные с запуском кода. В нашем случае он сообщит следующее:</p><blockquote><p>Uncaught TypeError: Cannot set property 'className' of undefined\n    at deactivateAll ((index):83)\n    at window.onload ((index):87)</p></blockquote><p>И мы понимаем, что проблема находится в функции <code>deactivateAll</code>. Давайте поставим туда <code>breakpoint</code> – точку останова, чтобы вживую посмотреть, что там происходит. Для этого модифицируйте код функции следующим образом (впишите строку <code>debugger</code>):</p><pre><code class=\"language-javascript\">function deactivateAll(nav) {\n  let items = nav.childNodes;\n  debugger;\n  for (let i = 0; i &lt; items.length; i++) {\n    let li = items[i];\n    let a = li.childNodes[0];\n    a.className = \"nav-link\";\n  }\n}</code></pre><p>Теперь, если вы обновите страницу с открытым инспектором (можно нажать Run в jsFiddle), инспектор покажет вам ваш код, на котором строчка debugger; будет отмечена синим.</p><p><img alt=\"Окно инспектора с точкой останова\" src=\"/img/tasks/debugger-1.png\"></p><p>Про работу с инспектором написано много статей, например <a href=\"https://learn.javascript.ru/debugging-chrome\">https://learn.javascript.ru/debugging-chrome</a></p><p>Одна из самых важных его функций с точки зрения разработки на <code>javascript</code> – это возможность приостановить выполнение программы в любой момент, посмотреть текущие значения переменных и продолжить отладку в пошаговом режиме.</p><p>Нас в данный момент интересует только значение переменной <code>items</code>. По пока неизвестной нам причине, элементы <span>&lt;li&gt;</span>, которые мы из нее извлекаем – не соответствуют нашим ожиданиям и приводят к ошибке.</p><p>Чтобы посмотреть значение переменной, достаточно просто навести на нее курсор – инспектор покажет ее значение во всплывающем окне.</p><p><img alt=\"Окно инспектора с показанной переменной\" src=\"/img/tasks/debugger-2.png\"></p><p>Теперь причина очевидна. Мы ожидали, что внутри этого блока будут только <code>&lt;li&gt;</code>. Но туда затесались совершенно ненужные нам текстовые узлы – <code>TextNode</code>. Это пробелы, которые получаются у нас из-за переносов строк в HTML и из-за отступов.</p><p>Что с ними делать? Первое решение – удалить их из HTML – кажется крайне неудобным, т.к. код в HTML будет страшно неудобно смотреть. </p><p>Для таких случаев есть еще одна удобная функция запроса элементов – <code>querySelectorAll</code>. Она умеет вытаскивать HTML-элементы по их селектору, синтаксис которого примерно соответствует синтаксису селекторов в CSS. И самая важная для нас особенность – эту функцию можно вызвать не для всего <code>document</code>, а для какого-то конкретного элемента. В этом случае поиск элементов, соответствующих селектору, будет производиться только для \"потомков\" этого родительского элемента.</p><p>Давайте изменим наш код с использованием  querySelectorAll:</p><pre><code class=\"language-javascript\">function deactivateAll(nav) {\n\tconst links = nav.querySelectorAll(\"a\");\n\tfor (let i = 0; i &lt; links.length; i++) {\n\t  const link = links[i];\n    link.className = \"nav-link\";\n\t}\n}</code></pre><p>Теперь у нас есть все инструменты для деактивации соседних вкладок.</p><h2>Задание</h2><p>Сделать, чтобы и меню, и табы полноценно переключались. Клик на меню или таб должен приводить к его активации, при этом все соседи этого элемента должны деактивироваться.</p><h3>Посказки</h3><ul><li>Кусок кода, который у нас раньше отвечал за подписку на события, нужно обернуть внутрь функции <code>makeNavInteractive</code>. Мы будем вызывать эту функцию дважды – для меню и для списка табов. Поэтому давайте сделаем ей аргумент <code>nav</code>, в котором при вызове будем передавать ей соответствующий блок навигации. Естественно, подписывать на события она должна всех детей, полученных из html-элемента, полученного в аргументе nav.</li><li>Наш <code>clickHandler</code> теперь должен не только активировать ссылку, но и вызывать функцию deactivateAll. Напомним, что эта функция тоже ждет в качестве аргумента HTML-узел с конкретной навигацией. Поскольку в <code>clickHandler</code> мы уже умеем получать ссылку, на которой был клик – получение самой навигации не составит труда. Нужно всего лишь дважды применить свойство <code>parentNode</code>. Первый раз – для получения <code>&lt;li&gt;</code>, как непосредственного предка ссылки. Затем – уже для навигации, как непосредственного предка <code>&lt;li&gt;</code>.</li></ul>",
      "tKey": 6
    }
  ]
},{
  "_id": {
    "$oid": "5be0be72c5950a60f97502bd"
  },
  "name": "Интерактив на React",
  "html": "<p>В предыдущем юните мы делали интерактив на чистом javascript, без применения современных библиотек. Это не очень эффективно, и в современном мире веб-разработки делается крайне редко. </p><p>Вместо этого используются современные библиотеки и фреймворки, которые позволяют значительно ускорить процесс разработки. На данный момент лидерами среди них являются библиотека React от фейсбука и Vuejs от китайской коммунистической партии.</p><p>Мы будем изучать React (<a href=\"https://reactjs.org/\">https://reactjs.org/</a>), как чуть более распространенный.</p>",
  "uKey": 4,
  "tasks": [
    {
      "name": "Классы и ООП",
      "html": "<p>Перед тем, как начать осваивать React, нам важно разобраться с еще одной довольно сложной концепцией. Она называется ООП – объектно-ориентированное программирование, и в том или ином виде присутствует почти во всех языках.</p><p>Для понимания ООП нужно усвоить несколько понятий.</p><ol><li>Класс – это механизм, который позволяет быстрое создание объектов с одинаковым функционалом, но разными данными. </li><li>Экземпляр, или инстанс (instance) класса – объект, созданный с помощью этого класса</li><li>Конструктор – специфичная для класса функция, которая отвечает за создание новых объектов.</li><li>Указатель this – это ссылка на специфичную для экземпляра копию данных. Она доступна из любой функции, относящейся к классу.</li></ol><p>Давайте посмотрим простой пример.</p><pre><code class=\"language-javascript\">class Nav {\n  constructor(nav) {\n     this.nav = nav;\n     this.activeItemIndex = 0;\n  }\n  \n  activateItem(itemIndex) {\n    ...\n    this.activeItemIndex = itemIndex;\n  }\n}\n\nlet instance1 = new Nav(document.getElementById(\"some_id\"));\nlet instance2 = new Nav(document.getElementById(\"some_id_2\"));\ninstance1.activateItem(1);\ninstance2.activateItem(2);</code></pre><p>Давайте разберемся, что происходит в этом псевдокоде:</p><ol><li>Мы задаем класс <code>Nav</code> с помощью ключевого слова <code>class</code>. Все, что между открывающей и закрывающей фигурной скобкой – функционал данного класса. Подробнее синтаксис класса описан на <a href=\"https://learn.javascript.ru/es-class\">https://learn.javascript.ru/es-class</a></li><li>Первая функция внутри класса – это конструктор. Задача конструктора – выполнить все необходимые действия, когда пользователь хочет создать инстанс класса. Обычно это заполнение начальными значениями собственного набора данных, доступного в указателе <code>this</code>. У конструктора в данном случае задан один аргумент – <code>nav</code>. При создании экземпляра класса пользователю потребуется передать сюда HTML-элемент блока навигации. Задача конструктора – просто сохранить его в <code>this</code>, чтобы он был позднее доступен из любых других функций класса.</li><li>В классе задана еще одна функция – <code>activateItem</code>. Предполагается, что ее можно вызвать для переключения активной вкладки. Ее код пока не дописан – она всего лишь сохраняет номер активной вкладки в <code>this</code>.</li><li>После того, как мы закончили описывать класс, мы создаем два инстанса. Инстанс всегда создается с ключевым словом <code>new</code>, после которого следует название класса и перечисляются аргументы для его конструктора. От вызова обычной функции эта конструкция отличается только словом <code>new</code>.</li><li>После того, как инстансы созданы, мы вызываем их методы для активации вкладки.</li></ol><blockquote><p>Обратите внимание – начиная с этого таска, мы больше не будем пользоваться встроенным редактором кода. Для выполнения заданий мы будем использовать внешнюю песочницу <a href=\"https://jsfiddle.net\">https://jsfiddle.net</a>. В ней можно сохранить результат выполнения кода как ссылку – и приложить в качестве комментария к заданию. Песочница jsFiddle обладает интуитивно понятным интерфейсом, хотелось бы пояснить только один момент, часто вызывающий недопонимание у студентов. Если преподаватель возвращает ваше задание на доработку, вы можете внести изменения в уже существующий fiddle – для этого нужно будет нажать кнопку Update на панели инструментов. Обратите внимание – URL вашего кода при этом поменяется, и вам нужно будет заново его скопировать и вставить в комментарий к заданию.</p></blockquote><h2>Задание</h2><p>Это был теоретический минимум по ООП. Теперь давайте воплотим его на практике – перепишем нашу интерактивную навигацию на классах. </p><h3>Требования и подсказки</h3><ul><li>Нужно завернуть все методы внутрь класса. Это крайне полезно с точки зрения организации кода. На странице может быть и другой функционал, и засорять глобальное пространство различными функциями – плохая идея. Всего, для успешной работы классу потребуются следующие функции: <code>constructor</code>, <code>addEventListeners</code>,  <code>clickHandler</code> и <code>activateItem</code>.</li><li>Поскольку мы договорились, что вся работа по инициализации должна выполняться в конструкторе – из конструктора необходимо будет вызвать <code>this.addEventListeners()</code>, которая будет осуществлять подписку на события кликов для всех ссылок внутри <code>this.nav</code>.</li><li>При реализации <code>addEventListeners</code> воспользуйтесь <code>querySelectorAll</code>. Не забывайте, что внутри всех функций класса вам доступна переменная <code>this.nav</code>.</li><li>Поскольку функция <code>clickHandler</code> тоже становится членом класса и будет использовать this, нам нужно позаботиться, чтобы при ее вызове не потерялся контекст. Дело в том, что вызываеть ее будем не мы, а браузер в момент клика. В таких случаях он всегда теряет контекст. Чтобы этого избежать, при подписке на событие клика нужно будет передавать не <code>this.clickHandler</code>, а <code>this.clickHandler.bind(this)</code>. Подробнее о биндинге и потере контекста тут – <a href=\"https://learn.javascript.ru/bind\">https://learn.javascript.ru/bind</a></li><li>Функция <code>activateItem(index)</code> должна не только установить переменную this.activeItemIndex, но и позаботиться об обновлении интерфейса. Прямо в этой функции удалите класс <code>active</code> со всех ссылок внутри <code>this.nav</code>, а затем из массива этих ссылок возьмите одну с номером <code>this.activeItemIndex</code> и установите для нее класс <code>active</code>.</li><li>Естественно, функция <code>clickHandler</code>должна всего лишь вызвать <code>this.activateItem</code> с правильным номером. Однако, откуда ей взять правильный номер кликнутой ссылки? (Раньше у нас такой проблемы не было, поскольку мы активировали класс прямо из хэндлера). Самое простое решение – установить заранее для каждой из ссылок дополнительный HTML-атрибут <code>data-index</code>, и записать в него порядковый номер ссылки. Сделать это лучше всего из <code>addEventListeners</code>, установкой атрибута занимается встроенная в браузер функция <code>link.setAttribute(\"data-index\", index)</code>. Тогда в <code>clickHandler</code> мы просто прочитаем этот индекс с помощью <code>link.getAttribute(\"data-index\")</code> и легко получим нужное значение.</li><li>После того, как закончите описывать класс, вытащите из страницы верхнюю навигацию и переключалку табов – и создайте два инстанса классов, передав им эти переменные с навигацией. Все должно заработать. </li></ul><blockquote><p>Механизм bind, которым мы пользуемся, можно считать устаревшим. Правильная альтернатива – использование стрелочных функций. Однако, версия JS, которую использует JSFiddle, не слишком новая и пока не умеет обрабатывать стрелочные функции в качестве членов класса. Подробнее <a href=\"https://stackoverflow.com/questions/31362292/how-to-use-arrow-functions-public-class-fields-as-class-methods\">https://stackoverflow.com/questions/31362292/how-to-use-arrow-functions-public-class-fields-as-class-methods</a> </p></blockquote>",
      "tKey": 1
    },
    {
      "name": "Знакомство с jsx",
      "html": "<p>Код в React-приложениях пишется на специальном диалекте языка <code>javascript</code>, который называется <code>jsx</code> (Java Script eXtended). Его основная особенность – прямо в коде javascript можно писать как простые HTML-теги, так и сложные конструкции и обращаться с ними как с обычными переменными.</p><p>Вот несколько примеров:</p><pre><code class=\"language-jsx\">let hutoriumLinkText = \"Хуториум\";\nlet hutoriumLinkHref = \"http://hutorium.ru\";\nlet hutoriumLink = &lt;a href={ hutoriumLinkHref }&gt;{ hutoriumLinkText }&lt;/a&gt;;\nlet myLinks = &lt;ul&gt;\n  &lt;li&gt;{ hutoriumLink }&lt;/li&gt;\n  &lt;li&gt;&lt;a href=\"http://poselok-programmistov.ru\"&gt;Поселок программистов&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;;\nlet linkInsideAlert = &lt;div className=\"alert\"&gt;\n  &lt;li&gt;{ hutoriumLink }&lt;/li&gt;\n&lt;/div&gt;</code></pre><p>Когда мы задаем эти HTML теги – мы можем в любой момент использовать доступные нам переменные и любые javascript-выражения, заключив их в фигурные скобки. Это можно делать как для атрибутов, так и для контента внутри тегов – как видно на примере <code>hutoriumLink</code>. </p><p>Поскольку сама <code>hutoriumLink</code> теперь является обычной переменной – мы точно так же можем вставить ее в верстку более сложных компонентов – как мы видим на примере <code>myLinks</code> и <code>linkInsideAlert</code>.</p><blockquote><p>Обратите внимание – когда мы описывали <code>linkInsideAlert</code>, для присвоения класса мы использовали атрибут <code>className</code> вместо привычного <code>class</code>. Это не слишком приятная особенность языка jsx. Дело в том, что в javascript слово <code>class</code> является зарезервированным, и обозначает сосем не классы HTML-элементов. Разработчики JSX решили обойти эту проблему вот такой заменой. В общем, в дальнейшем для обозначения HTML-классов в <code>jsx</code> будем использовать <code>className</code>. </p></blockquote><p>Нужно понимать, что современные браузеры пока не понимают JSX в чистом виде – для этого приходится или использовать специальные средства и эмуляторы (как например в jsFiddle), или перед выгрузкой финального кода на боевые сервера транслировать (т.е. переводить) файлы jsx в обычный javascript.</p><p>Чтобы не терять времени, давайте форкнемся от небольшой заготовки для наших дальнейших разработок и посмотрим, из чего она состоит:\n<a href=\"https://jsfiddle.net/4d3tg6mn/\">https://jsfiddle.net/4d3tg6mn/</a></p><p>Первое, что бросается в глаза – в блоке HTML практически пусто. Это нормальная практика для React-приложений, поскольку вся генерация HTML будет делаться средствами JSX, который находится в окошке <code>javascript</code>.</p><p>Все, что нам требуется от блока HTML – просто подключить необходимые стили и создать пустой <code>&lt;div&gt;</code>, в который наш jsx будет встраивать свою верстку.</p><pre><code class=\"language-html\">&lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css\" crossorigin=\"anonymous\"&gt;\n&lt;div id=\"target\"&gt;&lt;/div&gt;</code></pre><p>Теперь давайте посмотрим на блок javascript.</p><ol><li>В начале – идет уже знакомый нам блок кода, который готовит переменную <code>myLinks</code>. </li><li>С помощью инструмента ReactDOM мы выводим (\"рендерим\") эту переменную внутрь дива с <code>id=\"target\"</code>, созданного в блоке HTML.</li></ol><p>Функции <code>ReactDOM.render</code> требуется два аргумента –  выражение, содержащая верстку (в нашем случае переменная <code>myLinks</code>) и реальный  HTML-элемент со страницы, в который эта верстка будет помещена.</p><h2>Задание</h2><p>Перенесите нашу верстку карточки продукта в формат <code>jsx</code> и отрисуйте ее на странице с помощью ReactDOM.render()</p><h3>Подсказки</h3><ul><li>Наша старая верстка состояла из трех корневых тегов – <code>&lt;header&gt;</code>, <code>&lt;main&gt;</code>, <code>&lt;footer&gt;</code>. Но в переменную jsx можно поместить только один тег (либо массив тегов, но пока так не делаем). Решение – давайте обернем нашу верстку еще в один внешний <code>div</code>, тогда его без проблем  можно поместить в переменную;</li><li>Не забудьте поменять везде <code>class</code> на <code>className</code>;</li><li>Не забудьте перенести наш CSS.</li></ul>",
      "tKey": 2
    },
    {
      "name": "Компоненты React",
      "html": "<p>Компоненты – это ключевое понятие React. С точки зрения языка <code>javascript</code>, компонент – это обычный класс, который мы проходили пару занятий назад. Но инстансы этого класса – не просто переменные, а jsx-верстка. И создаются инстансы не с помощью оператора <code>new</code>, а с помощью обычного jsx-синтаксиса для тегов.</p><p>Давайте посмотрим пример.</p><pre><code class=\"language-jsx\">class MyComponent extends React.Component {\n  render() {\n    return &lt;div&gt;Hello from component&lt;/div&gt;;\n  }\n}\nconst instance = &lt;MyComponent&gt;&lt;/MyComponent&gt;;\nReactDOM.render(instance, document.getElementById(\"target\"));</code></pre><p>Давайте разберем этот код.</p><ol><li>Мы создаем обычный класс, как делали раньше. Но на этот раз в строке определения классов появилось новое слово <code>extends</code>. Это обычная для <code>javascript</code> конструкция – так делается наследование классов. В результате все инстансы нашего класса будут наследовать часть функционала от стандартного класса   React.Component, что очень удобно. Познакомьтесь подробнее с концепцией наследования – <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/extends\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/extends</a> или <a href=\"https://learn.javascript.ru/es-class\">https://learn.javascript.ru/es-class</a> </li><li>Внутри класса мы объявляем только одну функцию <code>render</code>. В реакт-компонентах это самая важная функция – она отвечает за отрисовку итоговой верстки. Все, что она вернет – будет составлять итоговый HTML каждого инстанса компонента. </li><li>Мы создаем инстанс компонента так, как будто наш класс – обычный тег <code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code>. В этом заключается одно из основных удобств реакта – мы можем создавать сложные компоненты с кучей функционала, использованием внутри других компонентов и гибкой настройкой – а в верстку вставлять их как обычные div-ы.</li></ol><blockquote><p>Важный момент про возврат значения из функции. До этого все функции, которые мы создавали, выполняли определенный функционал, но не возвращали значение. Хотя мы косвенно пользовались возвращаемыми значениями встроенных функций – например, когда вызывали <code>let item = document.getElementById(\"some_id\")</code>. Для этого внутри функций используется ключевое слово <code>return</code> – все, что указано после него, будет считаться результатом выполнения функции – т.е. может быть куда-нибудь записано после вызова  (в переменную <code>item</code> в указанном примере). Подробности <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/return\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/return</a></p></blockquote><h2>Задание</h2><p>Перепишите наш код, чтобы вся верстка отрисовывалась через React-компонент.</p><h3>Подсказки и требования</h3><ul><li>Назовите создаваемый компонент <code>App</code>. Это общепринятое название для корневого элемента веб-страницы в реакте (Сокращение от application – приложение).</li><li>В функции <code>render</code> компонента  напишите <code>return</code> и верните всю требуемую верстку.</li><li>Создайте инстанс вашего компонента и запишите его в переменную app.</li><li>Выведите его с помощью вызова <code>ReactDOM.render()</code>.</li><li>Можно сделать более короткий, но пока чуть более сложный для понимания вариант – не создавать переменную, а вызвать создание инстанса компонента сразу же при вызове <code>ReactDom.render</code>, вот так: <code>ReactDOM.render(&lt;App&gt;&lt;/App&gt;, ...)</code>. Или, поскольку у тега нет внутреннего контента, можно использовать сокращенную форму записи тега <code>ReactDOM.render(&lt;App /&gt;, ...)</code></li></ul>",
      "tKey": 3
    },
    {
      "name": "Свойства компонентов (props)",
      "html": "<p>Как уже упоминалось, React-компонент – это обычный javascript-класс с парой особенностей.</p><ul><li>Должен наследоваться от <code>React.Component</code>;</li><li>Инстанс создается не с помощью <code>new</code>, а как HTML-тег;</li><li>Инстанс представляет собой jsx-верстку, а не просто обычный объект.</li></ul><p>Когда мы создаем инстанс обычного класса, у нас есть возможность передавать конструктору аргументы, чтобы каждый инстанс чем-то отличался <code>const tabNav = new Nav(document.getElementId(\"tab-nav\"))</code>. А как нам передавать аргументы в React-компонент?</p><pre><code class=\"language-jsx\">const MessageBox = class extends React.Component {\n  render() {\n    return &lt;div&gt;\n      &lt;h1&gt;{ this.props.header }&lt;/h1&gt;\n      &lt;p&gt;{ this.props.text }&lt;/p&gt;\n    &lt;/div&gt;;\n  }\n}\nReactDOM.render(&lt;MessageBox header=\"Привет!\" text=\"Тут какой-нибудь текст\" /&gt;, document.getElementById(\"target\"))</code></pre><p>Как мы видим, аргументы передаются в инстанс компонента с помощью обычных HTML-атрибутов – точно так же, как мы передавали бы <code>href</code> или <code>class</code> для тегов обычной верстки.</p><p>Конструктор берет все полученные таким образом атрибуты и складывает их в объект <code>this.props</code> – так что они становятся доступны из любой функции внутри класса. В примере мы видим, как метод <code>render</code> использует <code>this.props.header</code> и <code>this.props.text</code>.</p><p>Поскольку мы создаем инстанс компонента как обычный HTML-тег и даже используем атрибуты – мы по всем правилам HTML можем задать этому тегу какой-нибудь внутренний контент. Что произойдет с этим контентом? Будет ли он выведен на экран, ведь отрисовкой компонента полностью управляет функция <code>render()</code>?</p><pre><code>&lt;MessageBox header=\"Привет!\" text=\"Тут какой-нибудь текст\"&gt;\n  &lt;h3&gt;Подзаголовок&lt;/h3&gt;\n  &lt;ul&gt;\n    &lt;li&gt;Пункт 1&lt;/li&gt;\n    &lt;li&gt;Пункт 2&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/MessageBox&gt;</code></pre><p>Ответ – нет, внутренний контент не будет выведен, поскольку функция <code>render</code> никак его не использует. Однако, конструктор компонента поместит этот внутренний контент в <code>this.props</code>, и мы сможем им пользоваться! Если логика нашего компонента подразумевает такое обращение с ним, мы можем просто вывести этот контент в функции <code>render</code>:</p><pre><code class=\"language-jsx\">const MessageBox = class extends React.Component {\n  render() {\n    return &lt;div&gt;\n      &lt;h1&gt;{ this.props.header }&lt;/h1&gt;\n      &lt;p&gt;{ this.props.text }&lt;/p&gt;\n      \n      &lt;h4&gt;Дополнительно:&lt;/h4&gt;\n      { this.props.children }\n    &lt;/div&gt;;\n  }\n}\nReactDOM.render(\n  &lt;MessageBox header=\"Привет!\" text=\"Тут какой-нибудь текст\"&gt;\n    &lt;h3&gt;Подзаголовок&lt;/h3&gt;\n    &lt;ul&gt;\n      &lt;li&gt;Пункт 1&lt;/li&gt;\n      &lt;li&gt;Пункт 2&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/MessageBox&gt;, \n  document.getElementById(\"target\")\n);</code></pre><p><code>this.props.children</code> представляет собой не один jsx-тег, а обычный javascript-массив, состоящий из jsx-тегов. В нашем случае массив полученный массив будет вот таким:</p><pre><code class=\"language-jsx\">[\n  &lt;h3&gt;Подзаголовок&lt;/h3&gt;,\n  &lt;ul&gt;&lt;li&gt;Пункт 1&lt;/li&gt;&lt;li&gt;Пункт 2&lt;/li&gt;&lt;/ul&gt;\n]</code></pre><p>В результате внутри функций класса мы можем обращаться к <code>this.props.children</code> как к обычному массиву. Например, использовать для каких-нибудь вычислений или отрисовки его длину <code>this.props.children.length</code>, или вывести из этого массива только один элемент с заданным номером <code>this.props.children[0]</code>.</p><h2>Задание</h2><p>Давайте сделаем белую плашку товара отдельным компонентом, передав ему текст заголовка в виде обычного свойства <code>title</code>, а остальной контент – в виде внутреннего содержимого тега.</p><h3>Подсказки и требования</h3><ul><li>Рекомендуемое название класса – <code>ProductBox</code>. Обратите внимание на политику именования – раньше для переменных и функций мы использовали везде <code>mixedCase</code>, т.е. первое слово сложного названия начиналось с маленькой буквы. Для имен классов в <code>javascript</code> используют соглашение <code>CamelCase</code>, когда и первое, и все последующие слова пишутся с большой буквы.</li><li>Метод <code>render</code> вашего нового компонента отрисовывает <code>this.props.title</code> cамостоятельно, а остальной контент – просто используя <code>this.props.children</code></li><li>Не забудьте, что вам нужно сохранить класс <code>product</code> для карточки продукта, чтобы она нормально стилизовалась. Для этого методу <code>render</code> нужно позаботиться, чтобы возвращаемый им тег имел соответствующий класс. Еще помните, как надо задавать HTML-класс в jsx-верстке?</li><li><code>div</code> с классами <code>col col-sm-8 offset-sm-2</code> в новый компонент лучше не тащить. Пусть он лучше останется в компоненте <code>App</code> и будет играть роль контейнера для нового компонента. Так у нас сохранится возможность переиспользовать наш новый компонент в каком-нибудь блоке другого размера.</li><li>То есть, внутри дива с <code>col col-sm-8 offset-sm-2</code> нужно будет поместить <span>&lt;ProductBox title=\"заголовок блока\"&gt;</span>остальной контент<span>&lt;/ProductBox&gt;</span></li><li>После того, как все получится – для эксперимента отрисуйте еще один ProductBox в другом месте с немного другим заголовком.</li></ul>",
      "tKey": 4
    },
    {
      "name": "Функция map и ее использование в рендеринге",
      "html": "<p>Давайте создадим еще один компонент – Navigation, который сможем использовать для меню и наших табов. Пусть в качестве props-аргументов он принимает массив строк, которые нужно отобразить и имя класса для самого элемента навигации.</p><p>То есть, мы хотим его использовать примерно таким образом:</p><pre><code class=\"language-jsx\">const appLinks = [\"Услуги\", \"Цены\", \"О компании\", \"Контакты\"];\nconst tabLinks = [\"Фотографии\", \"Описание\", \"Отзывы\"];\n\nconst appNav = &lt;Navigation links={ appLinks } navClass=\"nav\"&gt;;\nconst tabs = &lt;Navigation links={ tabLinks } navClass=\"nav nav-tabs\"&gt;</code></pre><blockquote><p>Вы, наверное, заметили, что для задания переменных мы в этот раз использовали не <code>let</code>, а <code>const</code>. Отличие – в эту переменную больше нельзя будет ничего записать. Фактически, это переменная, а не константа. Использование <code>const</code> для переменных, которые мы не собираемся перезаписывать – является хорошей практикой, и начиная с этого момента мы будем ее придерживаться.</p></blockquote><p>Чтобы воплотить желаемое поведение, наш компонент <code>Navigation</code> должен сформировать массив из jsx-элементов <code>&lt;li&gt;</code>, каждый из которых будет соответствовать строке из <code>this.props.links</code>. </p><p>Если посмотреть на эту задачу более широко, то это – мэппинг, т.е. преобразование (mapping – отображение) одного массива в другой. В современном <code>javascript</code> для мэппинга есть удобный инструмент – функция <code>map</code>.  Изучите ее самостоятельно <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a></p><p>Если адаптировать пример из статьи к нашим условиям, мы получим что-то вроде:</p><pre><code class=\"language-jsx\">const items = this.props.links.map(function(textItem) {\n  return &lt;li&gt;&lt;a className=\"nav-link\"&gt;{ textItem }&lt;/a&gt;&lt;/li&gt;;\n})</code></pre><p>Мы создали функцию, которая принимает аргументом строку и возвращает сформированный jsx-элемент <code>&lt;li&gt;</code> со ссылкой и этой строкой внутри. Затем мы вызвали функцию <code>this.props.links.map</code>. Она сама перебрала все элементы массива <code>this.props.links</code>, и каждый элемент этого массива (а у нас там как раз строки) отправила аргументом нашей функции. Полученные от функции jsx-элементы она по порядку складировала в новый массив и вернула этот новый массив в качестве результата. Мы записали его в переменную <code>items</code> и теперь можем выдать в верстку. </p><p>Конечно, все эти действия можно было бы сделать и с циклом <code>for</code>, но с функцией <code>map</code> получается гораздо проще и быстрее в написании. Поэтому использование функции <code>map</code> в рендеринге React-компонентов – распространенная практика.</p><p>Мы могли бы еще немного сократить код, если бы использовали сокращенную (стрелочную) форму записи функций – Arrow functions <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a></p><p>Со стрелочной функцией код выглядел бы так:</p><pre><code class=\"language-jsx\">const items = this.props.links.map(\n  textItem =&gt; &lt;li&gt;&lt;a className=\"nav-link\"&gt;{ textItem }&lt;/a&gt;&lt;/li&gt;\n);</code></pre><p>Использование стрелочных функций не является обязательным требованием в рамках данного курса – но лучше привыкайте их использовать и применять.</p><h2>Задание</h2><p>Реализуйте новый компонент Navigation и примените его для вывода меню и табов.</p><h3>Подсказки</h3><p>В результате выполнения задания наши ссылки в верхнем меню пока потеряли атрибут <code>href</code> – мы его сейчас не отрисовываем. У бутстрапа есть специальный стиль, который перекрывает цвет всех ссылок без <code>href</code>, в результате ссылки в верхнем меню становятся невидимыми. </p><p>Нам это совсем не нужно, поэтому давайте немного доработаем блок CSS и повысим приоритет наших стилей, которые отвечают за цвет ссылок в меню:</p><pre><code class=\"language-css\">.app-bar a {\n  color:white !important;\n}\n.app-bar a.active {\n  color:lightgreen !important;\n}</code></pre>",
      "tKey": 5
    },
    {
      "name": "Состояние компонента (state)",
      "html": "<p>Давайте сделаем наш компонент интерактивным. </p><p>Пришло время познакомиться с концепцией React чуть более глубоко. Рендеринг React-компонента должен зависеть от двух объектов с данными. </p><ol><li>Объект свойств<code>this.props</code> – с ним мы уже знакомы. Важным для понимания является тот факт, что компонент не может изменить свои <code>props</code> никаким методом – их устанавливает и меняет только родительский элемент. Получается, для хранения динамических данных, на которые влияет логика работы компонента (например, номер активной вкладки) – <code>this.props</code> не подходит.</li><li>Объект состояния  <code>this.state</code>. Он как раз предназначен для хранения состояния – любых данных, которые могли измениться во время жизни компонента. Родительский элемент не может оказывать никакого влияния на <code>state</code> дочернего компонента. </li></ol><p>Получается, внешний вид компонента (т.е. верстка) является как бы функцией двух переменных – свойств <code>this.props</code>, которые определяются родителем и состояния <code>this.state</code>, которое определяется внутренней логикой. Когда происходят любые изменения в <code>this.props</code> или <code>this.state</code>, компонент полностью перерисовывается.</p><p>Этот подход кардинально отличается от подхода, который мы реализовали ранее на чистом <code>javascript</code>. Теперь нам не нужно выковыривать какие-то элементы из HTML и вручную менять им свойства. Мы просто прописали алгоритм рендеринга на основе состояния и свойств, и полностью полагаемся на него. Теперь наша забота – просто отреагировать на события и внести изменения в <code>this.state</code>.</p><h2>Инициализация состояния</h2><p>Если ваш рендеринг зависит от состояния (а это не всегда так – бывают <code>stateless components</code>, которые зависят только от свойств), то вы должны проинициализировать его в конструкторе. </p><pre><code class=\"language-jsx\">class Tabs extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      activeIndex: 0\n    }\n  }\n}</code></pre><p>Вы заметили, что в нашей прошлой реализации мы остались без активных вкладок вообще? Чтобы такого не происходило, нужно всегда заботиться об установке начальных значений в объект <code>state</code>.</p><p>Еще важным для понимания моментом является вызов функции <code>super</code> в конструкторе. Дело в том, что наш класс является наследником от React.Component. Когда мы создаем в нем какие-то функции (в том числе и конструктор), они как бы \"затирают\" аналогичные функции у родительского класса. Но если нам нужна эта затертая функция у родителя (а конструктор  React.Component нам определенно нужен – он делает кучу необходимых вещей) – мы можем ее вызвать с помощью ключевого слова <code>super</code> (родительский класс еще называют суперклассом).</p><h2>Изменение состояния</h2><p>Нельзя просто так взять и записать какую-то переменную в <code>this.state</code> (точнее, можно, но только в конструкторе). Например, если вы в какой-то функции напишете <code>this.state.activeIndex = 1;</code>, то инстанс компонента не будет перерисован – потому что ядро React-компонента не умеет получать уведомления о присваиваниях.  </p><p>Состояние нужно менять с помощью функции <code>this.setState</code>:</p><pre><code>this.setState({ activeIndex: 1 })</code></pre><p>В качестве аргумента она принимает объект со свойствами, которые нужно изменить. React объединит этот объект с другими существующими свойствами, если они есть, и вызовет повторный рендеринг.</p><p>В некоторых случаях действительно бывает эффективнее изменить какое-то свойство вручную. Но в этом случае придется принудительно заставить React-компонент перерисоваться, вызвав функцию <code>this.forceUpdate()</code>.   </p><h2>Обработка событий</h2><p>Обработка событий очень похожа на обычную обработку событий, которую мы делали на чистом <code>javascript</code>.</p><pre><code>class Tabs extends React.Component {\n  onClick(event) {\n    const index = event.target.getAttribute(\"data-index\");\n    alert(index);\n  }\n\n  render() {\n    return &lt;div&gt;\n      &lt;a data-index=\"0\" onClick={ this.onClick.bind(this) }&gt;Первая ссылка&lt;/a&gt;\n      &lt;a data-index=\"1\" onClick={ this.onClick.bind(this) }&gt;Вторая ссылка&lt;/a&gt;\n    &lt;/div&gt;;\n  }\n}</code></pre><h2>Условное присвоение HTML-классов и тернарный оператор</h2><p>У нас возникнет интересная задача при выводе активной ссылки. Естественно, все <span>&lt;li&gt;</span> мы будем выводить с помощью функции <code>map</code>. В зависимости от того, является ли данная ссылка активной – мы должны будем указать либо <code>nav-link active</code>, либо просто <code>nav-link</code> в качестве класса. </p><p>То есть, мы должны отрендерить HTML-атрибут <code>className</code>, который не является статичным, а зависит от <code>props</code> или <code>state</code>. Для этого можно использовать фигурные скобки с выражением – точно так же, как для вывода контента тегов:</p><pre><code class=\"language-jsx\">&lt;a className={ выражение_для_имени_класса  }&gt;\n  { выражение_для_текста ссылки }\n&lt;/a&gt;</code></pre><p>В таких случаях удобно применять условный (или тернарный) оператор (многие называют его просто \"вопросиком\") <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Условный_оператор\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Условный_оператор</a></p><p>В зависимости от того, выполняется условие или нет, тернарный оператор возвращает либо первое, либо второе выражение.</p><pre><code class=\"language-jsx\">&lt;a className={ index === this.state.activeIndex ? \"nav-link active\" : \"nav-link\" }&gt;\n  { выражение_для_текста ссылки }\n&lt;/a&gt;</code></pre><h2>Задание</h2><p>Теперь у нас есть все необходимые знания и навыки, чтобы доделать полноценную интерактивную навигацию на React-компонентах.</p><h3>Подсказки</h3><p>В прошлом задании мы выводили элементы списка <code>&lt;li&gt;</code> с помощью такого кода:</p><pre><code class=\"language-jsx\">this.props.links.map(text =&gt; \n  &lt;li className=\"nav-item\"&gt;&lt;a className=\"nav-link\"&gt;{ text }&lt;/a&gt;&lt;/li&gt;\n) </code></pre><p>При таком использовании функции <code>map</code> мы не сможем получить доступ к индексу (номеру) выводимого <code>&lt;li&gt;</code>. А этот индекс нам нужен – во-первых, нам надо устанавливать атрибут <code>data-index</code> для <code>&lt;li&gt;</code> или вложенной в него ссылки. Во-вторых, индекс нужен для определения того, является ли компонент активным.</p><p>Это легко исправить. Дело в том, что <code>map</code> передает нашей функции-мэпперу два аргумента – элемент исходного массива и индекс. Просто наша функция мэппер в данный момент принимает только первый из них, поэтому второй недоступен. Вот как это можно исправить:</p><pre><code class=\"language-jsx\">this.props.links.map((text, index) =&gt; \n  &lt;li className=\"nav-item\"&gt;\n    &lt;a data-index={index} className=\"nav-link\"&gt;{ text }&lt;/a&gt;\n  &lt;/li&gt;\n) </code></pre><p>Вы столкнетесь с еще одной проблемой. Давайте вспомним, откуда записывается информация в <code>this.state.activeIndex</code>:</p><ol><li>При рендеринге <code>&lt;li&gt;&lt;a&gt; ... &lt;/a&gt;&lt;/li&gt;</code> мы записываем в атрибут <code>data-index</code> значение индекса <code>index</code>. </li><li>При клике мы из <code>event</code> выцепляем <code>target</code> и считываем из него атрибут <code>data-index</code>.</li></ol><p>Дело в том, что в HTML-атрибутах могут храниться только строковые значения.  То есть, помещали мы туда числовое значение, но считаем – уже строковое.</p><p>Поэтому при клике на первую вкладку в <code>this.state.activeIndex</code> запишется не число 1, а строка \"1\". В итоге, когда мы будем проверять равенство <code>this.state.activeIndex === index</code> для определения активного класса – проверка никогда не сработает. </p><blockquote><p>Тройной знак равенства обозначает строгую проверку. В отличие от двойного знака равенства (обычной проверки), строгая проверка срабатывает только когда и левая, и правая части имеют одинаковый тип и одинаковые данные. То есть, нестрогая проверка <code>\"1\" == 1</code> сработает, а строгая <code>\"1\" === 1</code> не сработает.</p></blockquote><p>Есть конечно вариант просто заменить проверку на нестрогую, но это считается плохой практикой. Вместо этого лучше проконтролировать, чтобы в <code>this.state.activeIndex</code> попадали данные с правильным типом. Для этого можно после получения индекса из HTML-атрибута преобразовать его к числовому типа с помощью функции Number, примерно так:</p><pre><code>onClick(event) {\n  const indexString = event.target.getAttribute(\"data-index\");\n  const index = Number(indexString);\n  this.setState({ activeIndex: index });\n}</code></pre>",
      "tKey": 6
    },
    {
      "name": "Переключение контента",
      "html": "<p>Наши вкладки сейчас переключаются, но не несут никакой практической пользы. Обычно они нужны, чтобы показывать разные блоки контента в зависимости от того, какая вкладка активна.</p><p>Нам нужно это исправить. Удобным вариантом было бы, если бы мы передавали нашему компоненту в качестве контента несколько блоков, каждый из которых соответствовал бы одной вкладке. Примерно так:</p><pre><code>const tabs = [\"Фотографии\", \"Описание\", \"Отзывы\"];\n&lt;Navigation links={ tabs } navClass=\"nav nav-tabs\"&gt;\n  &lt;div&gt;&lt;h2&gt;Фотографии&lt;/h2&gt;&lt;/div&gt; \n  &lt;div&gt;&lt;h2&gt;Описание&lt;/h2&gt;&lt;/div&gt; \n  &lt;div&gt;&lt;h2&gt;Отзывы&lt;/h2&gt;&lt;/div&gt; \n&lt;/Navigation&gt;</code></pre><p>Тогда компонент получит доступ к этим трем блокам в виде <code>this.props.children</code> и сможет вывести один из них в зависимости от текущего активного индекса.</p><h2>Задание</h2><p>Реализуйте переключение контента в нашем компоненте Navigation. У вас на данный момент достаточно знаний, чтобы все реализовать самостоятельно.</p>",
      "tKey": 7
    }
  ]
},{
  "_id": {
    "$oid": "5c03f7cae64f6ccda676f5f5"
  },
  "name": "Сервер-сайд и примитивный веб-сервер",
  "html": "<p>Все веб-приложения устроены в соответствии с архитектурой клиент-сервер. </p><p>Сервер – это компьютер или программа,которые работают где-то в дата-центре.\nКлиент – это браузер любого пользователя.</p><p>Поэтому вся веб-разработка делится на <em>сервер-сайд</em> (server-side, еще называют бэкэндом – backend) и <em>клиент-сайд</em> (client-side, или фронтэнд – frontend).</p><p>К клиент-сайду относится все, что происходит на стороне браузера – верстка, стилизация, интерактив.</p><p>Сервер-сайд отвечает за то, чтобы подготовить и передать клиенту все необходимые для работы файлы, страницы и данные. Вопросы сервер-сайда - это хранение данных (в специальных хранилищах – базах данных), управление доступом, выдача в клиент веб-страниц в зависимости от адреса и т.п.</p><p>Каждый обмен данных между клиентом и сервером называется <em>запросом</em>. Запрос происходит по определенным правилам, которые называются протоколом HTTP (или его защищенной модификацией – HTTPS). Веб-разработчик должен хорошо его понимать – обязательно изучите, когда закончите курс <a href=\"https://ru.wikipedia.org/wiki/HTTP\">https://ru.wikipedia.org/wiki/HTTP</a></p><p>Обычно (упрощенно) весь процесс взаимодействия происходит вот так:\n1. Клиент запрашивает у сервера веб-страницу по определенному URL. \n1. Сервер видит запрос, анализирует его, пытается понять, что хочет клиент и отдает ему ответ. Например, в зависимости от URL сервер отдает ту или иную страницу HTML, или специальный ответ с кодом 404 (\"Страница не найдена\")\n3. Клиент получает HTML и видит, что к этому HTML требуется несколько CSS и JavaScript-файлов. Для каждого из них он шлет новый запрос серверу.\n4. Сервер в ответ на все эти запросы выдает соответствующие JS-  и  CSS- файлы.\n5. Браузер понимает, что теперь все готово для полноценного отображения страницы. Он отрисовывает HTML в сответствии с подключенным CSS и выполняет Javascript, чтобы страница стала интерактивной.</p><p>Как вы понимаете, до этого мы занимались только клиентским программированием – делали страницу интерактивной. Сейчас мы переходим к серверному программированию.</p>",
  "uKey": 5,
  "tasks": [
    {
      "name": "Запуск первого веб-сервера на cloud9",
      "html": "<p>Как вы понимаете, jsfiddle нам больше не подходит – он только про клиентскую часть. </p><p>Все программирование на сервер-сайде происходит в операционной системе LInux. Устанавливать и настраивать ее на своем компьютере сложно и долго, поэтому в учебных целях мы воспользуемся эмулятором. Он позволит нам настроить и создать веб-сервер с Linux-окружением, и управлять им прямо из окна браузера.</p><p>Вот эмулятор, который мы будем использовать – <a href=\"https://c9.io/\">https://c9.io/</a>. Для регистрации в нем вам понадобится инвайт – чтобы получить его, обратитесь к преподавателю.</p><p>После входа нажмите на большой плюсик, чтобы создать новый <code>workspace</code>, или перейдите по адресу <a href=\"https://c9.io/new\">https://c9.io/new</a></p><p>Заполните дла нашего воркспейса следующие настройки:\n1. Название (лаитиницей). Мы рекомендуем назвать <code>purenode</code> – \"чистый\" Node. Это означает, что в этом воркспейсе мы будем создавать веб-сервер без фреймворков, чисто средствами языка.\n2. Убедитесь, что выбран селектор <code>public</code>, а не <code>private</code>.\n3. В шаблонах (Choose a template) выберите  Node.js. Node.js – это диалект языка javascript, используемый для разработки на сервер-сайде. Это очень важная настройка – если ошибетесь, надо будет удалять воркспейс и создавать новый.</p><p>Теперь нажмите кнопку <code>Create workspace</code> и подождите, пока он не будет создан.</p><p>Сервер создан – вас должно было перекинуть в  IDE – интегрированную среду разработки (англ. Integrated Development Environment). Она состоит из трех частей:\n1. Слева – древовидный список файлов, которые доступны в вашей небольшой операционной системе.\n1. Вверху – окно для просмотра и редактирования этих файлов. Сейчас там открыт файл Readme с инструкцией.\n1. Внизу – окно с терминалами. Терминал нужен, чтобы вводить различные команды операционной системы, запуская таким образом программы и просматривая их результат. </p><h2>Задание</h2><p>Запустите веб-сервер – введите команду \n<code>node server.js</code> и нажмите Enter.</p><p>В нашем Readme сказано – <em>Once the server is running, open the project in the shape of '<a href=\"https://projectname-username.c9users.io/\">https://projectname-username.c9users.io/</a>'</em>. То есть, после запуска нашего веб-сервера, он уже может обрабатывать реальные запросы из браузера по адресу, состоящему из вашего имени, указанного при регистрации и имени проекта.</p><p>Откройте в новой вкладке этот URL, убедитесь, что он работает и укажите его в комментарии. </p>",
      "tKey": 1
    },
    {
      "name": "Собственный веб-сервер",
      "html": "<p>Сервис Cloud9, которым мы пользуемся, создал веб-сервер с определенным функционалом за нас. Это здорово, но нам нужно самим научиться его делать. Поэтому удалите слева все файлы и папки, кроме файла <code>server.js</code>.</p><p>Сначала – небольшой организационный момент. Во-первых, Cloud9 IDE не сохраняет файлы автоматически в процессе редактирования. Это очень неудобно, но это можно исправить. </p><p>Откройте в меню <code>Cloud9 &gt; Preferences &gt; Experimental</code>, найдите настройку <code>Auto save files</code> и установите значение <code>After delay</code>.</p><h2>Неольшой ликбез по  Linux-программам</h2><p>На самом деле командой <code>node server.js</code> мы запускали не наш сервер, а Linux-программу, которая называется <code>node</code>. Linux-программам тоже можно передавать аргументы, как и javascript-функциям – только они перечисляются через пробел, а не в круглых скобках через запятую. То есть, <code>server.js</code> – это был просто аргумент для программы <code>node</code>.</p><p>Что же делает программа <code>node</code>? Она запускает интерпретатор языка Node.js (серверная версия языка javascript) и передает этому интерпретатору на выполнение первый аргумент – который должен быть именем файла с программой на языке Node.js.</p><h4>Как определить, работает Linux-программа или уже завершилась?</h4><p>До момента, когда мы запустили программу, у нас в терминале самой нижней строкой было так называемое <em>приглашение</em>, которое выглядело примерно так:</p><p><code>alevkon:~/workspace $</code></p><p>Если курсор (белый квадратик) находится в той же строке, что и приглашение – значит, нас приглашают ввести команду, и данный терминал сейчас ничем не занят. Но после того как мы ввели нашу команду и нажали Enter, наш курсор перешел на другую строку, а нового приглашения не появилось – это значит, что данный терминал занят выполнением программы. </p><p>Пока он занят – мы можем быть уверены, что наша программа выполняется, веб-сервер работает и может обслуживать приходящие к нему запросы от браузера. Когда же он остановится?</p><ul><li>Если в программе произойдет фатальная необработанная ошибка. Скажем, мы написали плохой код, который при обслуживании определенного адреса допускает серьезную ошибку. В этом случае сервер \"падает\" – потому что программа node в таких случаях завершает работу и выводит в терминал сообщение об ошибке.</li><li>Если мы прервем выполнение этой программы вручную. Для этого нужно нажать сочетание клавиш <code>Ctrl-C</code>, находясь в том же терминале (обратите внимание - на маке тоже нужно нажимать Ctrl-C, а не Cmd-C).</li></ul><p>Мы будем довольно часто прерывать выполнение программы по мере ее разработки. Каждый раз, когда мы изменили логику работы, нужно будет останавливать веб-сервер и запускать его заново.</p><h2>Примитивный веб-сервер</h2><pre><code>const http = require('http');\n\nconst server = http.createServer(function(req, res) {\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"text/plain\");\n  res.write(\"Hello World\");\n  res.end();\n});\n\nserver.listen(process.env.PORT);</code></pre><p>Давайте разберемся, как мы делаем этот веб-сервер.</p><ol><li>Подключаем модуль <code>http</code>. На языке Node написано огромное количество функционала, который мы можем с пользой использовать. Весь этот функционал находится в специальных <em>модулях</em>, которые можно подключать функцией <code>require</code>. Здесь мы подключаем стандартный модуль <code>http</code>, который всегда идет вместе с нодой, и его не нужно устанавливать дополнительно. Мы записали этот модуль в переменную <code>http</code>, и теперь все функции модуля будут доступны через нее.</li><li>У модуля <code>http</code> есть метод <code>createServer</code>. Ему в качестве аргумента нужно передать пользовательскую функцию. Эту функцию модуль <code>http</code> будет вызывать каждый раз, когда какой-нибудь браузер пришлет очередной запрос. Нашей функции модуль <code>http</code> всегда будет передавать два аргумента – http-запрос и http-ответ. Из запроса мы сможем получить всю необходимую информацию, т.е. понять, что именно этот браузер хочет получить. А объект http-ответа модуль подготовил, чтобы мы могли вписать в него информацию для отправки браузеру.</li><li>Теперь давайте разберем поведение функции.<ol><li>Внутри нее мы назвали аргументы <code>req</code> и <code>res</code> (сокращения от request – запрос и response – ответ). Как видите, мы в теле функции никак не используем req – но мы все равно должны объявить два аргумента, чтобы они не перепутались. </li><li>Сначала мы записываем в <code>statusCode</code> код ответа – 200. Самостоятельно разберитесь, что означает этот код <a href=\"https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP\">https://ru.wikipedia.org/wiki/Список<em>кодов</em>состояния_HTTP</a></li><li>Затем мы записываем поле <code>Content-Type</code> в заголовок ответа. Самостоятельно разберитесь, что такое заголовок, зачем нужно поле <code>Content-Type</code> и что означает значение <code>text/plain</code>. <a href=\"https://developer.mozilla.org/ru/docs/Web/HTTP/Заголовки\">https://developer.mozilla.org/ru/docs/Web/HTTP/Заголовки</a>. Вкратце, заголовок – это такой блок информации, который всегда идет вместе с телом как http-запроса, так и http-ответа и содержит для принимающей стороны дополнительную информацию, касающуюся обработки этого запроса/ответа.</li><li>Затем мы записываем информацию в <em>тело</em> http-ответа. (см. заголовок \"Тело\" в секции \"Ответы HTTP\" статьи <a href=\"https://developer.mozilla.org/ru/docs/Web/HTTP/Messages\">https://developer.mozilla.org/ru/docs/Web/HTTP/Messages</a>)</li><li>И, наконец, отправляем ответ обратно браузеру, вызвав команду <code>res.end()</code>. Это типовая ситуация, хорошенько уложите ее в голове. Нам надо сформировать три вещи в ответе – числовой код статуса, заголовки, тело. После этого ответ можно \"завершить\", и он уйдет браузеру.</li></ol></li><li>Теперь еще одно важное, но пока сложное для понимание действие. Мы должны привязать наш веб-сервер к определенному сетевому <em>порту</em> нашей операционной системы. В рамках курса сильно вникать в этот вопрос мы не будем – это некое стандартное действие, необходимое для того, чтобы в наш сервер прилетали запросы с нужного сетевого интерфейса (которых в операционной системе может быть несколько).</li></ol><p>Теперь, если мы запустим наш сервер, мы сможем заходить на тот же самый адрес (сформированный по принципу '<a href=\"https://projectname-username.c9users.io/'\">https://projectname-username.c9users.io/'</a>), что и в предыдущем задании, и получать в ответ <em>Hello world</em>.</p><h2>Задание</h2><p>Давайте сделаем наш сервер немного интереснее. Пусть он выдает нам что-то вроде считчика запросов. То есть, заходя следующий раз на ту же страницу мы должны видеть число, на 1 больше предыдущего.</p><h3>Подсказки и требования</h3><ul><li>Объявите переменную <code>counter</code> снаружи нашей функции–обработчика запросов. Это очень важно – если вы объявите ее внутри функции, то при каждом новом вызове переменная будет создаваться заново и счетчика не получится. </li><li>Несмотря на то, что созданная нами переменная будет находиться снаружи функции, изнутри она будет все равно будет доступна благодаря механизму <code>javascript</code>, который называется замыканием <a href=\"https://learn.javascript.ru/functions-closures\">https://learn.javascript.ru/functions-closures</a>.</li><li>Внутри функции каждый раз увеличивайте значение переменной <code>counter</code> на единицу. Это можно сделать простым оператором присваивания <code>counter = counter + 1</code> или <code>counter++</code>.</li><li>На всякий случай – если будете делать оператором присваивания, не используйте <code>let</code> внутри функции! Если вы напишете <code>let counter = counter + 1</code>, то в функции будет создана новая внутренняя переменная с таким же именем, доступа к внешней переменной не будет из-за совпадения имен, и счетчика не получится.</li><li>При выводе используйте механизм Template literals <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/template_strings\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/template_strings</a> , и выводите в ответ строки вида \"Номер запроса: 17\".</li><li>Не забудьте после модификации кода перезапустить ваш сервер.</li><li>Не огорчайтесь, если счетчик будет увеличиваться на 2, а не на 1 при каждом запросе. С этим мы подробнее разберемся в следующем таске.</li></ul><p>Для проверки задания предоставьте сразу два URL:</p><ul><li>По которому можно убедиться, что счетчик работает.</li><li>По которому можно посмотреть все файлы вашего проекта. Для этого нажмите кнопку <code>Share</code> справа вверху и скопируйте ссылку Files. Она должна иметь вид <code>https://preview.c9users.io/user_name/project_name</code></li></ul>",
      "tKey": 2
    },
    {
      "name": "Консоль и логирование запросов",
      "html": "<p>В прошлом задании мы столкнулись с проблемой – наш счетчик почему-то увеличивался на 2 при каждом заходе. Это точно не то поведение, которое мы от него ожидали – нам хотелось бы увеличивать его на 1. Как понять, в чем причина?</p><p>Вообще, пошаговая отладка сервер-сайда несколько сложнее, чем клиент-сайда. Запустить хромовский Inspector не всегда возможно – особенно, когда мы работаем через эмулятор.</p><p>Для получения информации о том, что происходит с сервер-сайд приложением, часто используется <em>логирование</em> – выдача сообщений в режиме реального времени в специальный поток данных, отображаемый в консоли (терминале). С терминалом мы уже немного знакомы – это такая вкладка внизу, из которой мы запускали наше приложение командой <code>node server.js</code></p><p>Для выдачи какой-либо информации в консоль в <code>node</code> есть специальная функция <code>console.log</code>. Ей можно через запятую передать несколько выражений, и она их выведет на экран. Например:</p><pre><code>console.log(\"Processing new request, current date:\", new Date().toString());</code></pre><p>Давайте каждый раз, когда к нам приходит запрос, будем выводить URL, с которого он приходит. Информацию об URL, как и все другие данные запроса, находится в объекте Request, который наша функция-обработчик запросов принимает первым аргументом под именем <code>req</code>.</p><pre><code>console.log(\"Request, url:\", req.url);</code></pre><h2>Задание</h2><p>Вставьте логирование в вашу функцию-обработчик запроса. Перезапустите сервер. В соседней вкладке несколько раз обновите страницу с адресом вашего приложения. Переключитесь в IDE и посмотрите в терминал – там будет видно, к каким URL приходят запросы. Изучите самостоятельно, что такое <code>favicon.ico</code> и почему браузер его запрашивает. Перепишите код вашей функции так, чтобы счетчик не увеличивался, когда приходит такой запрос. </p>",
      "tKey": 3
    },
    {
      "name": "Маршрутизация запросов (роутинг)",
      "html": "<p>Веб-сервер, который мы создали на прошлом шаге, обрабатывал все входящие запросы одинаково. Естественно, это не совсем правильное поведение веб-сервера - обычно на разные адреса он выдает разные страницы.</p><p>Логика определения, какой контент возвращать в зависимости от запрашиваемого URL – называется маршрутизацией, или роутингом (routing).</p><h2>Небольшой ликбез по URL</h2><p>Для упрощения можно считать, что URL, с которым имеет дело веб-разработка, состоит из трех частей. Давайте проанализируем эти части на примере URL <a href=\"http://hutorium.ru/student/unit/5/4?mode=complex\">http://hutorium.ru/student/unit/5/4?mode=complex</a></p><table><thead><tr><th>Название</th><th>Пример</th><th>Доступ из req</th></tr></thead><tbody><tr><td>Домен</td><td>hutorium.ru</td><td>Отсутствует</td></tr><tr><td>Путь</td><td>/student/unit/5/4</td><td><code>req.url</code></td></tr><tr><td>Поиск</td><td>?mode=complex</td><td><code>req.url</code></td></tr></tbody></table><p>Разберем эти части. </p><ol><li>Домен – начальная часть URL, до первого слеша. Обычно домен соответствует сайту.  У доменов может быть иерархия, когда один домен является частью другого – в этом случае первый называет поддоменом второго. Например, <code>maps.yandex.ru</code> является поддоменом <code>yandex.ru</code>. Cloud9 выделяет для вашего сайта тоже поддомен вида <code>projectname-username.c9users.io</code>. </li><li>Путь – кусок URL от первого слеша включительно до знака вопроса, если он есть. Обычно он соответствует одной конкретной веб-странице.</li><li>Поиск (search, еще называют query) – вся часть от знака вопроса до конца, если есть. Обычно используется для различных параметров для вывода той же самой страницы. Впервые такую схему с вопросом начали использовать поисковики, передавая таким образом фразу для поиска (<a href=\"https://www.yandex.ru/search/?text=хуториум\">https://www.yandex.ru/search/?text=хуториум</a>) – поэтому ее назвали search. </li></ol><p>К сожалению, изнутри веб-сервера мы не можем непосредственно получить доступ к домену. Это связано с тем, что серверу обычно не нужно знать, с какого именно домена пришел конкретный запрос. Его задача – разобраться в деталях и сформировать правильный ответ. Когда это важно, сетевое окружение конфигурируется таким образом, чтобы встроить оригинальное доменное имя внутрь одного из заголовков запроса – но это скорее вопрос системного администрирования, а не разработки.</p><p>Как мы видим, путь и поиск тоже не разделены, а приходят к нам в виде одного параметра <code>req.url</code>. Это связано с тем, что такое разделение – является неким общепринятым соглашением, но не жестким стандартом. Модуль <code>http</code>, который мы используем – абстрагируется от любых соглашений, и следует только стандартам.</p><p>Однако, эти части URL нам неплохо бы разделять для дальнейшего роутинга. Конечно, это можно сделать вручную, функциями <code>javascript</code> для работы со строками. Но – это сложно и мы не всегда можем сделать это правильно и учесть все детали и нюансы, которых в структуре URL довольно много. </p><p>Поэтому обычно для анализа частей URL используют еще один node-модуль, который, как и http, идет в стандартной поставке и не требует дополнительной установки.</p><pre><code class=\"language-javascript\">const URL = require(\"url\");\nconst parsedURL = URL.parse(\"https://www.yandex.ru/search/?text=хуториум\");\nconsole.log(parsedURL);\nconsole.log(\"Путь\", parsedURL.pathname);</code></pre><p>Теперь в <code>parsedURL</code> записан объект, который содержит все компоненты переданного на парсинг оригинального URL. Мы можем взять оттуда путь <code>pathname</code>, и на основе его анализа – выдать нужную страницу.</p><h2>Задание</h2><p>Сделайте маршрутизацию следующим образом.</p><ol><li>При заходе на главную страницу нашего поддомена пользователь должен видеть сообщение \"Main page\".</li><li>При заходе на страницу \"/counter\" пользователь должен видеть значение счетчика.</li><li>При заходе на страницу \"/reset\" значение счетчика должно сбрасываться в 0, пользователю выдать сообщение \"Счетчик сброшен\".</li><li>При заходе на любую другую страницу пользователь должен видеть текст \"Not found\".</li><li>Счетчик должен увеличиваться только при посещении главной страницы.</li></ol><h3>Подсказки и требования</h3><ul><li>Внутри основной функции нужно осуществлять только роутинг – но не какие-то другие действия (увеличения счетчика) или выдачу страниц.</li><li>Для каждого типа страниц нужно создать свою обслуживающую функцию – <code>serveIndex</code> для главной, <code>serveCounter</code>, <code>serveReset</code> и <code>serveNotFound</code> – для остальных.</li><li>Этим функциям нужно передавать оба аргумента – req и res.</li><li>Для выбора нужной функции маршрутизации удобнее использовать не <code>if</code>, а <code>switch</code> <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/switch\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/switch</a>.</li><li>Если к любому URL приписать справа знак вопроса и любой текст, то страница все равно должна обрабатываться точно так же. </li></ul>",
      "tKey": 4
    },
    {
      "name": "Генерация HTML",
      "html": "<p>В прошлом задании было довольно неудобным, что URL для перехода на страницу счетчика и сброса приходилось вбивать вручную. Давайте это исправим – выведем на главной странице две ссылки, которые ведут на страницу счетчика и сброса. </p><h3>Кавычки внутри строки</h3><p>Для того, чтобы javascript мог понять, что определенное выражение является текстом – а не выражением, которое нужно вычислять, мы использовали кавычки. Когда javascript находит кавычку, он ищет ближайшую к ней следующую кавычку и весь контент между ними считает строкой. Но что делать, когда нам нужно сгенерировать строку, которая сама по себе должна содержать кавычку или несколько? Например, сгенерировать HTML-код для ссылки, в которой будет атрибут <code>href</code>. Если мы напишем первым способом, который приходит в голову </p><pre><code>const html = \"&lt;a href=\"http://hutorium.ru\"&gt;\"</code></pre><p>то javascript поймет нас совершенно превратно. Он увидит первую кавычку, найдет ближайшую к ней, и будет считать строкой вот этот контент <code>&lt;a href=</code>. Дальнейший контент – <code>http://hutorium.ru\"&gt;\"</code> – он будет пытаться интерпретировать как выражение и, естественно, выдаст ошибку.</p><p>Проблему можно решать двумя способами.\n1. Использовать экранирующий слеш для кавычек. Изучите сами – <a href=\"https://learn.javascript.ru/string\">https://learn.javascript.ru/string</a>, раздел \"экранирование спецсимволов\".\n1. Использовать разные кавычки. Несколько менее универсальный способ, но вполне рабочий. В javascript строки можно заключать в одинарные <code>'пример'</code> или двойные <code>\"пример\"</code> кавычки. Они ничем не отличаются – можно использовать и те, и другие. Если для какой-то строки мы используем двойные – то внутри можно смело использовать одинарные в любом количестве и порядке, они не будет влиять на закрытие строки. И наоборот – если мы окружаем строку одинарными, то внутри можно смело использовать двойные.</p><h3>Относительные ссылки</h3><p>Мы давно не использовали ссылок с атрибутом <code>href</code>. Когда использовали их в самом начале, то ссылки вели на другой домен, и весь URL прописывался в ссылке полностью <code>&lt;a href=\"http://hutorium.ru\"&gt;Хуториум&lt;/a&gt;</code>. </p><p>Для внутренних ссылок, которые ведут на страницу на том же самом сайте, так не делают. Указывать полный URL с доменом неудобно и неправильно. Представьте себе, что вы решили поменять название вашего workspace в Cloud9 IDE – и все внутренние ссылки, написанные вместе с доменом, сразу же перестанут работать. </p><p>Или пример из реальных условий – обычно во всех кмпаниях существует боевая версия сайта (\"продакшен\") и версия для проверки (\"девелоперская\"), располагающиеся на разных доменах. Если мы будем прописывать внутренние ссылки с доменами, то на одной из версий они будут вести не туда.</p><p>Поэтому для внутренних ссылок домен не указывают, и пишут только путь к странице. Такие ссылки называются \"относительными\" (в противовес \"абсолютным\", которые включают в себя домен). Значение, указанное в <code>href</code> абсолютной ссылки, просто присоединяется к текущему URL в браузере.</p><p>Это тоже не всегда удобно. Представьте себе, что мы находимся на странице <code>site.ru/conter</code> и хотим сделать ссылку на страницу <code>site.ru/reset</code>. Если мы напишем просто <code>&lt;a href=\"reset\"&gt;Сброс&lt;/a&gt;</code>, то нас перекинет на страницу <code>site.ru/counterreset</code> – приделав <code>href</code> к существующему адресу.</p><p>Поэтому все используют несколько модифицированную версию относительных ссылок – начинающуюся со слеша <code>/</code>. Если ссылка начинается со слеша, то браузер приделает ее содержимое не ко всему URL из адресной строки, а только к домену – что нам и нужно. </p><h2>Задание</h2><p>Модифицируйте предыдущее задание так, чтобы на страницы счетчика и сброса вели ссылки. Текст на ссылках обязательно должен быть на русском (\"Счетчик\" и \"Сброс\")</p><h3>Подсказки</h3><p>Поскольку при выдаче страницы мы в заголовке ответа <code>Content-Type</code> сообщаем браузеру, что выдаваемый контент – обычный текст, он не отрисует ссылки в виде HTML-верстки. Он покажет нам всю страницу в виде обычного (\"плоского\", plain) текста, а не HTML (\"гипер-текста\", HyperText).</p><p>Найдите в поиске и изучите самостоятельно, какие виды Content-Type бывают, и какой нужно указать, чтобы браузер воспринимал переданный контент как HTML-страницу.</p><p>Еще одна проблема, с которой вы столкнетесь – это кодировка. Поскольку HTML, HTTP и все остальные протоколы разрабатывали буржуи с загнивающего Запада, они позаботились только об английском языке, включив его в стандартный набор символов.. Возможности писать HTML и другой текст на других языках появились сильно позже. Все они базировались на различных соглашениях, которые называются \"кодировками\", и они менялись много раз, пока не пришли к современной кодировке, которая сейчас является стандартом де-факто – она называется UTF-8. </p><p>Но браузеру нужно явно сообщать, в какой кодировке написана страница – потому что в интернете до сих пор масса страниц со старыми кодировками, и браузер не может быть уверен, что страницу нужно отображать именно в <code>utf-8</code>. Изучите самостоятельно, какой заголовок нужно установить в <code>res</code>, чтобы указать браузеру отрисовывать страницу в соответствии с <code>utf-8</code>, и мы видели нормальный текст на русском.</p>",
      "tKey": 5
    },
    {
      "name": "Понятие статики и обслуживание статических файлов",
      "html": "<p>Как мы успели убедиться, генерировать HTML – довольно утомительное занятие. Представьте себе, насколько неудобно было бы держать функцию, которая генерировала бы огромный HTML, который мы использовали для карточки продукта. Мы бы не смогли использовать отступы, у нас были бы проблемы с переносом строк и много других сложностей.</p><p>Поэтому HTML, а тем более – CSS и картинки принято хранить на сервере в отдельной папке в виде обычных файлов, а не генерировать и выдавать на лету.</p><p>Такой контент – который никак не зависит от каких-либо переменных или других меняющихся сущностей (например, базы данных), и при любом запросе выдается всегда одинаковым  – называют статическим контентом (или просто <em>статикой</em>) и всегда стараются держать в виде отдельных файлов.</p><blockquote><p>Например, HTML-страница <code>/counter</code> из прошлого примера не была статической – она зависела от переменной <code>counter</code></p></blockquote><p>Давайте научимся обслуживать статические файлы. </p><h3>Алгоритм функции serveStatic</h3><p>У функции непростой алгоритм, поэтому давайте продумаем его перед реализацией.</p><ol><li>Определить название файла, которым мы должны ответить на запрос.</li><li>В зависимости от расширения файла установить в ответе правильный <code>Content-Type</code> с помощью функции <code>res.setHeader()</code>;</li><li>Считать контент файла.</li><li>Выдать контент файла в <code>res</code>.</li></ol><h3>Определение название файла из запроса</h3><p>Нам понадобится еще один стандартный модуль <code>path</code>. Устанавливать не нужно – он идет в стандартной поставке.</p><p>Тогда имя файла можно будет определить вот так:</p><pre><code>const filename = path.basename(req.url)</code></pre><p>Еще один важный момент – когда в систему придет запрос на главную страницу c  URL, равным <code>/</code> – нам хотелось бы ответить на запрос страницей <code>index.html</code>. Однако, тогда предложенный путь определения имени файла не сработает.</p><p>Для решения этой проблемы стоит добавить нашей функции третий, необязательный параметр – customFilename. Если он задан – мы возьмем его. Если не задан – то определим по предложенному алгоритму. Сама функция роутинга тогда должна будет позаботиться о том, чтобы в случае запроса <code>/</code> она вызывала <code>serveStatic</code> с дополнительным третьим параметром.</p><p>С учетом этого, определение имени файла можно сделать с помощью уже знакомого оператора выбора (тернарного оператора, \"вопросика\")</p><pre><code>const filename = customFileName\n   ? customFileName\n   : path.basename(req.url);</code></pre><p>Или с помощью логического оператора ИЛИ <code>||</code> (<a href=\"https://learn.javascript.ru/logical-ops\">https://learn.javascript.ru/logical-ops</a>) </p><pre><code>const filename = customFileName || path.basename(req.url);</code></pre><h3>Определение расширения файла</h3><p>В зависимости от того, какой файл мы отдаем – html, css или jpg-картинку – мы должны выдать в <code>res</code> соответствующий <code>Content-Type</code> (п.2 алгоритма).</p><p>Определить расширение можно с помощью той же библиотеки <code>path</code>.</p><pre><code class=\"language-javascript\">const extension = path.extname(filename);</code></pre><p>Обратите внимание – полученное расширение будет включать в себя точку (например, <code>.css</code>). Учтите это, когда будете делать <code>switch</code>.</p><p>Изучите сами, какой <code>Content-Type</code> требуется для файлов CSS, HTML и JPG, чтобы браузер корректно их обрабатывал.</p><h3>Считывание файлов</h3><p>Нам нужно будет научиться считывать файл в переменную, чтобы затем выдать его содержимое в res.write().</p><p>Это можно сделать с помощью еще одного стандартного пакета <code>fs</code> (file system):</p><pre><code class=\"language-javascript\">// это где-нибудь вверху файла\nconst fs = require('fs');\n\n...\n\nconst content = fs.readFileSync(\"static/\" + filename);\nres.write(content);</code></pre><p>В целом, синхронную версию функции <code>readFile</code> – лучше никогда не использовать. Мы пользуемся ей исключительно в учебных целях, но синхронная версия убивает все преимущества <code>Node.js</code> перед другими языками – поэтому в боевой практике используйте обычную <code>readFile</code>. Перед этим нужно будет научиться работать с асинхронными функциями.</p><h3>Как скачивать файлы в Linux</h3><p>Вы эмуляторе cloud9 вы легко сможете создать новую папку static и положить в нее файлы <code>index.html</code> и <code>main.css</code>, в которых поместим наш контент с jsFiddle. Но как перетащить туда product.jpg?</p><p>Это можно сделать через командную строку – в лучших традициях операционной системы Линукс. Откройте внизу еще одно окно терминала (нажмите кнопку + и выберите в списке new terminal), и введите туда следующую последовательность команд: (после каждой надо нажимать Enter).</p><pre><code>cd static\nwget http://80.211.25.188/img/tasks/product.jpg</code></pre><p>Первая команда – меняет активную папку, т.е. заходит в папку static, которая была предварительно создана. Вторая – скачивает в текущую папку файл по указанному URL. </p><p>Файл должен был появиться в папке <code>static</code> слева. </p><h2>Задание</h2><p>Теперь нам хватает знаний, чтобы наш веб-сервер корректно выдал страницу из задания <a href=\"/unit/2/5\">http://80.211.25.188/unit/2/5</a> со стилями и картинкой.</p><h3>Подсказки и требования</h3><ul><li>Убедитесь, что картинка на этот раз отдается с нашего сервера, а не из внешнего интернета. Для этого в теге <code>&lt;img&gt;</code> нужно прописать корректный <code>src</code>. Как и <code>href</code> в ссылках, атрибут <code>src</code> может содержать относительный путь, например <code>/product.jpg</code>.</li><li>Раньше мы не подключали свой файл стилей – jsFiddle делал это за нас автоматически. Сейчас jsFiddle мы не используем, и нам нужно делать все по взрослому. Подключите наш CSS файл с помощью тега <code>&lt;link&gt;</code>. Изучите самостоятельно, как это делается. Тег <code>&lt;link&gt;</code> тоже поддерживает относительный путь.</li></ul>",
      "tKey": 6
    }
  ]
},{
  "_id": {
    "$oid": "5c03f9b8d6c41dcf902208ea"
  },
  "name": "Динамические веб-страницы, шаблонизатор и база данных",
  "html": "<p>Одна из основных задач, которые стоят перед сервер-сайдом – это отображение на веб-страницах динамического содержимого, которое зависит от базы данных или других переменных факторов.</p><p>Для решения этой задачи используется одна из трех стратегий:</p><ol><li>Динамические веб-страницы. В этом случае сервер отдает веб-страницы не как статический контент, а генерируют на лету с помощью шаблонизатора. </li><li>SPA (Single page Application). В этом случае на любой запрос сервер возвращает одну и ту же статическую страницу без какого-либо значимого HTML. Весь роутинг и отрисовка динамического содержимого происходит на клиент-сайде. </li><li>SSR (Server-side Rendering). В этом случае создается единый код для рендеринга компонентов как на сервер-сайде, так и на клиент-сайде. Сначала компоненты отрисовываются на сервер-сайде и в браузер уходит полноценная готовая страница. Затем тот же код компонентов выполняется на клиент-сайде, они \"подхватывают\" готовую верстку и начиная с этого момента отвечают за интерактив и отображение.</li></ol><p>В этом юните мы познакомимся с первой стратегией. Ее основное преимущество – простота реализации и тот факт, что поисковые системы видят полноценные страницы, а не куцые заглушки, как в SPA – это кардинально влияет на поисковую оптимизацию. </p><p>Главный недостаток стратегии – сложность реализации интерактивных компонентов на странице. Нам приходится держать код, относящийся к компонентам страницы, в двух разных местах. </p><ol><li>Шаблон страницы на сервер-сайде. </li><li>Логика изменения внешнего вида компонентов на клиент-сайде.</li></ol><p>Когда компонент в процессе развития проекта надо будет менять – любое изменение в шаблоне могут ломать логику на клиент-сайде, который полагался на старую верстку. Это очень неудобно и, фактически, делает разработку вдвое дороже.</p><p>Тем не менее, эта стратегия довольно популярна в силу того, что всего несколько лет назад ничего другого и не было – а также в силу простоты начальной реализации.</p>",
  "uKey": 6,
  "tasks": [
    {
      "name": "Верстка страницы со списком товаров",
      "html": "<p>Давайте представим, что мы делаем простой интернет-магазин. Нам нужно два типа страниц – одна для списка товаров, вторая – для отображения конкретного товара.</p><h2>Задание</h2><p>Отобразите на главной странице вашего сайта список товаров. Клик на товар должен вести на страницу товара.</p><p><img alt=\"Список товаров\" src=\"/img/tasks/product-list.jpg\"></p><h3>Подсказки и требования</h3><ul><li>Переименуйте <code>index.html</code> в <code>product.html</code>;</li><li>Создайте новую <code>index.html</code> с требуемой версткой;</li><li>Добавьте в роутинг возможность отображения страницы товара по адресу <code>/product</code></li><li>Вторую картинку товара можно скачать по адресу <code>http://80.211.25.188/img/tasks/product2.jpg</code>. Как и первую, ее необходимо скачать на ваш сервер с помощью <code>wget</code>.</li><li>Для верстки списка товаров используйте карточки <a href=\"https://getbootstrap.com/docs/4.1/components/card/\">https://getbootstrap.com/docs/4.1/components/card/</a></li><li>Кнопки внизу являются обычными ссылками с классом <code>btn btn-primary</code></li></ul>",
      "tKey": 1
    },
    {
      "name": "Список товаров и шаблонизация",
      "html": "<p>В программировании есть такое понятие – паттерны проектирования. Это удачные решения, которые принято применять в типовых ситуациях. Нам сейчас понадобится паттерн <em>сервис</em> – это когда несколько функций, отвечающий за один логический раздел, выносятся во внешний файл в виде объекта.</p><h2>Подготовка и подключение <code>ProductService</code></h2><p>Создайте файл <code>ProductService.js</code> со следующим содержимым:</p><pre><code class=\"language-javascript\">module.exports = {\n  init() {\n    //Тут будет функция инициализация нашего товарного сервиса\n  },\n  \n  getProducts() {\n    // Тут будет функция, которая выдает весь список товаров\n  }\n}</code></pre><p>Наша цель в этом и следующих заданиях – обеспечить вывод товаров на страницах нашего интернет-магазина. Очевидно, нам понадобится много функций для работы с ними. Все такие функции мы объединим в файле <code>ProductService.js</code> и сделаем его в виде Node.js-модуля. После этого наш модуль можно будет подключить к файлу <code>server.js</code> и удобно оттуда использовать:</p><pre><code>const ProductService = require(\"./ProductService.js\");\n\nProductService.init();\nconst products = ProductService.getProducts();</code></pre><p>Это очень удобно – вся сложная логика по хранению и поиску товаров будет скрыта в другом файле, и <code>server.js</code> не будет загромождаться лишним функционалом.</p><p>Перед использованием самостоятельно изучите механизм модулей (require + module.exports) в Node.js – \n<a href=\"https://nodejs.org/api/modules.html\">https://nodejs.org/api/modules.html</a>.</p><p>Теперь давайте проинициализируем наш сервис при запуске приложения. Иницилизация – это выполнение неких начальных действий, необходимы для дальнейшей нормальной работы. Инициализация часто занимается установкой соединения с базами данных или другими внешними сервисами, запуск других параллельных приложений или установка начальных значений.</p><p>Давайте вызовем инициализацию нашего модуля непосредственно перед началом прослушки порта нашим сервером. Если мы вызовем позже – теоретически возможен момент, когда пользователь уже вышлет запрос, и наш обработчик успеет вызвать функцию сервиса до того, как он будет инициализирован.</p><pre><code class=\"language-init\">ProductService.init()\nserver.listen(process.env.PORT);</code></pre><p>Теперь давайте реализуем эту инициализацию в <code>ProductService</code>. В дальнейшем он будет отвечать за получение информации о товарах из базы данных, а пока – мы просто запишем статическую информацию о товарах в переменную <code>products</code>.</p><blockquote><p>Переменная <code>products</code> не должна быть локальной, т.е. заданной в init.js. Если сделать ее локальной, то она будет недоступна для использования из других функций модуля, например <code>getProducts</code>.</p></blockquote><pre><code class=\"language-javascript\">let products = [];\nmodule.exports = {\n    init() {\n        products.push({\n            title: \"Товар 1\",\n            img: \"product.jpg\",\n            description: \"Краткое описание первого товара\",\n            price: 1000\n        });\n    },\n    \n    getProducts() {\n        \n    }\n}</code></pre><p>Теперь наша функция init просто добавляет (<code>push</code>) в пустой массив <code>products</code>, объявленный глобально для данного модуля, объект с информацией о первом товаре.</p><p>Теперь вернемся к функции getProducts. Предполагается, что она должна просто выдавать  список товаров. Поскольку мы храним товары в переменной products, нам достаточно просто ее вернуть:</p><pre><code>getProducts() {\n  return products;        \n}</code></pre><h2>Установка шаблонизатора</h2><p>Мы уже несколько раз сталкивались с функцией <code>require</code>. Как мы уже знаем, она может подключать функционал собственных модулей (ProductService.js), а также стандартных модулей, идущих в кмплекте с Node.js (мы использовали <code>http</code>, <code>path</code>, <code>fs</code>, <code>url</code>).</p><p>Кроме того, она умеет подключать модули, разработанные другими программистами.  Именно наличие огромной экосистемы (более 360 тысяч на начало 2017) этих пользовательских модулей <code>npm packages</code> делает язык Node одной из самых крутых и современных систем – множество задач уже реализовано за вас, вам остается только подключить модуль и воспользоваться его функционалом.</p><p>Нам понадобится установить модуль шаблонизатора <code>ejs</code>, который не идет в стандартной поставке. Установка выполняется через командную строку терминала. Остановите ваш сервер (Ctrl-C) и введите команду:</p><pre><code class=\"language-shell\">npm install ejs --save</code></pre><p>Давайте подробно разберем, что означает каждое слово в этой строке:</p><ul><li>npm – запуск менеджера пользовательских модулей (\"пакетов\", Node Packages Manager). Это стандартный инструмент, который идет вместе с Node.js. Сейчас его вытесняет <code>yarn</code>, который пользуется той же базой. В рамках курса мы его изучать не будем – но для практики рекомендуем его установить и самостоятельно учиться пользоваться.</li><li>install – это первый аргумент команды <code>npm</code> (напомним, что все аргументы linux- программ перечисляются через пробел). В качестве первого аргумента npm ожидает конкретное действие, кторое ей нужно выполнить. Здесь мы просим ее сделать <code>install</code> – т.е. установить модуль. Вместо <code>install</code> можно указать сокращенную форму <code>i</code>.</li><li>ejs - это пакет шаблонизатора, который мы хотим установить.</li><li>--save – это необязательный параметр, т.н. \"флаг\". Они часто прописываются для Linux-команд с двумя минусами (иногда с одним, если используется сокращенная форма). В данном случае мы просим сохранить информацию о факте установки в файл package.json, а не просто скачать модуль.</li></ul><p>Последний параметр довольно важен для понимания. Все внешние модули (пакеты) скачиваются в папку <code>node_modules</code> в корне проекта. Обычно боевой проект использует сотни таких пакетов, и папка node_modules начинает занимать гигабайты места. Это создает серьезные сложности при совместной работе над проектом нескольких разработчиков, поскольку обмен исходным кодом начинает занимать кучу лишнего времени. Поэтому общепринятое решение – папка node_modules исключается из репозитория, не считается исходным кодом, и ее никуда не передают. </p><p>Вместо этого вся информация об используемых пакетах, их версиях и другая нужная информация сохраняется в небольшом файле <code>package.json</code>. Имея этот файл, любой разработчик может выполнить команду <code>npm install</code> (без параметров), менеджер npm считает из файла <code>package.json</code> всю информацию о необходимых модулях, и их установит.</p><blockquote><p>Обратите внимание – при выполнении команды <code>npm install ejs --save</code> мы скорее всего получим ошибку. Она связана с тем, что у нас пока нет файла <code>package.json</code>, а создавать его автоматически <code>npm</code> не хочет – видимо, разработчики npm в этот день пошли пить смузи вместо работы. Чтобы форсировать создание <code>package.json</code>, нам нужно выполнить команду <code>npm init</code> и ответить на несколько заданных вопросов (можно просто нажимать Enter).</p></blockquote><p>Теперь у нас должна появиться папка <code>node_modules</code>, а в ней – наш первый установленный модуль <code>ejs</code>. </p><h2>Шаблонизатор EJS</h2><p>Как работает шаблонизатор EJS?</p><ol><li>Создается файл шаблона – который представляет собой почти обычный HTML. Только в некоторых местах, где должны быть динамические данные, вписываются странные теги вроде <code>&lt;%=  product.title %&gt;</code>.</li><li>Готовится большой объект с данными – там должны быть прописаны все данные, которые понадобятся в шаблоне.</li><li>Вызывается функция рендеринга, которой передается шаблон и этот набор данных. Рендеринг подставляет внутрь всех странных тегов соответствующие данные из набора и получается готовый HTML.</li></ol><p>Вот простой пример. В данном случае в качестве шаблона мы используем просто строку – обычно шаблоны бывают большими, поэтому хранятся в файлах и считываются перед рендерингом.</p><pre><code class=\"language-javascript\">const ejs = require(\"ejs\");\n\nconst data1 = { \n  product: {\n    title: \"Товар 1\", \n    imageURL: \"product.jpg\" \n  }\n};\nconst data2 = { \n  product: {\n    title: \"Товар 2\", \n    imageURL: \"product2.jpg\" \n  }\n};\n\nconst template = ejs.compile(\n  \"&lt;h1&gt;&lt;%= product.title %&gt;&lt;/h1&gt;&lt;img src='&lt;%= product.imageURL %&gt;' /&gt;\"\n);\n\nconst product1 = ejs.render(template, data1);\nconst product2 = ejs.render(template, data2);</code></pre><p>Вместо функции ejs.render можно просто использовать переменную <code>template</code> как   функцию:</p><pre><code>const product1 = template(data1);</code></pre><p>EJS – это довольно распространенный язык шаблонов, и он используется не только в Node. Изучите самостоятельно его возможности</p><p><a href=\"http://ejs.co/\">http://ejs.co/</a>\n<a href=\"https://www.npmjs.com/package/ejs\">https://www.npmjs.com/package/ejs</a>\n<a href=\"https://ionicabizau.github.io/ejs-playground/\">https://ionicabizau.github.io/ejs-playground/</a></p><h2>Задание</h2><p>Сделайте на главной странице вывод первой карточки продукта через шаблонизатор. Цикл шаблонизатора осваивать пока не надо – просто выведите в нем нулевой элемент массива <code>products</code>, полученного из ProductService.</p><h3>Подсказки и требования</h3><ul><li>Обслуживание главной страницы теперь нужно вытащить из serveStatic в отдельную функцию - serveIndex, поскольку ее логика гораздо сложнее.</li><li>Для чтения содержимого файла мы раньше использовали <code>readFileSync</code> и просто отправляли ее содержимое в <code>res</code>. Нюанс заключается в том, что <code>readFileSync</code> возвращает не строку, а специальный объект Buffer – <a href=\"https://nodejs.org/api/buffer.html\">https://nodejs.org/api/buffer.html</a>. Когда мы отправляли его в <code>res.send()</code>, все было номрально – потому что <code>res.send()</code> умеет обрабатывать и буфер, и строку. Но когда мы попытаемся передать этот буфер в <code>ejs.compile()</code>, чтобы сформировать шаблон – мы получим ошибку, т.к. <code>ejs.compile()</code> понимает только строки. Для избежания ошибки мы должны сначала преобразовать буфер в строкус помощью функции <code>toString():</code>const content = fs.readFileSync(\"static/index.html\").toString();`\nBuffer toString()</li><li>Если у вас возникают любые сложности с рендерингом шаблона, постарайтесь в начале исправить их сами – это гораздо полезнее, чем сразу звать преподавателя. Небольшой совет – когда сформируете объект с данными, выведите его перед рендерингом в консоль с помощью <code>console.log</code>. Вы увидите, что реально приходит в функцию компиляции, и визуальное сравнение с тем, как вы пытаетесь обратиться к этим данным в шаблоне – может помочь найти ошибку.</li></ul>",
      "tKey": 2
    },
    {
      "name": "Цикл в шаблонизаторе",
      "html": "<p>Теперь давайте сделаем, чтобы на главной странице выводилось несколько продуктов. То есть, в набор данных мы теперь будем передавать не один конкретный товар из списка, а сразу массив товаров.</p><blockquote><p>Кстати, массив данных для передачи в шаблонизатор часто называют <code>scope</code> (скоуп)</p></blockquote><pre><code>const products = ProductService.getProducts();\nconst scope = {\n  products: products\n};\n\n...\n\nconst html = template(scope);</code></pre><p>Теперь остается только внедрить этот массив в шаблон. Нам нужно, чтобы шаблонизатор \"пробежался\" по всему массиву <code>products</code>, и для каждого из них вывел сложную структуру c карточкой данного товара.</p><p>Если вы читали документацию по EJS, то обратили внимание – теги EJS бывают двух видов. Первые, со знаком <code>=</code> в начале <code>&lt;%= выражение  %&gt;</code> непосредственно встраивают результат выражения в результирующий HTML. </p><p>Вторые, без знака <code>=</code>, (например <code>&lt;% let a = 10;  %&gt;</code> в HTML ничего не выдают, зато могут делать другие полезные действия – например, записывать значения в переменные, которые потом будут использованы, или содержать какие-то конструкции <code>javascript</code>, необходимые для управления логикой. Типичный пример:</p><pre><code class=\"language-ejs\">&lt;% if (product.hasPrice) { %&gt;\n  &lt;div class=\"price\"&gt;&lt;%= product.price %&gt;&lt;/div&gt;\n&lt;% } %&gt;</code></pre><p>Обратите внимание – мы использовали два тега без знака равенства. Первый использовался для открытия блока <code>if</code>. Поскольку внутри <code>if</code> может быть несколько действий, мы открыли операторную скобку <code>{</code>. Внутри этих операторных скобок мы можем просто перечислять теги <code>html</code> или <code>ejs</code> – все они будут выполнены или вставлены в <code>html</code> только при выполнении условия. Если мы открыли операторную скобку <code>{</code> – нужно обязательно ее закрывать. Это нужно, чтобы <code>ejs</code> понял, где заканчивается блок условия и где можно продолжать выводить теги в обычном режиме. Кроме того, если забыть поставить закрывающую скобку, то <code>ejs</code>, как и обычный <code>javascript</code> – будет считать это синтаксической ошибкой и откажется компилировать весь шаблон.</p><p>Аналогичным образом используeтся и оператор <code>for</code> внутри ejs. Например:</p><pre><code class=\"language-ejs\">&lt;% for (let i = 0; i &lt; products.length; i++) { %&gt;\n  &lt;% let product = products[i]; %&gt;\n  &lt;div&gt;&lt;h1&gt;&lt;%= product.title %&gt;&lt;/h1&gt;&lt;/div&gt;\n&lt;% } %&gt;</code></pre><h2>Задание</h2><p>Добавьте в наш <code>ProductsService</code> один или несколько товаров с разными характеристиками и добейтесь, чтобы они выводились на главной странице с помощью шаблона.</p>",
      "tKey": 3
    },
    {
      "name": "Идентификация товаров и ЧПУ",
      "html": "<p>Наши ссылки на страницу конкретного товара сейчас выглядят просто как <code>/product</code>. Поскольку они ничем не отличаются друг от друга, вывести информацию о конкретном правильном продукте система не сможет. Очевидно, URL страницы продукта должен включать в себя что-то, с помощью чего наш сервер сможет определить, какой именно товар ему отображать.</p><blockquote><p>Напомним, что все товары у нас пока хранятся в обычном массиве. Чуть позже мы будем хранить их в базе данных – специальном хранилище, которое предоставляет удобный доступ к записям, позволяет модифицировать их и сохраняет все данные между сеансами запуска сервера (в отличие от обычного массива, который хранится в памяти). В любой базе данных каждая запись получает свой <code>идентификатор</code> – уникальный для каждой записи атрибут, по которому легко найти любую запись. В качестве базы данных мы будем использовать MongoDB, идентификаторы в которой представляют собой строку из 24 символов, например <code>507f1f77bcf86cd799439011</code></p></blockquote><p>Обычно для идентификации товара на таких страницах используется один из следующих способов:</p><ol><li>Кусок URL соответствует идентификатору записи в базе данных, например <code>/product/507f1f77bcf86cd799439011</code>. Обычно такой URL выглядит неприятно, он непонятен для человека и его неудобно копировать и кому-то передавать. Даже в других базах, когда идентификатор имеет числовой вид, эта практика не является распространенной.</li><li>ЧПУ (человеко-понятный URL). Чтобы сделать URL человеко-понятным, для идентификатора товара используют дополнительный атрибут, который обычно представляет собой название товара, переведенное в латиницу и с исключением запрещенных для URL символов. Этот атрибут называют <code>slug</code> (слаг). Например, для товара \"Детская книжка-раскраска\" слаг может быть таким – <code>detskaya-knizhka-raskraska</code>. Обратите внимание, что пробелы запрещены в URL, поэтому они заменены дефисами. Обычно слаг генерируется автоматически на основе названия товара. Пример человеко-понятного  URL – <code>/product/detskaya-knizhka-raskraska</code>.</li><li>Комбинированный метод. Иногда бывает, что в базе может оказаться два разных товара с одинаковым названием. В этом случае для них сгенерруется одинаковый слаг, и ссылка из разных частей каталога будет вести на одинаковую страницу продукта. В результате только один из товаров будет показан, а второй полностью выпадет из показа и продаж – что неприемлемо. Поэтому чаще всего в URL для больших каталогов комбинируют слаг и уникальный числовой идентификатор продукта. В случае, если товары хранятся в БД с числовыми идентификаторами (например, <code>PostgreSQL</code>), в URL можно использовать их. В случае, если идентификаторы сложные, как в <code>MongoDB</code> – нам придется завести дополнительный числовой атрибут, который мы будем использовать в качестве ключа и самостоятельно следить за его уникальностью. Примеры комбинированных URL для книжки-раскраски – <code>/product/2071-detskaya-knizhka-raskraska</code> и <code>/product/13722-detskaya-knizhka-raskraska</code>.</li></ol><h3>Извлечение кода из URL</h3><p>Чтобы извлечь код из URL, нам понадобится изучить несколько стандартных функций по работе со строками в <code>javascript</code> – <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String</a></p><h4>Функция <code>replace</code></h4><p>Может заменить в строке указанный кусок на другой (или на пустую строку)  <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/replace\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/replace</a> </p><pre><code class=\"language-javascript\">const url = \"/product/2071-detskaya-knizhka-raskraska\";\nconst slugPart = url.replace(\"\"/product/\", \"\")\nconsole.log(slugPart);</code></pre><h4>Функция <code>split</code></h4><p>Разбивает строку на несколько по указанному символу, и возвращает массив из этих подстрок. <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/split\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/split</a> </p><pre><code class=\"language-javascript\">const slugPart = \"2071-detskaya-knizhka-raskraska\";\nconst slugParts = slugPart.split(\"-\");\nconsole.log(slugParts); // Выведет массив [\"2071\", \"detskaya\", \"knizhka\", \"raskraska\"]</code></pre><h3>Выдача товара по ключу</h3><p>После того, как мы извлечем строку с кодом  из URL, нам понадобится найти товар с заданным ключом в нашем ProductService. Для этого нужно будет добавить функцию <code>getProductByKey</code>, которая переберет весь список товаров и вернет только тот, у которого ключ совпадает с заданным.</p><p>Для этого можно воспользоваться циклом <code>for</code> или функцией массива <code>find</code> – <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find</a></p><h3>Роутинг динамических страниц</h3><p>До этого задания все названия страниц были статичными. Поэтому их маршрутизацию (роутинг) можно было делать с помощью оператора <code>switch</code>. Сейчас так не получится – страницы с продуктом будут иметь совершенно разные URL, но все они должны обслуживаться одной функцией. </p><p>Поэтому либо до использования <code>switch</code> со статическими URL, либо в его блоке <code>default</code> нам нужно будет вставить проверку <code>if</code>, соответствует ли URL пришедшего запроса нашему динамическому URL.</p><p>Обычно такую проверку осуществляют с помощью <code>регулярных выражений</code> (RegExp, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions</a>). Мы пока так делать не будем и удовлетворимся простой проверкой с помощью функции <code>indexOf</code>  (<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf</a>) – которая проверит, начинается ли пришедший URL со строки <code>/product/</code>:</p><pre><code class=\"language-javascript\">if (urlParsed.pathname.indexOf(\"/product/\") === 0) {\n // вызов функции обработки страницы\n}</code></pre><h2>Задание</h2><p>Реализуйте вывод на странице продукта правильного товара, используя комбинированные человеко-понятные URL.</p><h3>Подсказки и требования</h3><ul><li>Доработайте наш массив товаров в <code>ProductService.js</code>. В каждый товар нужно добавить атрибуты <code>slug</code> и <code>key</code> –  уникальный для каждого товара числовой ключ.</li><li>Реализуйте в <code>ProductService.js</code> функцию <code>getProductByKey</code>.</li><li>Сформируйте правильные ссылки в нашем ejs-шаблоне для главной страницы. Ссылка должна иметь вид <code>/product/поле key-поле slug</code></li><li>Создайте отдельную функцию <code>serveProduct</code>, которая будет обслуживать страницу продукта. Она должна извлечь из URL ключ товара, найти в <code>ProductService.js</code> правильный товар по ключу, сформировать <code>scope</code> с данными для шаблона (<code>scope</code> будет объектом с единственным поле <code>product</code>, содержащем полученный продукт) и сформировать страницу по шаблону, как это делалось в <code>serveIndex</code>.</li><li>Обеспечьте правильную проверку URL и вызов функции <code>serveProduct</code> из роутинга.</li><li>Доделайте страницу <code>product.html</code>, превратив ее в шаблон, который выводит правильную информацию о продукте</li><li>Выведите на странице продукта блок <code>breadcrumb</code> (т.н. \"хлебные крошки\", <a href=\"https://getbootstrap.com/docs/4.1/components/breadcrumb/\">https://getbootstrap.com/docs/4.1/components/breadcrumb/</a>) для удобного возврата на главную страницу. Ссылка на главную страницу должна быть относительной (<code>href=\"/\"</code>).</li></ul>",
      "tKey": 4
    },
    {
      "name": "База данных",
      "html": "<p>До этого момента мы хранили все наши товары в обычной переменной внутри сервиса <code>ProductService.js</code>. Это неудобно и неправильно. </p><p>Представьте себе, что мы бы захотели дать администратору нашего магазина возможность добавлять новые товары или менять информацию о существующих. Мы бы добавили в наш <code>ProductService.js</code> функции <code>createProduct</code> и <code>updateProduct</code>, создали на сайте закрытую зону – панель инструментов, которая в конечном счете вызывает эти функции. Функции меняли бы информацию в массиве <code>products</code>, и главная страница моментально отображала бы изменения.</p><p>Но – как только мы решим перезагрузить наш сервер после обновления кода – все изменения, сделанные администратором, пропадут. Поэтому (и по многим другим причинам) для хранения данных используются специальные хранилища – базы данных. Мы будем использовать базу, которая называется <code>MongoDB</code>, как наиболее простую в освоении. Для дальнейшего самостоятельного изучения мы рекомендуем базу PostgreSQL.</p><h2>Установка и конфигурация MongoDB</h2><p>Процесс установки <code>MongoDB</code> на нашу платформу <code>Cloud9</code> подробно описан в статье <a href=\"https://community.c9.io/t/setting-up-mongodb/1717\">https://community.c9.io/t/setting-up-mongodb/1717</a>.</p><p>Для установки нужно выполнить несколько Linux-команд в терминале, в котором мы запускали наш сервер.</p><p>Сначала, нужно установить сам движок (т.е. программу) MongoDB. Не забудьте перед выполнением всех команд остановить сервер/</p><pre><code class=\"language-shell\">sudo apt-get install -y mongodb-org</code></pre><p>Затем последовательно выполнить следующие команды (после ввода каждой строки нажимайте Enter):</p><pre><code>mkdir data\necho 'mongod --bind_ip=$IP --dbpath=data --nojournal --rest \"$@\"' &gt; mongod\nchmod a+x mongod</code></pre><blockquote><p>Первая команда создает на нашем сервере папку <code>data</code>. Вторая – создает файл <code>mongod</code> (mongo daemon). В этот файл она записывает команду запуска <code>mongod</code> со всеми нужными параметрами. В этом нет особой необходимости – можно было бы вызывать и вручную, но так гораздо удобнее. Третья команда – модифицирует права на запуск этого файла, в это на данной стадии вникать не нужно.</p></blockquote><h2>Запуск <code>mongodb</code> и ручной ввод команд</h2><p>Теперь откройте новую вкладку терминала (рядом с текущей вкладкой терминала есть кнопка  \"+\" – нажмите и выберите New Terminal) и выполните команду:</p><pre><code class=\"language-shell\">./mongod</code></pre><p>Эта команда запускает т.н. демон mongodb. Демонами называются программы, работающие в фоновом режиме и не взаимодействующие напрямую с пользователем. Пока работает демон (т.е. пока не остановлен сочетанием <code>Ctrl-C</code> в данном терминале или пока он не столкнулся с фатальной ошибкой) – <code>MongoDB</code>успешно функционирует и мы можем отправлять к ней запросы.</p><p>Все взаимодействие с <code>mongodb</code> – добавление новых записей, получение или модификация существующих – осуществляется через запросы на специальном языке. Запросы можно отправлять как из нашей программы на <code>Node.js</code>, так и вручную.</p><p>Давайте выполним несколько запросов вручную, чтобы познакомиться с языком и подготовить базу к дальнейшему использованию.</p><p>Откройте еще одну вкладку терминала, введите там команду <code>mongo</code> и нажмите Enter</p><p>В ответ вы получите что-то вроде:</p><pre><code>MongoDB shell version: 2.6.12\nconnecting to: test\nServer has startup warnings: \n2018-07-05T06:07:15.046+0000 ** WARNING: --rest is specified without --httpinterface,\n2018-07-05T06:07:15.046+0000 **          enabling http interface\n&gt; </code></pre><p>Последний символ – знак <code>&gt;</code> – это приглашение <code>MongoDB</code> ко вводу команд</p><p>Давайте ведем несколько команд:</p><pre><code class=\"language-mongo\">use shop\ndb.createCollection(\"product\")</code></pre><p><code>MongoDB</code> позволяет обслуживать сразу несколько баз данных. Переключение между ними происходит с помощью команды <code>use</code>. Если указанная база еще не была создана – она автоматически создается. После команды <code>use</code> все последующие команды применяются только к выбранной базе данных.</p><p>То есть, первой командой мы создаем базу <code>shop</code>, в которой в дальнейшем будем хранить все данные нашего интернет-магазина.</p><p>В <code>MongoDB</code> вся информация хранится в виде <code>документов</code>, объединенных в <code>коллекции</code>. Например, мы можем создать коллекцию для хранения всех товаров, и назвать ее <code>product</code>.  Каждый документ в этой коллекции будет соответствовать одному товару.</p><p>Вторая команда из нашего примера как раз создает коллекцию <code>product</code>.</p><h2>Запуск <code>./mongod</code> после некорректного завершения</h2><p>Если вы сделаете паузу в разработке на определенный период, cloud9 в целях экономии своих ресурсов выключит наш сервер и включит только когда мы снова вернемся к разработке.</p><p>Если в момент этого насильного выключения был запущен демон ./mongod, то он не сможет корректно завершить свою работу. База <code>MongoDB</code> довольно сильно зависит от корректного завершения работы. Ради обеспечения скорости работы она не сразу скидывает все новые поступающие данные в соответствующие файлы внутри своей папки. Часть из них она держит в оперативной памяти, а часть - в небольшом файле подкачки с быстрым доступом. </p><p>Поэтому после насильного выключения база может повторно не запустится. Если мы при попытке запуска увидим в терминале сообщение наподобие:</p><pre><code>**************\nUnclean shutdown detected.\nPlease visit http://dochub.mongodb.org/core/repair for recovery instructions.\n*************</code></pre><p>То нам придется перед следующим запуском выполнить команду для восстановления данных и приборки:</p><pre><code>mongod --dbpath ./data --repair</code></pre><p>После этого наш <code>./mongod</code> можно будет запускать обычным способом.</p><h2>Создание и чтение документов</h2><p>Для создания документов используется команда db.ИМЯ КОЛЛЕКЦИИ.insert(), которой нужно передать объект со свойствами будущего документа.</p><p>Попробуйте выполнить такую команду. В терминале не очень удобно вводить многострочные команды – поэтому воспользуйтесь копированием и вставкой.</p><pre><code class=\"language-mongo\">db.product.insert({\n  title: \"Товар 1\",\n  img: \"product.jpg\",\n  description: \"Краткое описание первого товара\",\n  price: 1000,\n  key: 500,\n  slug: \"tovar-1\"\n})</code></pre><p>В ответ должно было появиться что-то вроде</p><pre><code class=\"language-mongo\">WriteResult({ \"nInserted\" : 1 })</code></pre><p>Это означает, что документ успешно вставлен в коллекцию. Теперь его можно оттуда прочитать:</p><pre><code class=\"language-mongo\">db.product.find()</code></pre><p>И мы увидим наш документ с товаром:</p><pre><code class=\"language-mongo\">{ \"_id\" : ObjectId(\"5b3dd4a7542a925936ea39fb\"), \"title\" : \"Товар 1\", \"img\" : \"product.jpg\", \"description\" : \"Краткое описание первого товара\", \"price\" : 1000, \"key\" : 500, \"slug\" : \"tovar-1\" }</code></pre><p>Как видите, в документе появилось поле <code>_id</code>, которое мы не задавали. Об этом заботится сама база данных – для каждого нового документа она генерирует уникальный идентификатор и вставляет его в поле <code>_id</code>.</p><p>У <code>MongoDB</code> есть много других команд – выдача документа по идентификатору, изменение документов, поиск документов по фильтру. Команды (операторы) <code>MongoDB</code> вы можете изучить самостоятельно: <a href=\"https://docs.mongodb.com/manual/reference/operator/\">https://docs.mongodb.com/manual/reference/operator/</a></p><h2>Обращение к <code>MongoDB</code> из программного кода</h2><p>Для работы с <code>MongoDB</code> нам понадобится еще одна библиотека, которая не идет в стандартной поставке Node.js и которую, как и <code>ejs</code>, нужно установить самостоятельно.</p><pre><code>npm i mongodb --save</code></pre><p>Первое, что нам нужно сделать – это подключиться к базе из нашей программы. В модуле <code>ProductService.js</code> мы предусмотрительно создали функцию <code>init</code>, которая раньше помещала в массив <code>products</code> необходимые данные. Больше нам не нужна ни переменная <code>products</code>, ни код, который вручную вставляет в нее товары.</p><p>Вместо этого нам нужно задать в модуле две переменные <code>shopDatabase</code> и <code>productCollection</code> и переписать код инициализации следующим образом:</p><pre><code class=\"language-javascript\">const MongoClient = require('mongodb').MongoClient;\n\nlet shopDatabase;\nlet productCollection;\nmodule.exports = {\n    init() {\nMongoClient.connect('mongodb://localhost:27017')\n        .then(function (clientInstance) {\n            shopDatabase = clientInstance.db(\"shop\");\n            productCollection = shopDatabase.collection(\"product\");\n        })\n  },\n\n ...\n\n};</code></pre><p>Давайте разберемся, что здесь происходит. Общая цель – нам нужно подключиться к базе и записать в глобальные переменные <code>shopDatabase</code> и <code>productCollection</code> готовые объекты базы данных <code>shop</code> и коллекции документов <code>product</code>.</p><h3>Понимание асинхронности и Промисы (Promises)</h3><p>Поскольку операция подключения к БД может занять значительное время, она сделана <em>асинхронной</em>. То есть, мы можем вызвать операцию подключения и двигаться дальше, не заботясь о том, когда она завершится. </p><p>Однако, записать нужные значения в наши переменные мы сможем, только когда подключение успешно закончится. Где же нам писать этот код?</p><p>Давайте в более общем виде разберем механизм асинхронности в javascript. Раньше мы имели дело с синхронным кодом:</p><pre><code>// вызываем какую-то быструю операцию\nconst navs = document.querySelectorAll(\".nav\");\n// сюда мы попадаем только когда операция завершится</code></pre><p>А вот пример работы асинхронного кода:</p><pre><code>const promise = someAsyncOperation();\n// мы запустили некую длительную операцию,\n// но она еще не завершилась\n// однако, она устроена так, чтобы нас не блокировать\n// поэтому она мгновенно возвращает управление, и в фоне продолжает работать.\n// А мы тем временем можем продолжать выполнять другие действия\nalert(\"Этот алерт вылезет мгновенно\");\n\npromise.then(function(result) {\n  // эта асинхронная функция вернула нам \"промис\" –\n  // \"обещание\", что она закончит свою работу\n  // мы можем вызвать у промиса метод then\n  // и в качестве аргумента передать ему анонимную функцию\n  // промис вызовет ее позже, когда асинхронная функция закончит всю необходимую работу\n  alert(\"Этот алерт будет вызван значительно позже\");\n});</code></pre><blockquote><p>Концепция асинхронности и промисов крайне важна для дальнейшего понимания. Это одна из главных отличительных черт javascript. Постарайтесь хорошенько ее усвоить и уложить в голове <a href=\"https://habr.com/post/209662/\">https://habr.com/post/209662/</a></p></blockquote><p>Теперь давайте вернемся к нашему примеру, теперь уже с более полным пониманием того, что происходит.:</p><pre><code>let shopDatabase;\nlet productCollection;\nmodule.exports = {\n    init() {\nMongoClient.connect('mongodb://localhost:27017')\n        .then(function(clientInstance) {\n            shopDatabase = clientInstance.db(\"shop\");\n            productCollection = shopDatabase.collection(\"product\");\n        })\n  },</code></pre><p>Из документации по <code>mongodb</code> \n (<a href=\"https://www.npmjs.com/package/mongodb\">https://www.npmjs.com/package/mongodb</a>) мы знаем, что функция <code>MongoClient.connect</code> – асинхронная, и возвращает промис. Поэтому мы сразу подписываемся на его изменения с помощью функции <code>then</code> и все дальнейшие действия производим в переданной ему  анонимной функции.</p><p>Когда асинхронная функция имеет какой-то осязаемый результат выполнения, которым она должна поделиться – она передает его промису. Когда промис будет вызывать нашу анонимную функцию (которую мы подписали с помощью <code>then</code>), он передаст ей этот результат первым аргументом. </p><p>Поэтому в нашей анонимной функции мы назвали первый аргумент <code>clientInstance</code>, и используем его для получения базы данных и коллекции.</p><p>Вот еще пара моментов, которые неплохо бы знать про промисы. Когда возникнет необходимость, нужно будет освоить их самостоятельно.</p><blockquote><p>Промисы умеют обрабатывать не только успешный результат, но и ошибки, которые произошли в асинхронной функции. Подписаться на ошибку можно точно так же, как и на успешный результат – только уже не с помощью функции <code>then</code>, а с помощью функции <code>catch</code>. Изучать эту концепцию можно только после самостоятельного освоения механизма <code>try/catch</code> для обработки ошибок в обычном синхронном коде. </p><p>Поскольку в большинстве случаев действия нужно продолжать после успешного выполнения асинхронной функции, в современной версии языка <code>javascript</code> появился механизм <code>async/await</code>, который делает обработку промисов значительно проще. К сожалению, в версии языка Node.js, которая идет внутри Cloud9,  механизм <code>async/await</code> пока не поддерживается.</p><p>Вы уже поняли, что мы возвращаемся из <code>ProductService.init</code> раньше, чем происходит фактическое подключение базы данных. Не дожидаясь подключения, в модуле <code>server.js</code> мы запускаем веб-сервер и начинаем обрабатывать запросы. Если по каким-то причинам процесс  подключения затянется, может получиться ситуация, когда мы уже обрабатываем какой-то запрос –  а база еще не готова. В нашем учебном проекте мы с этим фактом миримся, но на практике процесс инициализации тоже делают асинхронным – и дожидаются инициализации всех необходимых подключений перед тем, как продолжить работу.</p></blockquote><h3>Коллбеки, или почему асинхронные функции библиотек иногда не возвращают промисы</h3><p>Промисы стали стандартом де-факто относительно недавно. До этого все пользовались другим механизмом для работы с асинхронным кодом – он назывался коллбеки (callbacks). Пользователь функции, которая делает что-то асинхронное, ыл вынужден передавать ей еще один аргумент – функцию-коллбек <code>callback</code> для обратного вызова. Когда асинхронная функция считала, что закончила работу, она просто вызывала этот коллбек с результатом.</p><p>Для понимания коллбеков можно прочитать одну из этих двух статей:\n<a href=\"https://habr.com/post/151716/\">https://habr.com/post/151716/</a>\n<a href=\"https://www.tutorialspoint.com/nodejs/nodejs_callbacks_concept.htm\">https://www.tutorialspoint.com/nodejs/nodejs_callbacks_concept.htm</a></p><p>Коллбеки были популярны довольно долго, поэтому в <code>node</code> множество старых библиотек написано с их использованием. Авторы многих этих библиотек медлительны и до сих пор не успели создать новые версии, работающие на промисах. Но – промис-варианты этих библиотек часто создаются другими сторонними разработчиками. </p><p>Поэтому, когда вы столкнетесь с библиотекой, не поддерживающей промисы, постарайтесь сначала найти ее промис-вариант. Как правило, в названии разработчики используют название старой функции с суффиксом <code>-promise</code> или префиксом <code>promise-</code>. </p><p>Например:</p><pre><code>https://www.npmjs.com/package/ftp\nhttps://www.npmjs.com/package/promise-ftp</code></pre><h2>Получение товаров и создание асинхронной функции</h2><p>До этого мы только пользовались асинхронными функциями. Сейчас, когда мы будем дорабатывать метод <code>getProducts</code>, нам нужно будет научиться самим создавать такие функции. Как вы поняли, асинхронная функция должна возвращать <code>Promise</code>. Обычно асинхронные функции создаются примерно так:</p><pre><code>function asyncFunction() {\n  return new Promise(function(resolve, reject) {\n    // тут мы выполняем какие-то полезные действия\n    // возможно, они тоже будут содержать вызовы других асинхронных функций\n    // и в любой момент мы вызываем resolve(), если все прошло хорошо\n    // при этом передаем в resolve некий полезный результат, если есть.\n    // а в случае ошибкаи вызываем функцию reject()\n    const someResult = 10;\n    resolve(someResult);\n  })\n}</code></pre><p>То есть, мы конструируем объект класса <code>Promise</code> и сразу же его возвращаем. Конструктору <code>Promise</code> нужно передать анонимную функцию, которая и будет выполнять все полезные действия. Эта функция мгновенно будет вызвана, и ей передадут два аргумента – мы назвали их <code>resolve</code> и <code>reject</code>. Оба аргумента – функции. Мы должны будем их вызвать, когда вся полезная работа будет сделана. Вызов <code>resolve</code> приведет к тому, что наш промис последовательно вызовет все функции, которые подписывались на него с помощью метода <code>then</code>.</p><p>Давайте перепишем нашу функцию <code>getProducts</code> так, чтобы она получала записи из базы данных – точнее, из коллекции <code>product</code>, ранее записанной в переменную <code>productCollection</code>.</p><pre><code class=\"language-javascript\">  getProducts() {\n        return new Promise(function(resolve, reject) {\n            const cursor = productCollection.find();\n            const promise = cursor.toArray();\n            promise.then(function(products) {\n                resolve(products);\n            })\n        });\n    },</code></pre><p>Вот что мы делаем. Сначала – идет стандартная обвязка асинхронной функции, которую мы рассмотрели раньше. Затем мы вызываем метод <code>find()</code> у <code>productCollection</code>. Он возвращает нам не массив товаров, как хотелось бы – а некий <code>курсор</code> – указатель на результат запроса (возможно, еще не выполненный). Из курсора можно получать результаты п одной записи, а можно целиком – с помощью асинхронной функции <code>toArray</code>.</p><pre><code>const promise = cursor.toArray();</code></pre><p>Функция <code>toArray</code> произведет фактическое выполнение запроса и вернет в промис результат – массив найденных документов. Далее, мы просто подписываемся на этот промис, и в случае его выполнения просто вызываем наш итоговый <code>resolve</code>, передавая ему результат:</p><pre><code>promise.then(function(products) {\n  resolve(products);\n})</code></pre><p>Функцию, которую мы написали, можно сильно упростить. В целом такое решение – создавать новый промис, вызывать другие асинхронные функции,а затем в нужный момент вызывать <code>resolve()</code> или <code>reject()</code> – является универсальным, и его часто придется применять. Поэтому очень важно разобраться и понять в нем каждую строчку кода.</p><p>Однако, в нашем конкретном случае, есть более простое решение. В целом, нам нужно вернуть промис, который при успехе вернет массив продуктов. Но – промис, который возвращает нам функция <code>cursor.toArray()</code> делает ровно то же самое. Значит, мы можем просто вернуть его в качестве результата нашей функции и все будет работать как надо. </p><pre><code>getProducts() {\n  const cursor = productCollection.find();\n  const promise = cursor.toArray();\n  return promise;\n}</code></pre><p>Такой подход довольно часто применяется. Естественно, он сработает, только если нас полностью устраивает результат, который вернет промис из библиотеки (в данном случае <code>cursor.toArray()</code>). Если бы нам нужно было выполнить над результатом какие-то дополнительные действия или как-то его преобразовать перед выдачей из нашей функции – пришлось бы делать обертку из нового промиса, как в первом варианте. Естественно, разработчики библиотек стараются сделать свои функции максимально удобными – поэтому ситуация, когда они возвращают ровно то, что нам нужно, и мы можем просто возвращать их промисы – довольно распространена.</p><h2>Обращение к асинхронной функции из обработчика HTTP-запроса</h2><p>Теперь наш обработчик <code>serveIndex</code> работает некорректно.</p><pre><code class=\"language-javascript\">const products = ProductService.getProducts();</code></pre><p>Наша <code>getProducts</code> теперь асинхронная, и в константу <code>products</code> передастся не желаемый список продуктов, а промис. Нам нужно на него подписаться с помощью функции <code>then</code> и все остальные действия проводить в функции-обработчике.</p><h2>Задание</h2><p>Перенести весь код работы с <code>MongoDB</code> в наш проект и доделайте функцию <code>serveIndex</code>, чтобы она нормально работала с асинхронным поведением <code>getProducts</code>.</p><h3>Подсказки</h3><p>Не забудьте, что для успешного функционирования нашего магазина теперь необходимо, чтобы в соседней вкладке был запущен демон <code>mongod</code>.</p><p>Кроме того, вы столкнетесь с еще одним важным последствием асинхронности.</p><p>В нашей основной функции-роутере в файле <code>server.js</code> мы выбирали обработчик с помощью оператора <code>switch</code>, а затем его вызывали. Обработчик производил необходимые манипуляции с объектом <code>res</code>, затем управление возвращалось обратно в роутер, и мы вызывали <code>res.end()</code>.</p><p>Сейчас, поскольку функция <code>serveIndex</code> тоже становится асинхронной (т.е. зависит от Promise), управление в роутер вернется раньше, чем <code>serveIndex</code> произведет выдачу в <code>res</code>. То есть, <code>res.end()</code> вызовется раньше, чем <code>res.write()</code>. В результате в браузер уйдет пустой ответ и отобразится пустая страницы. Все дальнейшие попытки записи в отправленный ответ с помощью <code>res.write()</code> будут просто проигнорированы системой.</p><p>То есть, общая для всех обработчиков отправка <code>res.end()</code> больше недопустима. Мы должны вынести ее из роутера и добавить в каждый обработчик после выдачи необходимых данных.</p>",
      "tKey": 5
    },
    {
      "name": "Страница товара и findOne",
      "html": "<p>Теперь давайте адаптируем нашу страницу товара к базе данных. Раньше мы самостоятельно искали наш товар в массиве с помощью цикла или функции <code>find()</code> – которая, по сути, является тем же самым. Если бы в массиве находилось десять тысяч записей, мы бы при каждом посещении страницы последовательно их перебирали, и это отнимало бы у сервера массу времени. Если бы наш магазин стал популярен, и нам бы пришлось обрабатывать тысячи посещений в день, при таком подходе наш сервер бы страшно тормозил и отдавал каждую страницу мучительно долго.</p><p>Поиск по базе данных – это гораздо более быстрая и удобная операция, чем последовательный перебор. Особенно, если мы заранее знаем, по каким полям нам придется искать искать и предварительно настроим в базе данных индексацию. Это не входит в рамки данного курса, но после прохождения крайне рекомендуется изучить эту концепцию самостоятельно.</p><p>Давайте посмотрим, что нам нужно сделать. Ранее мы пользовались функцией <code>find()</code>, которая доступна в каждой монго-коллекции. Этой функции можно задать фильтр – условие, которому должны соответствовать все найденные записи. Поскольку мы фильтр не задавали, система возвращала нам сразу все записи.</p><p>Часто бывает, что в коллекции нужно найти только одну запись – как в нашем случае. Конечно, можно использовать обычный <code>find()</code>, и взять первый элемент из найденного массива.</p><p>Но если база будет \"знать\", что мы ищем только одну запись, она найдет ее гораздо быстрее. Поэтому для таких случаев в коллекции есть специальная функция <code>findOne()</code>. Она возвращает промис, который вернет либо найденную запись, либо пустой объект <code>null</code>, если с данным фильтром записей найти не удалось.</p><h2>Фильтр для <code>find</code> и <code>findOne</code></h2><p>В качестве фильтра в <code>MongoDB</code> используется обычный <code>javascript</code>-объект. Считается, что документ в коллекции соответствует этому фильтру, если имеет все атрибуты, перечисленные в фильтре.</p><p>Предположим, у нас есть три объекта</p><pre><code class=\"language-json\">[\n  {\n    title: \"product-1\",\n    key: 100,\n    category: \"powerbank\",\n    price: 1000\n  },\n  {\n    title: \"product-2\",\n    key: 105,\n    category: \"powerbank\",\n    price: 1500\n  },\n  {\n    title: \"product-3\",\n    key: 112,\n    category: \"cellphone\",\n    price: 5000\n  }\n]</code></pre><p>Фильтру <code>{ category: \"powerbank\" }</code> будут соответствовать первые два. Фильтру <code>{ key: 112 }</code> будет соответствовать третий из них. Фильтрам <code>{ key: 500 }</code> или <code>{ anotherKey: 500 }</code> не будет соответствовать ни один объект.</p><blockquote><p>Фильтры могут быть устроены гораздо сложнее. Например, можно задать фильтр для поиска всех записей, у которых цена меньше 2000: <code>{ price: { \"$lt\": 2000 } }</code>. Полностью  синтаксис фильтров описан в официальной документации по <code>MongoDB</code>: <a href=\"https://docs.mongodb.com/manual/reference/operator/query/\">https://docs.mongodb.com/manual/reference/operator/query/</a></p></blockquote><p>Обратите внимание, что в <code>MongoDB</code> синтаксис фильтра чувствителен к типу данных. Например, фильтру <code>{ key: \"112\" }</code> не будет соответствовать ни один объект – поскольку в фильтре для поля <code>key</code> задано строковое значение, а в базе хранится числовое значение. Это очень важный для нас момент – поскольку при добавлении записей в базу данных мы добавляли числовые значения <code>key</code>, а из строки URL извлекаем строковый вариант. При поиске нужно будет предварительно перевести полученное из строки URL строковое значение в число с помощью функции <code>Number()</code></p><h2>Задание</h2><p>Доработайте функции <code>serveProduct</code> и <code>ProductService.getProductByKey</code> так, чтобы они работали с базой данных. В итоге страница товара должна полноценно работать.</p>",
      "tKey": 6
    },
    {
      "name": "Обработка ошибки 404",
      "html": "<p>Мы уже делали обработку ошибки \"Page not found\". Когда запрошенный URL не соответствует ни одному из обрабатываемых нами маршрутов, мы выдавали пустую страницу со статусом 404, указанным в заголовке, и простым текстом Not Found.</p><p>Однако, теперь пользователь может ввести URL, по нашей логике соответствующий странице товара (т.е. начинающийся с <code>/product/</code>), однако содержащий неверный код товара. Эта страница тоже должна выдаваться пользователю со статусом 404 – однако, сейчас она будет обработана функцией <code>serveProduct</code>.</p><h2>Почему важно правильно обрабатывать ошибку 404</h2><p>Самая главная причина для тщательной обработки ошибки 404 – это поисковая оптимизация. </p><p>Давайте представим, что у нас сайт из 100 полезных страниц с товарами. На всех есть хороший контент с описанием, который не дублируется на остальных страницах сайта. Поисковику нравится такие страницы, поэтому он охотно включает их в свою базу данных и выдает пользователям при поиске. Магазин работает и приносит деньги.</p><p>Однако, на любом сайте есть неограниченное количество URL, для которых нет соответствующей страницы. Любая абракадабра, которую введет пользователь после доменного имени – с точки зрения браузера и поисковика – нормальный полноценный URL. Если мы будем выдавать по таким адресам нормальный контент со <code>statusCode</code> равным 200, то поисковик будет считать их полноценными страницами. </p><p>То есть, если в интернете где-то появятся ссылки на миллион адресов вашего сайта с несуществующими URL, то поисковик их проиндексирует (т.е. возьмет себе в базу), и картинка вашего сайта в восприятии поисковика кардинально изменится. Вместо 100 полноценных уникальных страниц он увидит 1000100 страниц, из которых подавляющая часть имеет одинаковый контент. </p><p>Эта ситуация – катастрофическая. Приоритет ваших полезных URL на сайте понизится – он будет размыт миллионом бесполезных URL. Они могут попадать в поисковую выдачу, отнимая место у нормальных страниц. Когда вы захотите обновить контент на ваших страницах, поисковик не будет успевать включить их в базу – вместо этого он будет занят повторным обходом миллиона других страниц и проверкой, не изменилась ли информация на них. И, наконец, поисковик может посчитать миллион одинаковых страниц на вашем сайте поисковым спамом – и вообще заблокировать ваш сайт.</p><p>Поэтому на всех несуществующих страницах важно отдавать в качестве статуса 404. Поисковик понимает, что это значит, и просто не включает такие страницы в свою базу.</p><h2>Значение для пользователя</h2><p>Помимо выдачи статуса 404 для поисковых роботов, есть еще одно важное значение – удобство пользователя. Пользователь может попасть на несуществующую страницу по ошибке – перепечатав откуда-нибудь URL и ошибившись в паре символов. Наша задача – объяснить ему, что случилось, и уговорить продолжить навигацию по сайту. </p><p>Сейчас наша 404 страница выглядит как техническая ошибка. Увидя ее, пользователь закроет вкладку и продолжит поиск товара на других, более дружественных сайтах.</p><p>Давайте исправим эту ситуацию.</p><h2>Задание</h2><p>Если пользователь ошибается в коде товара (например, вводит URL <code>/product/3000-some-wrong-product/</code>) – выдать ему 404 страницу. Страница должна содержать нормальную шапку и футер, а также текст \"Введенный вами товар не найден\". Также нужно переделать обработку обычной 404-страницы, не имеющей отношения к товару (например, <code>/some-wrong-url</code>). Страница тоже должна содержать шапку и футер, но другое сообщение \"Введенная вами страница на сайте не обнаружена.\"</p><h3>Требования и подсказки</h3><p>Добавьте в вашу функцию <code>serveNotFound</code> третий, необязательный параметр <code>customText</code>. Если он задан – функция должна вывести его в качестве сообщения. Если он не задан – функция выводит стандартное сообщение.</p><p>Теперь вызов <code>serveNotFound</code> в конце функции-роутера мы можем оставить без изменений. Просто не указан третий параметр, и выведется обычное сообщение. А вот вызывать ее из <code>serveProduct</code> мы будем с третьим параметром – найденным сообщением про не найденный товар.</p><p>Напомним, что функция <code>ProductService.getProductByKey</code> возвращает промис, который при исполнении выдаст нам нужный товар – или <code>null</code>, если товар не найден. Все, что нам нужно – проверить возвращенный результат на равенство <code>null</code> и в этом случае вызвать <code>serveNotFound</code></p><pre><code class=\"language-javascript\">if (product === null) {\n  serveNotFound(req, res, \"some message...\");\n}</code></pre><p>Или, еще короче – </p><pre><code class=\"language-javascript\">if (!product) {\n  serveNotFound(req, res, \"some message...\");\n}</code></pre><h3>Дополнительно</h3><p>Тщательно изучите работу сравнения и логических операторов в Javascript.\n<a href=\"https://learn.javascript.ru/comparison\">https://learn.javascript.ru/comparison</a></p><p>Также, понадобится разобраться со смыслом оператора инверсии (оператора \"НЕ\"), представленного в JavaScript восклицательным знаком <a href=\"https://learn.javascript.ru/logical-ops\">https://learn.javascript.ru/logical-ops</a></p>",
      "tKey": 7
    },
    {
      "name": "Перенаправление (Redirect)",
      "html": "<p>Давайте рассмотрим повнимательнее логику работы нашей функции <code>serveProduct</code>. Мы вырезаем из кусочка URL только номер до первого дефиса – и используем его для поиска товара. Об оставшейся части URL, в которой хранится <code>slug</code> (латинизированное название для отображения в URL) товара, мы просто никак не заботимся.</p><p>Это означает, что пользователь может вводить любую абракадабру после первого дефиса – мы все равно отобразим на странице нужный товар. С точки зрения поисковой оптимизации, это почти настолько же плохо, как необработанные 404 страницы. Наш конкурент может разместить на каком-нибудь левом сайте (с отрицательным уровнем доверия поисковых систем) миллион разных ссылок на один наш товар. </p><p>Поисковик их проиндексирует, и начнет воспринимать наш сайт как хранилище миллиона одинаковых страниц с разными URL, на которые мы пытаемся загнать трафик с сомнительных ресурсов – после чего, скорее всего, понизит нас в поисковой выдаче.</p><p>Как обрабатывать эту ситуацию? Первое, что приходит в голову – выдавать на таких страницах 404. То есть, в <code>serveProduct</code> мы получаем продукт и сравниваем его <code>slug</code> с оставшейся частью URL. Если они не совпадают, то вызываем наш обработчик 404. Если совпадают – продолжаем нормальную обработку.</p><p>Решение рабочее, но с существенными недостатками. Представьте себе, что мы захотели изменить <code>slug</code> у какого-то товара, чтобы сделать его немножко понятнее. Но какой-то пользователь сохранил старую ссылку на товар день назад, а теперь возвращается, чтобы его купить. Или ввел ссылку вручную, ошибившись в паре символов – при чем не в коде, а именно в <code>slug</code>, никак не используемом для поиска. </p><p>Было бы крайне обидно терять таких пользователей и показывать им 404. Несмотря на всю вежливость сообщения, мы делаем им неудобно и есть вероятность, что после получения 404 они все-таки уйдут.</p><p>К счастью, для таких ситуаций протокол HTTP предоставляет нам удобное решение – перенаправление браузера на другую страницу, или редирект (Redirect). Поскольку мы в данный момент времени знаем и код товара, и его правильный <code>slug</code> – мы можем сформировать правильный URL для перехода. И тогда выдать в браузер не страницу, а специальную команду для перехода на этот URL.</p><blockquote><p>Когда поисковая система встречает редирект, она не индексирует данную страницу и не забивает собственные сведения о вашем сайте бесполезной информацией</p></blockquote><p>Механизм редиректа описан в статье <a href=\"https://developer.mozilla.org/ru/docs/Web/HTTP/Redirections\">https://developer.mozilla.org/ru/docs/Web/HTTP/Redirections</a></p><p>Чтобы выдать в браузер команду немедленного перехода на другой URL, нам нужно сделать две вещи:\n1. Выдать код ответа (statusCode) 301\n1. Записать в заголовок ответа поле <code>Location</code> со значением, равным новому URL.</p><p>Новый URL может быть как абсолютный, так и относительный – если вы хотите перенаправить браузер на тот же домен.</p><p>Примеры:</p><pre><code class=\"language-javascript\">res.setHeader(\"Location\", \"http://hutorium.ru\");\nres.setHeader(\"Location\", \"/about\");</code></pre><h2>Задание</h2><p>Сделайте редирект со страниц товаров, где корректно указан код товара, но в слаге допущена ошибка.</p><h3>Подсказки</h3><p>В рамках этой задачи нам потребуется извлечь <code>slug</code> из пришедшего URL.</p><p>Пока мы извлекали из него только ключ товара <code>key</code>, примерно таким способом:</p><pre><code class=\"language-javascript\">  const urlParsed = URL.parse(req.url);\n  const slugPart = urlParsed.pathname.replace(\"/product/\", \"\");\n  const slugParts = slugPart.split(\"-\");\n  const key = slugParts[0];</code></pre><p>Очевидно, что переменная <code>slugPart</code> состоит из двух частей – ключа <code>key</code> и непосредственно слага <code>slug</code>. Между ними стоит дефис. Значит, самый простой способ получить <code>slug</code> – вырезать из строки <code>slugPart</code> несколько первых символов. Их количество будет равно длине строке <code>key</code>, увеличенной на 1 (чтобы учесть дефис).</p><p>То есть, если <code>slugPart</code> будет содержать значение <code>31218-my-cool-product</code>, то из нее нужно вырезать первые 6 символов (длина строки \"31218\" = 5, увеличенная на 1).</p><p>Для этого удобно использовать метод <code>slice</code> <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/slice\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/slice</a>, не передавая ему второй аргумент.</p><pre><code>const slug = slugPart.slice(key.length + 1);</code></pre><p>Другая альтернатива (можете сделать самостоятельно) – удалить из массива <code>slugParts</code> первый элемент, и склеить остальные элементы массива в строку с помощью функции <code>join</code> с разделителем \"-\". Подробнее <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/join\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/join</a></p><p>Кроме того, нам понадобится формировать правильный URL для редиректа. Эта строка будет состоять из нескольких кусочков – статичных строк (например, \"/product\") и переменных (например, <code>key</code>, <code>slug</code>).</p><p>Для их соединения  в одну большую строку раньше использовали оператор сложения строк <code>+</code>:</p><pre><code>const key = \"2037\";\nconst productName = \"my-cool-product\";\nconst bigString = \"/static/\" + key + \"-\" + productName;</code></pre><p>Однако, сейчас такой подход устарел и считается плохой практикой. Вместо него используется механизм <code>template literals</code>, появившийся в одной из последних версий javascript. Строка в этом случае заключается в специальные кавычки-апострофы, внутри прописываются все статические части, а динамические части – переменные или целые выражения – прописываются внутри специальных структур <code>${}</code>.</p><pre><code>const key = \"2037\";\nconst productName = \"my-cool-product\";\nconst bigString = `/static/${key}-${productName}`;</code></pre><p>Подробгнее об использовании template literals: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals</a></p>",
      "tKey": 8
    }
  ]
},{
  "_id": {
    "$oid": "5c03fac906316ed0602c61f3"
  },
  "name": "Single Page Applications",
  "html": "<p>В прошлом юните мы изучали создание динамических веб-страниц.</p><p>Напомним, главный недостаток этой стратегии – сложность реализации интерактивных компонентов на странице. Нам приходится держать код, относящийся к компонентам страницы, в двух разных местах – шаблон страницы на сервер-сайде, и логику изменения внешнего вида компонентов (например, javascript-код для переключения вкладок) на клиент-сайде.</p><p>Когда компонент в процессе развития проекта надо будет менять – любое изменение в шаблоне могут ломать логику на клиент-сайде, который полагался на старую верстку. Это очень неудобно и, фактически, делает разработку вдвое дороже.</p><p>В этом юните мы изучим стратегию SPA - Single Page Applications. В этом подходе на любой запрос сервер возвращает одну и ту же статическую страницу без какого-либо значимого HTML. Весь роутинг и отрисовка динамического содержимого происходит на клиент-сайде, чаще всего с помощью React.</p>",
  "uKey": 7,
  "tasks": [
    {
      "name": "Настройка Webpack",
      "html": "<p>С языком JSX, который мы использовали, есть небольшая проблема. Дело в том, что современные браузеры \"понимают\" только язык Javascript, который является официальным стандартом, принятым общественной организацией World Wide Web Consortium (<a href=\"https://www.w3.org/\">https://www.w3.org/</a>).</p><p>Различные расширения языка Javascript (jsx, CoffeeScript, TypeScript и т.п.) разработаны частными компаниями, и в стандарт не включены. Поэтому, чтобы заставить наш jsx-код работать, мы должны его предварительно перевести, т.е. \"транслировать\" в стандартный Javascript.</p><p>JSFiddle, которым мы пользовались, делал это за нас. Сейчас, когда мы делаем свой собственный сервер, нам нужно позаботиться об этой трансляции самостоятельно.</p><p>То есть, у нас должно быть две версии нашего кода:</p><ol><li>Исходные файлы (исходники) – в которых код написан на нужных нам языках в удобном для нас виде. Мы будем хранить их в папке <code>static</code>.</li><li>Публичные файлы – файлы, которые получились в результате трансляции исходников. Они удобны не для нас, а для использования браузером. Мы будем хранить их в папке <code>public</code>.</li></ol><p>Естественно, в нашей функции <code>serveStatic</code> мы теперь будем брать файлы из папки <code>public</code>, где хранится версия, удобная для браузера.</p><p>То есть, нам нужно создать какой-то инструмент, чтобы содержимое из папки <code>static</code> по определенным правилам копировалось в папку <code>public</code>. Файлы, которые не требуют изменения (например, картинки или css), будут просто копироваться. Файлы, которые требуют изменения (например, jsx), будут одновременно транслироваться и попадать в <code>public</code> уже в преобразованном виде.</p><p>Этот процесс называется сборкой (bundling). В настоящее время стандартом де-факто для сборки клиентских файлов стал инструмент <em>webpack</em> <a href=\"https://webpack.js.org/\">https://webpack.js.org/</a></p><p>В рамках текущего задания мы сделаем на webpack простое копирование статических файлов, без их трансляции.</p><h2>Установка webpack и необходимых компонентов</h2><p>Давайте установим webpack в наш проект:</p><pre><code class=\"language-shell\">npm install webpack --save</code></pre><p>Webpack – это универсальный инструмент, он позволяет делать сборку любой сложности для очень разных задач. Поэтому весь функционал в нем вынесен в специальные подключаемые модули – плагины, которые нужно устанавливать дополнительно.</p><p>Давайте установим два необходимых нам плагина – для копирования файлов и очистки папки.</p><pre><code class=\"language-shell\">npm install copy-webpack-plugin --save\nnpm install clean-webpack-plugin --save</code></pre><p>Кроме того, нам понадобится еще один модуль, необходимый для запуска webpack из командной строки:</p><pre><code class=\"language-shell\">npm install webpack-cli  --save</code></pre><h2>Настройка package.json</h2><p>Мы уже имели дело с файлом <code>package.json</code>, хранящимся в корневой папке нашего проекта. Напомним – в нем хранится список всех npm-модулей, которые мы устанавливали с помощью npm install &lt;имя модуля&gt;  --save. </p><p>Кроме списка модулей, в этом файле можно хранить различные <em>скрипты</em> – специальные команды для запуска приложения в различных режимах. Давайте создадим в нем скрипт <code>build</code> для запуска нашей сборки.</p><p>Файл <code>package.json</code> должен строго соответствовать формату JSON. JSON (JavaScript Object Notation) – это обычный синтаксис записи javascript- объектов с двумя небольшими отличиями.</p><ol><li>Все названия ключей должны быть в кавычках. В обычном js это требование необязательно. Вы можете написать просто <code>{ someKey: \"someValue\"}</code> – с точки зрения js запись корректна, а с точки зрения JSON – нет. Корректным вариантом с точки зрения JSOn будет <code>{ \"someKey\": \"someValue\"}</code></li><li>Нельзя оставлять завершающую запятую (trailing comma) после последнего элемента объекта. Например, для JS будет являться корректной запись <code>{ a: 10, b: 20, }</code>, но с точки зрения JSON – она ошибочна. Правильный вариант – <code>{ a: 10, b: 20 }</code></li></ol><p>До этого все изменения <code>package.json</code> были автоматическими – он модифицировался каждый раз, когда мы устанавливали модуль. Теперь мы собираемся редактировать его вручную и крайне важно строго соблюдать правила формата JSON.\nЕсли вы допустите малейшие неточности или отклонения при ручном редактировании <code>package.json</code>, все последующие попытки установить модуль или запустить команду из этого файла – будут приводить к ошибке.</p><p>Давайте добавим в <code>package.json</code> команду для запуска нашей сборки:</p><pre><code class=\"language-json\">{\n  ...\n  \"scripts\": {\n    ...\n    \"build\": \"./node_modules/.bin/webpack --config ./webpack.js\"\n  }\n}</code></pre><p>Теперь, если мы выполним в командной строке удобную простую команду <code>npm run build</code>, фактически будет выполнена длинная и сложная команда, запускающая Linux-программу webpack с определенными параметрами:</p><pre><code>./node_modules/.bin/webpack --config ./webpack.js</code></pre><p>В данный момент мы передаем вебпаку только один параметр – путь к конфигурационному файлу, в котором мы должны настроить все желаемое поведение.</p><p>У нас этого файла пока нет – создайте его самостоятельно в корневой папке вашего проекта (на одном уровне с <code>package.json</code>).</p><p>Файл должен представлять собой обычный node-модуль, наподобие нашего ProductService.js. Webpack ожидает, что в module.exports этого модуля будет записан объект с конфигурационной информацией.</p><p>Давайте создадим этот объект с минимальной информацией для webpack:</p><pre><code class=\"language-javascript\">module.exports = {\n    mode: \"development\",\n    entry: \"./static/app.jsx\", \n    output: {\n        path: path.resolve(__dirname, \"public\")\n    }\n}</code></pre><p>Давайте рассмотрим все поля этого объекта подробнее:</p><ol><li>mode – режим запуска сборки. Обычно создают два режима, называемые \"production\" и \"development\". Первый режим конфигурируют так, чтобы получившиеся файлы были максимально эффективны для \"боевого\" режима работы – например, добавляют сжатие файлов и другую оптимизацию. Development режим используется в режиме разработки – когда наибольшее значение имеет удобство работы программиста. Файлы не сжимаются, в них может добавляться дополнительная отладочная информация, оптимизируется скорость сборки в ущерб качеству – чтобы не заставлять программиста долго ждать после каждого изменения. Мы пока будем работать с режимом \"development\".</li><li>entry – точка входа в приложение. Это javascript-файл, который вебпак будет считать главным для клиентской части приложения (\"точка входа\"). Несмотря на то, что в данный момент он нам не нужен, вебпак будет ругаться, если мы его не укажем. Поэтому нужно создать в папке <code>static</code> файл <code>app.jsx</code> (можно пустой), и обязательно указать в конфиге путь к нему.</li><li>output – тут должен быть объект, который подскажет вебпаку, куда складывать готовые файлы. Обычно у этого объекта бывает два атрибута. Это путь к папке, предназначенной для готовых файлов – <code>path</code>, и <code>filename</code>, указывающий, как вебпаку назвать файл с готовой точкой входа. Мы пока задаем только <code>path</code>, т.к. с точкой входа на этом этапе не работаем. Вебпак требует, чтобы в path задавался абсолютный путь, поэтому мы получаем его с помощью функции <code>resolve</code> уже известного нам  модуля <code>path</code>.</li></ol><p>теперь давайте запустим нашу сборку и убедимся, что вебпак не выдает никаких ошибок:</p><pre><code>npm run build</code></pre><p>Конечно, наша сборка в данный момент ничего не делает – т.к. мы не указали вебпаку, что именно нужно делать. Наша задача в данный момент – добиться отсутствия ошибок. Если webpack в терминал пишет ошибки красным цветом – перепроверьте все ваши действия и самостоятельно устраните их. </p><h2>Настройка копирования</h2><p>Добавьте в конфигурационный объект webpack следующий блок:</p><pre><code>  plugins: [\n        new CleanWebpackPlugin([\"public\"]),\n        new CopyWebpackPlugin([\n            {\n                from: \"static\",\n                to: \"\"\n            }\n        ]),\n    ]</code></pre><p>Мы подключаем к вебпаку два плагина. Первый – CleanWebpackPlugin – служит для очистки директории public от результатов предыдущих сборок. Второй – занимается копированием всех файлов из папки <code>static</code> в папку <code>public</code>.</p><p>Каждый плагин представляет собой обычный js-класс. Мы создаем инстансы этих классов, используя оператор <code>new</code> и передавая им в конструктор соответствующие настройки.</p><p>Как именно должны быть устроены их настройки – можно почитать на официальных страницах этих плагинов: <a href=\"https://www.npmjs.com/package/copy-webpack-plugin\">https://www.npmjs.com/package/copy-webpack-plugin</a> и <a href=\"https://www.npmjs.com/package/clean-webpack-plugin\">https://www.npmjs.com/package/clean-webpack-plugin</a></p><blockquote><p>Почему для CopyWebpackPlugin в качестве параметра <code>to</code> мы указываем пустую папку, а не <code>public</code>? Дело в том, что CopyWebpackPlugin считает путь, заданный в параметре <code>to</code> не абсолютным, а относительным. То есть, он прибавляется к параметру <code>path</code> в объекте <code>output</code>, заданным в конфиге для webpack. У нас этот параметр <code>path</code> как раз и содержит папку <code>public</code>.</p></blockquote><p>Естественно, переменные <code>path</code>, <code>CleanWebpackPlugin</code> и <code>CopyWebpackPlugin</code>, которые мы используем в конфиге – пока еще не заданы. Мы должны предварительно записать в них значения обычным образом через <code>require</code> соответствующих модулей:</p><p>const CleanWebpackPlugin = require(\"clean-webpack-plugin\");\nconst CopyWebpackPlugin = require(\"copy-webpack-plugin\");\nconst path = require(\"path\");</p><h2>Задание</h2><p>Настройте webpack в соответствии с инструкциями и переделайте вашу функцию <code>serveStatic</code> так, чтобы она брала файлы из папки <code>public</code>, а не <code>static</code>.</p><h3>Подсказки</h3><h4>Не создавайте папку public вручную!</h4><p>Если мы создадим папку <code>public</code> вручную, есть вероятность, что webpack не сможет сам скопировать туда файлы и очищать ее. Это связано с настройками Cloud9 и системой прав в операционной системе Linux, которой мы пользуемся. </p><p>Изучение системы прав в Linux не входит в наш курс, но для дальнейшего развития в сторону server-side разработчика вам понадобится полное понимание – поэтому рекомендуется изучить ее самостоятельно <a href=\"http://www.linuxcenter.ru/lib/books/kostromin/gl_04_05.phtml\">http://www.linuxcenter.ru/lib/books/kostromin/gl_04_05.phtml</a></p><p>Для выполнения данного задания достаточно просто не создавать папку public вручную. При запуске нашего скрипта webpack создаст ее самостоятельно.</p>",
      "tKey": 1
    },
    {
      "name": "Трансляция jsx",
      "html": "<p>Теперь давайте настроим webpack на трансляцию jsx, чтобы мы могли использовать React в нашем приложении. </p><p>Для начала, нам потребуется установить необходимые плагины (точнее, <em>лоадеры</em> – специальные инструменты для трансляции включаемых файлов). Общепринятым набором инструментов для трансляции любых версий и диалектов javascript является Babel – <a href=\"https://babeljs.io/\">https://babeljs.io/</a>. Конечно, он включает в себя вариант реализации для webpack, и инструменты для трансляции jsx. </p><pre><code>npm install babel-core --save\nnpm install babel-loader --save\nnpm install babel-preset-react --save</code></pre><p>Как мы уже видели в прошлом задании, одним из ключевых понятий webpack является <code>entry</code> – \"точка входа\" в приложение. Это главный javascript-файл, в который webpack будет включать всю логику работы клиентского приложения. Мы указывали в конфиге webpack, в поле <code>entry</code> файл <code>app.jsx</code> в качестве точки входа.</p><p>Теперь давайте определим правила сборки, которые будут действовать для нашей точки входа (а затем и всех других включаемых в нее файлов).</p><p>Пропишите в конфиге webpack следующий блок </p><pre><code>  module: {\n    rules: [\n      {\n        test: /\\.jsx$/,\n        exclude: /node_modules/,\n        use: {\n          loader: \"babel-loader\",\n          options: {\n            presets: [\"babel-preset-react\"]\n          }\n        }\n      }\n    ]\n  },</code></pre><p>Давайте подробно разберем, что здесь происходит. Все настройки, касающиеся включаемых в точку входа файлов, хранятся в объекте с ключом <code>module</code>. У него есть главное свойство <code>rules</code> – массив правил, которые будут применяться к включаемым файлам. Нам пока необходимо только одно правило – которое перед включением файлов jsx будет транслировать их в обычный js.</p><p>Правило представляет собой объект с тремя ключами:</p><ol><li><code>test</code> – здесь указывается, к каким именно файлам должно применяться данное правило. Чаще всего это делают в виде <em>регулярного выражения</em> (RegExp) – специального паттерна, которому должно соответствовать имя файла. Если включаемый файл соответствует регулярному выражению, правило будет применено. В данном случае мы задаем регулярное выражение, которому будут соответствовать все файлы с расширением jsx.<blockquote><p>Мы уже сталкивались с регулярными выражениями, это тема для отдельного самостоятельного изучения <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp</a></p></blockquote></li><li><code>exclude</code> – необязательный параметр, в нем можно указать исключения из правила – то есть файлы, к которым не нужно применять данную логику, даже если они соответствуют паттерну в свойстве <code>test</code>. В <code>exclude</code> тоже задается регулярное выражение. В нашем случае мы исключаем все файлы, полный путь к которым содержит строку <code>node_modules</code>. То есть, все файлы из подключаемых библиотек не будут транслироваться.</li><li><code>use</code> – непосредственное описание применяемого правила. Обычно содержит объект из двух ключей – <code>loader</code> и <code>options</code>. В <code>loader</code> указывается webpack-инструмент, который будет отвечать за трансляцию данного файла. В нашем случае это, конечно, <code>babel-loader</code>, который мы установили чуть раньше. В <code>options</code> указываются настройки для лоадера. Каждый лоадер имеет свой формат настроек, которые описаны в документации к нему. Наш <code>babel-loader</code> требует, чтобы в его опциях, в поле <code>presets</code> был указан массив <em>пресетов</em> – наборов babel для компиляции различных диалектов JS. Нам нужен только <code>babel-preset-react</code>, который занимается компиляцией jsx.</li></ol><h3>Другие доработки конфига <code>webpack</code></h3><p>Нам нужно сделать еще пару мелких доработок. </p><p>Во-первых, нужно указать итоговое имя файла, в котором будет находиться подготовленная webpack точка входа. Если его не указать, webpack будет использовать исходное название – <code>app.jsx</code>. В этом нет ничего страшного, но общепринятой практикой является называть подготовленный файл <code>bundle.js</code>.</p><pre><code>  entry: \"./static/app.jsx\",\n  output: {\n    filename: \"bundle.js\",\n    path: path.resolve(__dirname, \"public\")\n  },</code></pre><p>Теперь, весь наш код из <code>app.jax</code> (и в будущем – из подключаемых к нему файлов) будет транслироваться и попадать в <code>bundle.js</code> в виде чистого javascript-кода. Запустите <code>npm run build</code>, откройте <code>public/bundle.js</code> и изучите его содержимое.</p><p>Во-вторых, нам нужно исключить все исходные jsx-файлы из копирования в папку /public. Они никак не будут использоваться – все их содержимое будет записано внутрь файла bundle.js. Для этого нам нужно донастроить CopyWebpackPlugin, добавив в передаваемый ему объект одну опцию для исключения ненужных файлов:</p><pre><code class=\"language-json\">  ignore: [\n    \"*.jsx\"\n  ]</code></pre><p>Подробная документация по настройке <code>copy-webpack-plugin</code> и опции <code>ignore</code>: <a href=\"https://webpack.js.org/plugins/copy-webpack-plugin/#ignore\">https://webpack.js.org/plugins/copy-webpack-plugin/#ignore</a></p><h2>Перенастройка роутинга на SPA</h2><p>Напомним, в соответствии с концепцией SPA на все запросы страниц в браузер должен выдаваться одинаковый HTML - и на запрос главной страницы, и на запрос страницы конкретного товара.</p><p>Подготовьте стандартный HTML, который мы использовали для работы с React в 4 юните и назовите его <code>spa.html</code>. Переделайте ваш роутинг так, чтобы на все запросы HTML--страниц (в т.ч. главную) вызывалась функция <code>serveSPA</code>, которая выдает в <code>response</code> содержимое этого файла.</p><p>Не забудьте подключить в этот файл <code>&lt;link&gt;</code> на наш CSS. Кроме того, в самом конце <code>spa.html</code> нам понадобится подключить наш <code>bundle.js</code>:</p><pre><code>&lt;script src=\"/bundle.js\"&gt;&lt;/script&gt;</code></pre><p>Очень важно вставить его после тега <code>&lt;div id=\"target\"&gt;&lt;/div&gt;</code> – иначе, на момент выполнения React-кода наш таргет будет еще не готов, и React не сможет правильно отобразить контент.</p><h2>Задание</h2><p>Перенесите jsx-код из вашего задания <a href=\"http://hutorium.ru/student/unit/4/7\">http://hutorium.ru/student/unit/4/7</a> в файл app.jsx и сделайте, чтобы он отображался на главной странице. </p><h3>Подсказки и требования</h3><p>Наш транслятор переводит синтаксис <code>jsx</code> в обычные объекты и классы, понятные простому  javascript. Однако, логику, которая умеет отображать эти компоненты, мы еще не подключили. Как и все другие библиотеки в JS – она находится в модулях NPM, которые нужно предварительно установить, а затем подключить в файле, в котором они используются.</p><p>Установка делается обычным способом:</p><pre><code>npm install react --save\nnpm install react-dom --save</code></pre><p>А вот подключение – не совсем обычным. Вместо функции <code>reauire</code> мы на этот раз будем использовать директиву <code>import</code>. Она появилась в JS относительно недавно и отличается тем, что умеет подключать только необходимые компоненты из нужных библиотек. </p><pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom\";</code></pre>",
      "tKey": 2
    },
    {
      "name": "Разделение клиентского кода на модули",
      "html": "<p>Перед тем, как развивать client-side нашего приложения, нам нужно научиться делить его на модули и подключать их в нужных местах – иначе наш <code>app.jsx</code> очень быстро разрастется до размеров, когда его будет сложно читать и модифицировать.</p><p>Мы уже имели дело с разделением кода на серверной стороне с помощью механизма <code>module.exports/require</code>, когда выносили наш <code>ProductService.js</code> из основного файла. Сейчас нам нужно научиться делать то же самое для клиентской части – только с помощью нового механизма <code>import/export</code>. Мы уже коснулись его в прошлом задании, когда подключали React.</p><p>Давайте создадим внутри нашей папки <code>static</code> еще одну и назовем ее <code>components</code>. Здесь мы будем хранить наши готовые компоненты, которые сможем многократно переиспользовать на других страницах.</p><p>Теперь – создадим в ней файл <code>ProductBox.jsx</code> и перенесем в него класс <code>ProductBox</code>: </p><pre><code class=\"language-javascript\">import React from \"react\";\n\nclass ProductBox extends React.Component {\n  render() {\n    return &lt;div className=\"product\"&gt;\n      &lt;h1&gt;{ this.props.title }&lt;/h1&gt;\n      { this.props.children }\n    &lt;/div&gt;;\n  }\n}\n\nexport default ProductBox;</code></pre><p>Поскольку в модуле мы используем класс <code>React.Component</code>, нужно подключить модуль React в самом верху файла.</p><p>Далее, нам нужно \"экспортировать\" заданный класс из этого файла, чтобы в остальных файлах можно было его использовать. Это делается директивой <code>export default</code>. Мы сделали отдельной строкой, но экспортировать класс можно сразу же при его объявлении, вот так:</p><pre><code class=\"language-javascript\">export default class ProductBox extends React.Component {\n  ...\n}</code></pre><p>Теперь этот модуль можно подключить в нашем <code>app.jsx</code> с помощью <code>import</code>. Обратите внимание, что нам нужно будет указывать путь к подключаемому файлу относительно той папки, в которой находится использующий файл:</p><pre><code class=\"language-javascript\">import ProductBox from \"./components/ProductBox.jsx\";</code></pre><p>Теперь внутри <code>app.jsx</code> можно использовать класс <code>ProductBox</code>. Не забудьте убедиться, что вы удалили из <code>app.jsx</code> его первоначальное определение.</p><h2>Задание</h2><p>Вынесите все классы в отдельные файлы. Саму страницу – тоже вынесите в отдельный файл <code>ProductPage.jsx</code>. Создайте папку <code>pages</code> на одном уровне с <code>components</code> и поместите туда этот файл. Теперь все jsx-файлы страниц будем держать в этой папке.</p><p>То есть, определение класса App должно выглядеть просто как:</p><pre><code>class App extends React.Component {\n  render() {\n    return &lt;ProductPage&gt;&lt;/ProductPage&gt;;\n  }\n}</code></pre><p>В итоге у вас должны получиться следующие файлы:</p><ol><li><code>app.jsx</code></li><li><code>pages/ProductPage.jsx</code></li><li><code>components/ProductBox.jsx</code></li><li><code>components/Navigation.jsx</code></li></ol><blockquote><p>Обратите внимание – функция render обязана возвращать ровно один jsx-тег. Конечно, внутри у него может быть сложная структура из других тегов, но на верхнем уровне тег должен быть один. Что делать, если вам нужно вернуть верстку из нескольких тегов, находящихся на одном уровне? Например, при выдаче страницы <code>ProductPage</code> хотелось бы вернуть три тега – <code>&lt;header&gt;</code>, <code>&lt;main&gt;</code> и <code>&lt;footer&gt;</code>. Конечно, можно просто обернуть их еще в один <code>&lt;div&gt;</code>, но это может повлиять на верстку. Специально для таких случаев в React есть специальный тег <code>&lt;React.Fragment&gt;</code>. Если вы \"завернете\" ваши теги не в <code>&lt;div&gt;</code>, а в <code>&lt;React.Fragment&gt;</code>, то при фактическом рендеринге эта обертка просто исчезнет, не создав дополнительный тег.</p></blockquote>",
      "tKey": 3
    },
    {
      "name": "React Router",
      "html": "<p>Напомним, концепции SPA предполагает, что рендерингом и роутингом страниц будет заниматься клиентская часть приложения. </p><p>Сервер в ответ на запрос любой страницы отвечает одинаково. На сервере, естественно, сохраняется определенный роутинг – для статики и каких-то других запросов. Но, как только сервер определяет, что в ответ нужно выдать HTML-страницу – он просто выдает стандартный одинаковый бланк. Вся дальнейшая работа происходит на клиенте.</p><p>Самый простой способ – сделать это вручную, примерно так же, как и на сервере. Javascript-код на клиенте может проанализировать URL, который в данный момент находится в адресной строке браузера (с помощью <code>window.location.href</code>), и в зависимости от этого URL выдать ту или иную страницу.</p><p>Но в случае, когда наше SPA-приложение написано на React, мы можем использовать очень удобный инструмент React Router. У него достаточно сложная для восприятия документация <a href=\"https://reacttraining.com/react-router/web/guides/philosophy\">https://reacttraining.com/react-router/web/guides/philosophy</a>. В дальнейшем с ней нужно будет разобраться, а сейчас давайте усвоим базовые концепции.</p><p>Сначала нужно установить необходимые библиотеки</p><pre><code class=\"language-shell\">npm install react-router-dom --save\nnpm install history --save</code></pre><p>Поскольку React Router (как и сам React) предназначен не только для использования в Web, но и для мобильных приложений – названия их библиотек для конкретной области отличаются суффиксами. В нашем случае мы устанавливаем <code>react-router-dom</code>. Суффикс DOM означает Document Object Model – это название программного интерфейса для HTML-документов, которым мы постоянно пользовались (<a href=\"https://developer.mozilla.org/ru/docs/DOM/DOM_Reference\">https://developer.mozilla.org/ru/docs/DOM/DOM_Reference</a>). Для простоты понимания можно считать, что аббревиатура DOM всегда имеет отношение к вебу.</p><p>Вторая библиотека, которую мы устанавливаем – это <code>history</code>. Как мы уже проговаривали, для любого роутинга на клиентской стороне будет необходим доступ к текущему URL браузера – но на практике все немного сложнее.</p><p>Современные браузеры предоставляют одну интересную возможность для веб-разработчиков. Мы можем с клиента принудительно изменить URL отображаемой в браузере страницы – и браузер при этом не полезет загружать ее с сервера. Если при этом мы еще и отобразим новый контент – для пользователя это будет выглядеть как мгновенная навигация, что очень удобно.</p><p>Весь этот функционал браузеров называется History API <a href=\"https://developer.mozilla.org/ru/docs/Web/API/History\">https://developer.mozilla.org/ru/docs/Web/API/History</a>. Он по-прежнему может не поддерживаться некоторыми старыми тупыми браузерами или браузерами на мобильных устройствах. К тому же, в некоторых браузерах это API реализовано немного по-разному. Поэтому мы используем еще одну библиотеку <code>history</code> – которая позволяет нам абстрагироваться от деталей реализации History API и добавляет немного удобного функционала (который мы пока не используем).</p><h2>Подключение React Router и <code>Switch</code></h2><p>Давайте разберем простой пример подключения React Router.</p><pre><code class=\"language-javascript\">import { Router, Route, Switch } from \"react-router-dom\";\nimport Page1 from \"./pages/page1.jsx\";\nimport Page2 from \"./pages/page2.jsx\";\nimport Page3 from \"./pages/page3.jsx\";\n\nimport { createBrowserHistory } from \"history\";\nconst history = createBrowserHistory();\n\nclass App extends React.Component {\n  render() {\n    return &lt;Router history={ history }&gt;\n      &lt;Switch&gt;\n        &lt;Route exact path=\"/\" component={ Page1 } /&gt;\n        &lt;Route exact path=\"/second-page\" component={ Page2 } /&gt;\n        &lt;Route exact path=\"/products/:product\" component={ Page3 } /&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;;\n  }\n}</code></pre><h3>Импорт</h3><p>Во-первых, стоит обратить внимание на блок импорта вверху. До этого момента казалось, что <code>import</code> работает точно так же, как и <code>require</code> и непонятно, зачем было делать что-то новое. Но в строке <code>import { Router, Route, Switch } from \"react-router-dom\";</code> мы уже используем новый синтаксис, который обладает значительным преимуществом и незаменим для клиентской сборки.</p><p>Откройте папку <code>node_modules</code> нашего проекта. Несмотря на скромный функционал нашего проекта, у нас уже подключены десятки зависимостей. Места на сервер-сайде достаточно, поэтому это не проблема. </p><p>Но если мы будем применять тот же подход на клиент-сайде, нам придется включать все подряд в bundle.js. Он вырастет до огромных размеров, и при загрузке каждой страницы пользователю придется ждать кучу времени, пока <code>bundle.js</code> скачается. Поэтому, у директивы <code>import</code> есть возможность подключать не весь функционал модуля, а только необходимые нам компоненты. В нашем случае из всего пакета <code>react-router</code> мы подключаем компоненты  <code>Router</code>, <code>Route</code> и <code>Switch</code>.</p><h3>Инициализация роутера</h3><p>В начале, нам нужно создать объект history, в котором есть все требуемые роутеру функции. Этим занимается функция <code>createBrowserHistory</code>, </p><pre><code>const history = createBrowserHistory(); </code></pre><p>Согласно концепции React Router, все приложение – точнее, те его части, которые зависят от URL и не одинаковы на разных страницах – должны находиться внутри корневого компонента <code>&lt;Router&gt;</code>. Он будет самостоятельно отслеживать все изменения внутри объекта-истории и в зависимости от условий отображать ту или иную страницу. </p><p>Естественно, этому корневому компоненту в качестве свойства нужно будет передать объект истории – чтобы он понимал, где именно отслеживать изменения.</p><pre><code>render() {\n  return &lt;Router history={ history }&gt;\n    ..\n  &lt;/Router&gt;\n}</code></pre><h3><code>Switch</code> и маршруты</h3><p>Самый простой способ сделать роутинг страниц – это использовать <code>Switch</code>. Внутрь компонента <code>Switch</code> нужно поместить компоненты <code>&lt;Route&gt;</code>, каждый из которых соответствует одной странице.</p><p><code>Switch</code> будет поочередно проверять все маршруты, пока не найдет такой, которому будет точно соответствовать. В этом случае он выведет компонент, указанный в маршруте, и прекратит дальнейший поиск.</p><p>Поэтому каждому маршруту нужно передать два обязательных свойства:</p><ol><li><code>path</code> – путь, при котором данный маршрут должен \"сработать\".</li><li><code>component</code> – компонент, который маршрут будет отображать при срабатывании.</li></ol><p>Как мы видим, у перечисленных маршрутов задается еще одно свойство – <code>exact</code>. Оно пустое, т.е. не задает какого-либо значения. Однако, сам факт его присутствия сообщает роутеру, что данный маршрут требует точного, а не частичного совпадения.</p><h3>Параметры в маршруте</h3><p>Давайте посмотрим повнимательнее на третий маршрут:</p><pre><code class=\"language-jsx\">&lt;Route exact path=\"/products/:product\" component={ Page3 } /&gt;</code></pre><p>Его путь содержит странный кусок, начинающийся с двоеточия. Это т.н. параметризация – крайне распространенная практика в любой системе роутинга.</p><p>Ее суть – описать одной строкой сразу несколько однотипных маршрутов, у которых отличается только один кусок. Этот способ незаменим, когда мы имеем множество однотипных страниц (например, страниц товаров в нашем магазине).</p><p>Важный момент – реальные значения, которые попадут в URL на место параметризованных кусочков можно будет легко получить изнутри компонента с помощью выражения <code>this.props.match.params</code>.</p><table><thead><tr><th>Паттерн</th><th>Реальный  URL</th><th>Сработал?</th><th><code>this.props.match.params</code></th></tr></thead><tbody><tr><td><code>/products/:product</code></td><td><code>/products/abc</code></td><td>Да</td><td><code>{ product: \"abc\" }</code></td></tr><tr><td><code>/products/:product</code></td><td><code>/products/123-abc</code></td><td>Да</td><td><code>{ product: \"123-abc\" }</code></td></tr><tr><td><code>/products/:product</code></td><td><code>/products123</code></td><td>Нет</td></tr><tr><td><code>/products/:product</code></td><td><code>/products/123/11</code></td><td>Нет</td><td>`</td></tr><tr><td><code>/products/:category/:product</code></td><td><code>/products/book/1731-title</code></td><td>Да</td><td><code>{ product: \"1731-title\", category: \"book\" }</code></td></tr></tbody></table><h2>Ссылки</h2><p>Мы разобрались с тем, как отобразить нужную страницу. Но с точки зрения браузера клики по ссылкам пока по-прежнему ведут на обычные страницы – то есть, при клике по ним браузер будет перезагружать страницу. В то время как нашей целью было сделать мгновенную навигацию без задержки на загрузку браузером новой страницы.</p><p>Для этого в React Router есть очень удобный компонент <code>&lt;Link&gt;</code>. Он полностью заменяет собой обычную ссылку <code>&lt;a&gt;</code>. Фактически, при рендеринге он и выводит эту ссылку – то есть, если вы откроете ее в новой вкладке, у нее будет точно такое же поведение.</p><p>Но если просто кликнуть по этой ссылке, React Router перехватит этот клик, запретит его дальнейшую обработку браузером (чтобы тот не пытался грузить страницу), и вместо этого вызовет обновление объекта-истории. В браузере сменится URL, компонент <code>&lt;Router&gt;</code> на него отреагирует, произведет рендеринг, и на странице отрисуется другой компонент – соответствующий новому URL.</p><p>Обратите внимание – в отличие от HTML-тега <code>&lt;a&gt;</code>, ссылка в <code>&lt;Link&gt;</code> задается не через атрибут <code>href</code>, а через атрибут <code>to</code>. Перед использованием <code>&lt;Link&gt;</code> его нужно подключить уже знакомым способом через <code>import</code>.</p><pre><code class=\"language-javascript\">import { Link } from \"react-router-dom\";\n&lt;Link to=\"/product/1234-slug\"&gt;Link text&lt;/Link&gt;</code></pre><h2>Задание</h2><p>Сделайте страницу <code>IndexPage.jsx</code> для списка товаров, отображаемых на главной странице. Данные пока прописываем фиксированные, никаких загрузок из БД не требуется. Клик по кнопке в карточке товара должен вести на страницу с товаром. Переход должен быть мгновенным, URL в браузере при этом должен меняться.</p>",
      "tKey": 4
    },
    {
      "name": "Реализация API и концепция REST",
      "html": "<p>До этого момента наш сервер возвращал клиенту (т.е. браузеру) один из двух типов контента:</p><ol><li>Статические файлы</li><li>Динамические веб-страницы, контент которых зависит от каких-то внутренних переменных или состояния базы данных.</li></ol><p>Теперь, когда мы перешли к концепции SPA, мы вообще отдаем только статику – наш HTML никак не зависит от данных и всегда одинаковый. В результате мы отображаем в карточках товара только жестко пописанный в JSX контент. Как же нам теперь получать с сервера актуальные данные и отображать товары, хранящиеся в базе?</p><p>Для этого наш клиентский код должен научиться запрашивать эти данные с сервера, а сервер – научиться эти данные отдавать. Это будет совершенно новый тип запросов – на этот раз мы запрашиваем не статику или веб-страницы, а <em>данные</em>. </p><p>Запросы к данным принято называть API – Application Program Interface, или программный интерфейс приложения. То есть, запросы к страницам рассматриваются как \"человеческий\" интерфейс приложения – поскольку возвращаемая информация предназначена для чтения человеком. А запросы к данным – как \"программный\" интерфейс – потому что возвращаемая информация неудобна для восприятия человеком, а предназначена для других программ (в данном случае для нашего клиентского кода).</p><p>С технической точки зрения API-запросы ничем не отличаются от запросов к страницам или статике. Это точно такие же HTTP-запросы и HTTP-ответы сервера, с которыми мы имели дело раньше – естественно, со своим <code>ContentType</code>.</p><p>Общепринятым стандартом для обмена данными в веб является уже знакомый нам JSON – язык записи Javascript-объектов. Раньше еще использовался формат XML, но сейчас так никто не делает. Для выдачи данных в JSON-формате сервер должен установить Content-Type равный <code>application/json</code>.</p><h2>Концепция REST</h2><p>Раньше в веб-приложениях было принято создавать API-интерфейс, исходя из собственных предпочтений и понимания удобства. В результате интерфейсы всех приложений были разными, и совершенно непонятны стороннему разработчику. </p><p>Особенные неудобства этот факт доставлял в двух случаях. Первый – когда в команду какого-либо проекта вливался новый разработчик, ему приходилось слишком долго вникать в существующее API перед тем, как начать работать. Второй – при разработке веб-приложений с открытым API, которым может пользоваться сторонние разработчики, а не только клиентское приложение данного сайта. </p><p>Для решения этих проблем появилась концепция REST , которая описывает стандарт построения API. Эта концепция стала общепринятой, и интерфейсы практически всех современных веб-приложений построены в соответствии с ней. </p><p>Эта концепция называется REST. Интерфейсы и приложения, построенные на ее основе, иногда называют прилагательным <code>RESTful</code>.</p><p>Ее суть заключается в четком разделении глагола и существительного (действия и объекта, над которым нужно произвести действие) в синтаксисе запроса.</p><p>Концепция REST предполагает использование только четырех глаголов, для запоминания которых используют аббревиатуру CRUD – это Create (создание), Read (чтение), Update (модификация) и Destroy (уничтожение) – <a href=\"https://ru.wikipedia.org/wiki/CRUD\">https://ru.wikipedia.org/wiki/CRUD</a></p><p>В веб-приложениях глагол передается с помощью <em>метода</em>, которым отправляется запрос. Мы с вами еще не рассматривали методы – поскольку браузер все запросы отправляет с помощью метода по умолчанию, который называется GET. </p><blockquote><p>Для эксперимента откройте консоль браузера (Shift-Ctrl-i или Alt-Cmd-i на маке), вкладку  Network и обновите страницу. Вы увидите таблицу запросов, в которой есть колонка  <code>Method</code> – все выполненные браузером запросы будут иметь метод GET.</p></blockquote><p>Кроме GET, для CRUD используются еще три метода HTTP-запроса – POST, UPDATE (иногда PATCH) и DELETE.</p><blockquote><p>Изучите самостоятельно, какие еще методы запроса существуют в протоколе HTTP: <a href=\"https://developer.mozilla.org/ru/docs/Web/HTTP/Methods\">https://developer.mozilla.org/ru/docs/Web/HTTP/Methods</a>. </p></blockquote><p>Итак, серверу понятно, что глагол (тип действия, которое надо совершить) – нужно брать исходя из имени метода. Очевидно, что существительное (объект, над которым надо осуществить действие), должно как-то описываться в URL.</p><p>При этом принято следующее соглашение:</p><ol><li>Первая часть URL для всех API-запросов должна быть одинаковой – чтобы сервер мог определить, является данный запрос API-запросом или нет. Ее называют префиксом – обычно в качестве префикса берут <code>api</code> или <code>rest</code>.</li><li>Вторая часть запроса – это модель. Она соответствует типу коллекции в базе данных, над которой мы хотим выполнить действие.</li><li>Третья часть (необязательная) – это идентификатор модели – конкретной записи из коллекции, над которой мы хотим выполнить действие.</li></ol><p>Давайте рассмотрим на нескольких примерах, как должно реагировать наше RESTful API. </p><table><thead><tr><th>Method</th><th>URL</th><th>Действие</th></tr></thead><tbody><tr><td>GET</td><td><code>/api/product</code></td><td>Получить список всех товаров (т.е. записей коллекции <em>product</em>)</td></tr><tr><td>GET</td><td><code>/api/product/507f1f77bcf86cd799439011</code></td><td>Получить товар с идентификатором 507f1f77bcf86cd799439011</td></tr><tr><td>CREATE</td><td><code>/api/product</code></td><td>Создать новую запись в коллекции <em>product</em>. Данные для новой записи передаются в теле (body) запроса</td></tr><tr><td>UPDATE</td><td><code>/api/product/507f1f77bcf86cd799439011</code></td><td>Изменить товар с идентификатором 507f1f77bcf86cd799439011. Данные с новыми значениями полей передаются в теле (body) запроса</td></tr><tr><td>DELETE</td><td><code>/api/product/507f1f77bcf86cd799439011</code></td><td>Удалить товар с идентификатором 507f1f77bcf86cd799439011</td></tr></tbody></table><p>Как видите, в некоторых случаях нам пришлось использовать тело запроса (http request body) – необязательная область данных запроса, используемая для передачи сложных или больших объемов информации (например, для закачки файла или записи изменений в какую-нибудь модель). </p><p>Кроме того, в некоторых случаях могут использоваться дополнительные параметры URL, обычно перечисляемые после знака \"?\" – их еще называют GET-параметрами (даже если запрос имеет тип, отличный от GET) – <a href=\"https://en.wikipedia.org/wiki/Query_string\">https://en.wikipedia.org/wiki/Query_string</a></p><p>Несмотря на присутствие дополнительной информации в GET-параметрах и теле запроса, основная информация (глагол и существительное) содержатся в методе и URL запроса. Концепция REST позволяет любому разработчику быстро определить, какое действие делает тот или иной запрос к приложению, или сконструировать нужный ему запрос, не вчитываясь в документацию.</p><h2>Работа с идентификаторами MongoDB</h2><p>До этого мы мало сталкивались с идентификаторами записей в MongoDB, давайте разберемся с ними подробнее. </p><p>Каждая запись в MongoDB имеет уникальное поле <code>_id</code> – ее идентификатор. MongoDB генерирует его автоматически при создании записи и гарантирует, что каждый идентификатор будет абсолютно уникален. </p><p>Идентификатор представляет собой последовательность двоичных данных, которая в Javascript может быть представлена строкой из 24 символов. Каждый из этих символов представляет так называемую шестнадцатеричную цифру <a href=\"https://ru.wikipedia.org/wiki/Шестнадцатеричная_система_счисления\">https://ru.wikipedia.org/wiki/Шестнадцатеричная<em>система</em>счисления</a></p><p>Важно понимать, что эта строка – всего лишь вариант представления идентификатора. На практике, драйвер MongoDB всегда использует двоичный вариант строки – он занимает меньше места и быстрее обрабатывается.</p><p>Для нас это значит, что мы не можем осуществлять поиск по идентификатору без его преобразования в двоичный формат. То есть, вот такой код ничего не найдет:</p><pre><code>const someProductId = \"5b3dd4a7542a925936ea39fb\";\n\nproductCollection.findOne({ _id: someProductId }).then(function(products) {\n  // в products будет пусто, \n  // даже если в коллекции есть товар с таким идентификатором\n})</code></pre><p>Если мы хотим использовать поле <code>_id</code> для поиска, нам нужно сначала преобразовать строку с имеющимся идентификатором в двоичный формат. Для этого в модуле <code>mongodb</code> есть специальная функция <code>ObjectID</code>. </p><pre><code>const MongoClient = require('mongodb').MongoClient;\nconst ObjectID = require('mongodb').ObjectID;\n...\n\nconst someProductId = \"5b3dd4a7542a925936ea39fb\";\n\nproductCollection.findOne({ _id: ObjectID(someProductId) }).then(function(products) {\n  // теперь, если в коллекции есть товар с таким идентификатором,\n  // мы получим массив с этим товаром в качестве единственного элемента\n})</code></pre><p>Давайте реализуем эту концепцию для нашего приложения.</p><h2>Задание</h2><p>Реализуйте возможность запрашивать товары через API в формате JSON. В данный момент нужно реализовать только GET-запрос, зато оба типа – с идентификатором и без него.</p><p>То есть, запрос на <code>/api/product</code> должен выводить весь список товаров в JSON-формате. Запрос же на <code>/api/product/ИДЕНТИФИКАТОР_КОНКРЕТНОГО ТОВАРА</code> должен возвращать данный конкретный товар.</p><p>В комментарии к заданию укажите какой-нибудь URL с запросом к конкретному товару, чтобы его можно было проверить.</p><h3>Подсказки и требования</h3><ol><li>После запроса к базе данных вы получите объект или массив объектов. Но HTTP-умеет возвращать в ответе только строковые данные. Если вы просто выдадите объект в ваш response: <code>res.write(someObject)</code>, то он преобразует любой объект в одну и ту же строку <code>[Object object]</code> и выдаст ее в браузер. Чтобы выдать нормальное строковое представление объекта, нужно использовать функцию <code>JSON.stringify</code>: <code>res.write(JSON.stringify(someObject))</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify</a></li><li>После реализации вы сможете просто зайти браузером на указанные URL, как на обычные страницы. В настоящее время Хром показывает JSON как обычную строку, что очень неудобно для восприятия. Это можно исправить, если установить себе в Хром расширение <em>JSON Formatter</em>: <a href=\"https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa\">https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa</a></li><li>Создайте в <code>ProductService.js</code> новую функцию для поиска по id и назовите ее <code>findById</code>. Помните, что поле идентификатора в MongoDB выглядит как <code>_id</code>, а не просто <code>id</code>.</li><li>Реализуйте корректную обработку ситуации, когда в качестве id в ваш URL попал несуществующий в вашей базе идентификатор товара (но при этом являющийся корректным MongoDB-идентификатором). В этом случае вы должны выдать ошибку  404.</li><li>При реализации используйте новую функцию <code>serveAPI</code>. Передавайте ей управление, если ваш запрос начинается с <code>/api/products</code>, и внутри анализируйте – был ли передан id или нет, чтобы определить необходимое поведение. Для анализа удобно разбить pathname на части с помощью функции <code>split</code>: <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/split\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/split</a></li></ol>",
      "tKey": 5
    },
    {
      "name": "Обработка ошибок",
      "html": "<p>В предыдущем задании мы сделали URL, по которому можно зайти и получить JSON конкретного товара, зная его id:</p><pre><code>/api/product/5b3dd4a7542a925936ea39fb</code></pre><p>Если пользователь введет в URL другой идентификатор товара (например, заменит одну цифру в корректном URL), у нас будет выдана страница 404. Это правильное поведение.</p><p>Но что будет, если пользователь введет URL, в котором будет некорректный с точки зрения MongoDB идентификатор? Например, состоящий из 25 или 23 символов? Или содержащий в строке не шестнадцатеричные цифры, а другие символы?</p><pre><code>/api/product/_b3dd4a7542a925936ea39fb</code></pre><p>При заходе на такой URL наше приложение \"падает\" – сервер выводит в консоль ошибку и прекращает свою работу. Очевидно, что это некорректное поведение – любой желающий может остановить работу нашего интернет-магазина до момента, пока мы вручную не запустим сервер после падения.</p><p>Чтобы правильно обработать эту ситуацию, мы должны познакомиться с новой для нас концепцией в Javascript – обработкой ошибок. </p><p>Средства обработки ошибок (или, как их еще называют, <em>исключений</em> – т.е. ненормальных, исключительных ситуаций) – есть практически во всех языках и выглядят примерно одинаково. </p><p>Изучите самостоятельно, как устроена обработка исключений в javascript: <a href=\"https://learn.javascript.ru/exception\">https://learn.javascript.ru/exception</a></p><p>Теперь давайте разберемся, где именно происходит исключение, когда пользователь вводит в URL некорректное значение вместо идентификатора. Когда происходит необработанное исключение и падает сервер, в консоль выдается имя файла и номер строки кода, которая спровоцировала ошибку – а также последовательность вызовов функций, которые привели к этой ситуации.</p><p>Внимательно на нее посмотрев, мы увидим, что исключение происходит, когда мы пытаемся создать MongoDB идентификатор из дефектной строки, т.е. когда вызываем функцию <code>ObjectID(id)</code>.</p><p>Первая идея – завернуть вызов <code>ObjectID(id)</code> внутрь конструкции <code>try...catch</code>. </p><pre><code>getProductById(id) {\n  let mongoId;\n  try {\n    mongoId = ObjectID(id);\n  } catch(err) {\n    ...\n  }\n  return productCollection.findOne({ _id: mongoId });\n}</code></pre><p>Теперь, если <code>ObjectID</code> вызовет исключение, мы поймаем его внутри блока <code>catch</code>. Но как именно нам обработать наше исключение? Наша функция <code>getProductById</code> должна возвращать промис. Как мы уже упоминали, у промисов есть возможность обрабатывать не только успешный результат операции, но и неудачу. Для этого код, выполняющий операцию, должен вызвать функцию <code>.reject()</code> у промиса. Тогда код, пользующийся результатом операции, может получить управление через метод промиса <code>.catch()</code> – который работает точно так же, как <code>then</code>, но для случая неудачи.</p><pre><code>function somePromiseFunction() {\n  return new Promise(function(resolve, reject) {\n    reject(new Error(\"Error message\"));\n  });\n}\n\nsomePromiseFunction()\n   .then(function(result) {\n     // сюда мы никогда не попадем, потому что \n     // resolve нигде не вызывается\n   })\n  .catch(function(error) {\n    // сюда мы попадем, потому что somePromiseFunction\n    // вызывает reject\n    // в аргументе error нам придет объект ошибки,\n    // созданный внутри somePromiseFunction\n    // вызовом new Error(\"Error message\")\n  });</code></pre><p>Возвращаясь к нашему случаю – после \"поимки\" исключения в <code>getProductById</code> мы должны прервать выполнение функции и вернуть промис со статусом ошибки.</p><p>Это можно сделать обычным способом – создать новый промис, немедленно вызвать у него reject() и затем вернуть.</p><pre><code>} catch(err) {\n  const failedPromise = new Promise(function(resolve, reject) {\n    reject();\n  });\n  return failedPromise; \n}</code></pre><p>Однако, это довольно распространенная ситуация – когда нам нужно вернуть уже выполненный или ошибочный промис, поэтому разработчики языка позаботились о коротком способе сделать это:</p><pre><code>} catch(err) {\n  return Promise.reject();\n}</code></pre><p>Вызов <code>Promise.reject()</code> создаст новый промис, и немедленно переведет его в состояние ошибки. </p><p>Теперь наша функция не будет генерировать необработанных исключений и не приведет к падению сервера. Она вернет промис с состоянием ошибки – нам нужно будет на него подписаться и выдать информацию об ошибке в браузер. </p><pre><code>ProductService.getProductById(&lt;id, полученный из запроса&gt;)\n  .then(function(product) {\n    // выдача JSON товара\n  })\n  .catch(function(err) {\n    // выдача ошибки\n    // текст ошибки доступен в err.message\n  })</code></pre><p>Чтобы выдать в браузер ошибку, мы снова должны использовать специальный код статуса – только на этот раз не 404, а 500. Этот код означает внутреннюю ошибку сервера, которую можно отобразить на клиенте для информирования пользователя. Как и в случае 404, мы при этом можем выдать любую дополнительную текстовую информацию с помощью <code>res.write();</code>.</p><h2>Задание</h2><p>Реализуйте обработку ошибок. Убедитесь, что при вводе некорректного идентификатора в URL сервер не падает, а возвращает ответ со статусом 500.</p>",
      "tKey": 6
    },
    {
      "name": "Функция fetch и использование API на клиенте",
      "html": "<p>Теперь нам нужно научиться в клиентском приложении пользоваться API, которое мы только что сделали. Давайте сначала сделаем это для главной страницы со списком товаров.</p><ol><li>Мы должны загрузить с сервера данные по адресу <code>/api/product</code>. Загрузку данных принято делать внутри функции <code>componentDidMount()</code>, заданной в компоненте. React автоматически вызывает эту функцию, когда компонент полностью готов и уже внедрен в страницу.</li><li>Загрузка данных – асинхронный процесс, то есть она займет определенное время. То есть, данные в компоненте будут меняться с течением времени – это значит, что мы должны поместить их внутрь состояния <code>this.state</code> – например, в <code>this.state.products</code>.</li><li>Раз мы используем <code>state</code>, у компонента необходимо объявить конструктор, который запишет в <code>this.state</code> начальное значение – например, пустой объект.  Если этого не сделать, в <code>this.state</code> будет <code>null</code> – и все наши попытку вызвать <code>this.setState()</code> будут приводить к ошибке.</li><li>При рендеринге карточек товара мы должны сделать проверку – если в <code>this.state.products</code> данные пока отсутствуют, не выводить ничего. Если данные готовы – вывести их с помощью функции <code>map</code>, как мы это делали ранее для компонента навигации. </li></ol><h2>Работа с fetch</h2><p>Для этого служит функция <code>fetch</code> – ей можно передать любой URL, и она вернет объект <code>response</code>, содержащий ответ сервера с необходимыми данными. Функция асинхронная, то есть возвращает объект через промис.</p><pre><code>fetch(\"/api/products\").then(function(response) {\n  alert(response.status);\n})</code></pre><p>Казалось бы, мы могли в этот момент просто вызвать this.setState (не забыв предварительно сделать биндинг функции, передаваемой в промис), но все не так просто.</p><p>Дело в том, что на данный момент – когда <code>fetch</code> завершит свой промис  – данные еще не готовы. Доступны только заголовки ответа и код статуса. В этом есть смысл – потому что данные могут иметь огромный размер и еще не скачались к этому моменту.</p><p>Для получения данных у объекта <code>response</code> есть функция <code>json()</code>, которая вернет (конечно, через промис) полученные данные в формате json, когда они будут готовы.</p><pre><code>fetch(\"/api/products\").then(function(response) {\n  response.json().then(function(json) {\n    //вот теперь данные готовы\n    //и доступны в переменной json\n  })\n})</code></pre><p>Код выглядит сложновато – два уровня вложенности сбивают с толку, два раза придется прописывать <code>catch</code> для обработки ошибок. К счастью, в функции <code>then</code> для удобства реализован механизм <code>chaining</code> - обработка промисов \"по цепочке\" (chain = цепь).</p><h2>Чейнинг (соединение по цепочке) промисов</h2><p>В статье <a href=\"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/then</a> на русский язык этот механизм переведен как \"соединение\", но разработчики обычно называют его просто \"чейнинг\".</p><p>Его суть заключается в том, что сама функция <code>then</code> тоже возвращает промис. Если внутри функции, которую мы передаем в <code>then</code>, мы не передаем ничего через return – то функция <code>then</code> вернет оригинальный промис, который мы можем повторно обработать.</p><pre><code>const promise1 = someAsyncCall();\nconst promise2 = promise1.then(function() {\n  // не используем return\n});\nalert(promise1 === promise2); // выведет true</code></pre><p>В результате мы можем удобно подписать на <code>then</code> сразу несколько функций, которые будут идти как бы цепочкой:</p><pre><code>someAsyncCall()\n  .then(function() {\n    // первый обработчик\n  })\n  .then(function() {\n    // второй обработчик\n  })\n  .then(function() {\n    // третий обработчик\n  })\n  .catch(function() {\n    // обработчик ошибки\n  })</code></pre><p>Поскольку все эти <code>then</code> возвращают один и тот же промис, механизм также удобно использовать, чтобы обработать исключения в промисе с помощью <code>catch</code>.</p><p>Но самая важная особенность чейнинга заключается в том, что мы можем вернуть из нашего обработчика другой, новый промис. В этом случае и сама функция <code>then</code>, вызвавшая наш обработчик, вернет этот новый промис. В результате мы можем последовательно вызвать несколько асинхронных операций, не делая каждый раз новый уровень вложенности:</p><pre><code>asyncOp1()\n  .then(function(result1) {\n    // result1 - результат выполнения первой операции\n    // возвращаем новый промис\n    return asyncOp2();\n  })\n  .then(function(result2) {\n    // result2 - результат выполнения второй операции\n    // возвращаем новый промис\n    // return asyncOp3();\n  })\n  .then(function(result3) {\n    // result3 - результат выполнения второй операции\n  })\n  .catch(function(err) {\n    // обработчик ошибки\n    // сюда попадем, если хотя бы в одном из промисов цепочки была ошибка\n  })</code></pre><p>С учетом механизма цепочки наш код для вызова API можно переписать следующим образом:</p><pre><code>fetch(\"/api/products\")\n  .then(function(response) {\n    return response.json();\n  })\n  .then(function(json) {\n    //вот теперь данные готовы\n    //и доступны в переменной json\n  }.bind(this))</code></pre><h2>Условный рендеринг и пустое значение</h2><p>Мы сталкиваемся с относительно новой для нас ситуацией – когда нам приходится делать выбор, отрисовывать или нет целый блок в зависимости от значения переменной.</p><p>Во-первых, в таких случаях код рендеринга этого блока выносят в отдельную функцию – в нашем случае логично называть ее <code>renderProducts</code>. Она должна возвращать либо компонент, либо массив компонентов – тогда мы сможем легко использовать ее в основной функции render:</p><pre><code>  renderProducts() {\n    return &lt;div&gt;\n       ...\n    &lt;/div&gt;;\n    // Или можно вернуть сразу массив компонентов\n    // return this.state.products.map()\n  }\n  render() {\n     return &lt;div&gt;\n        ...\n        { this.renderProducts() }\n        ...\n     &lt;/div&gt;;\n  }</code></pre><p>Во-вторых, нам нужно реализовать проверку – заполнено ли к текущему моменту значение <code>this.state.products</code>. Если оно не готово, React допускает вставить в верстку значение <code>false</code> – для него это будет означать не выводить в этом месте ничего. Этого можно достичь условной проверкой внутри <code>renderProducts</code> или тернарным оператором внутри <code>render</code>.</p><p>Проверка:</p><pre><code>  renderProducts() {\n    if (!this.state.products) { return false; }\n    return &lt;div&gt;\n       ...\n    &lt;/div&gt;;\n  }</code></pre><p>Тернарный оператор:</p><pre><code>  render() {\n     return &lt;div&gt;\n        ...\n        { \n          this.state.products\n            ? this.renderProducts() \n            : false\n        }\n        ...\n     &lt;/div&gt;;\n  }</code></pre><p>Есть еще третий интересный способ – использование логического оператора И:</p><pre><code>{ \n  this.state.products &amp;&amp; this.renderProducts() \n}</code></pre><p>Логический оператор И работает следующим образом. Если хотя бы один из его аргументов имеет пустое значение (например, false или null или \"\" или 0), он немедленно вернет это значение. Если ни один из аргументов не пуст – он вернет последний аргумент. Благодаря этому свойству его очень удобно использовать для условного рендеринга.</p><h2>Задание</h2><p>Реализуйте на главной странице получение данных из API и рендеринг полученных карточек</p>",
      "tKey": 7
    },
    {
      "name": "Обработка статуса загрузки и ошибки",
      "html": "<p>Сейчас загрузка данных через АПИ происходит почти мгновенно – потому что объем данных незначителен. Однако, представьте себе, что объем данных вырос, а скорость соединения с Интернет временно снизилась. В результате ответ сервера может занять несколько секунд. Если пользователь все это время будет видеть пустой экран, он может подумать, что произошла какая-то ошибка – и, не дождавшись окончания загрузки, закрыть страницу.</p><p>Чтобы этого избежать, нам нужно корректно отображать текущий статус загрузки – и честно информировать об ошибке, если она произошла.</p><p>Для начала, давайте сделаем нашу загрузку со стороны сервера более длительной, чтобы смоделировать поведение при долгой загрузке.</p><pre><code>ProductService.getProducts().then(function(products) {\n  setTimeout(function() {\n    res.setHeader('Content-Type', 'application/json');     res.write(JSON.stringify(products));\n    res.end();\n  }, 2000);\n});</code></pre><p>Вместо того, чтобы сразу выдать результат, мы вызываем функцию <code>setTimeout</code>, которая выполнит наш код не сразу, а после паузы в 2000 миллисекунд (т.е. через 2 секунды) <a href=\"https://developer.mozilla.org/ru/docs/Web/API/WindowTimers/setTimeout\">https://developer.mozilla.org/ru/docs/Web/API/WindowTimers/setTimeout</a>.</p><p>Теперь давайте пропишем план, по которому нам нужно действовать.</p><ol><li>Нам нужно завести в <code>this.state</code> еще одно поле – status. Оно будет хранить строку, принимающую одно из следующих значений: <code>\"idle\"</code> (ничего не делаю), <code>\"pending\"</code> (загружаю), <code>\"ready\"</code> (готово), <code>\"error\"</code> (ошибка).</li><li>В конструкторе нужно будет установить начальное значение для <code>status</code> – естественно, это <code>\"idle\"</code>.</li><li>В момент, когда мы вызываем <code>fetch</code>, нужно будет установить статус <code>\"pending\"</code>. </li><li>При удачном завершении запроса или при возникновении ошибки мы должны установить статусы <code>\"ready\"</code>и <code>\"error\"</code> соответственно.</li><li>В случае, когда статус <code>ready</code> – вместо карточек нужно вывести компонент бутстрапа <code>alert</code> синего цвета: <a href=\"https://getbootstrap.com/docs/4.1/components/alerts/\">https://getbootstrap.com/docs/4.1/components/alerts/</a></li><li>В случае ошибки – <code>alert</code> красного цвета: </li></ol><h2>Задание</h2><p>Реализуйте корректную обработку статусов загрузки описанным способом.</p>",
      "tKey": 8
    },
    {
      "name": "GET-параметры в API и страница товара",
      "html": "<p>Теперь нам осталось аналогичным образом реализовать получение данных на странице товара. По сравнению с главной страницей у нас есть две детали:</p><ol><li>URL страницы параметризован – нам нужно предварительно получить эти данные в компоненте страницы, перед тем, как делать запрос</li><li>Поскольку нам нужно искать товар не по его <code>_id</code>, а по полю <code>key</code> – которое с точки зрения MongoDB является обычным полем – нам нужно будет делать обычный запрос к <code>/api/products</code>, но с дополнительным GET-параметром для поиска.  Естественно, нужно будет реализовать этот поиск на серверной стороне.</li></ol><p>Параметризованные данные из маршрута страницы роутер подставляет в <code>props</code> нашему компоненту – мы в любой момент можем обратиться к нему с помощью выражения <code>this.props.match.params</code>.</p><p>Запрос к API с дополнительным GET-параметром будет выглядеть как <code>/api/product?key=100</code>, где 100 – значение ключа товара, которое мы извлекли из параметров.</p><p>Чтобы правильно обработать такой запрос, нам придется выполнить на серверной стороне ряд мероприятий.</p><ol><li>Для парсинга GET-параметров удобно использовать библиотеку <code>query-string</code>, которую нужно предварительно установить <code>npm install query-string --save</code></li><li>Эта библиотека умеет превращать строку с GET-параметрами (<code>urlParsed.search</code>) в удобный объект c ключами и значениями, наподобие <code>{ key: 100 }</code>. Изучите самостоятельно, как это сделать – <a href=\"https://www.npmjs.com/package/query-string\">https://www.npmjs.com/package/query-string</a> </li><li>Нам нужно модифицировать функцию <code>getProducts</code>. Она должна принимать на вход аргумент <code>where</code>, в котором будет передаваться объект для поиска товаров в базе. Тогда мы сможем передать ей объект, полученный парсингом <code>query-string</code>.</li><li>Аргумент <code>where</code> наша функция может использовать непосредственно для поиска в коллекции <code>productCollection.find(where)</code>.</li><li>Однако, тогда наш поиск по ключу не будет работать – так как в mongo хранятся числовые значения ключей, а после парсинга GET-параметров мы получим строковые. Для решения этой проблемы мы можем просто провести предварительную обработку объекта <code>where</code> в <code>getProducts</code>:</li></ol><pre><code>if (where.key) {\n  where.key = Number(where.key);\n}</code></pre><h2>Задание</h2><p>Реализуйте корректную работу страницы товара. Два дополнительных требования:</p><ol><li>Страница должна работать как при переходе с главной страницы, так и при обновлении (для этого нужно обрабатывать ее в серверном роутинге).</li><li>В API должен корректно работать поиск по <code>slug</code> и по другим полям – например, <code>/api/product?slug=tovar1</code>. Скиньте ссылку на такой URL в комментариях к заданию.</li></ol>",
      "tKey": 9
    }
  ]
},{
  "_id": {
    "$oid": "5c03fb7a06316ed0602c61f4"
  },
  "name": "Express.js и бэк-офис магазина",
  "html": "<p>В этом юните мы переведем наше сервер-сайд приложение на фреймворк <code>express.js</code> – <a href=\"https://expressjs.com/\">https://expressjs.com/</a> и сделаем для нашего магазина back office – панель инструментов для управления каталогом товаров, которая позволит редактировать и добавлять информацию через удобный веб-интерфейс, а не через базу данных.</p>",
  "uKey": 8,
  "tasks": [
    {
      "name": "Установка express.js",
      "html": "<p>Express.js (<a href=\"https://expressjs.com/en/4x/api.html\">https://expressjs.com/en/4x/api.html</a>) – самый распространенный фреймворк для Node.js. </p><p>Его популярность связана с тем, что он не навязывает структуру приложения, как это делают многие фреймворки – но делает некоторые рутинные операции гораздо проще. </p><p>В основном эти рутинные операции связаны с роутингом. Express.js позволяет удобно привязывать функции-обработчики к разным маршрутам, расширяет функционал объектов <code>Request</code> и <code>Response</code> несколькими удобными полями и функциями, а также реализует концепцию <code>middleware</code> - когда запрос перед попаданием в финальную функцию-обработчик может пройти несколько стадий предварительной обработки. С помощью этой концепции очень удобно строить систему ограничения доступа, которая нужна для любого бек-офиса.</p><h2>Установка express.js и настройка сервера</h2><p>Установка, как обычно происходит через npm:</p><pre><code>npm install express --save</code></pre><p>Создание сервера на express.js очень похоже на создание сервера с помощью стандартного модуля http, который мы использовали раньше:</p><pre><code>const express = require('express');\nconst app = express();\n\napp.listen(process.env.PORT, function() {\n  console.log(\"Server started\");\n});</code></pre><h2>Маршрутизация</h2><p>Маршрутизацию в express.js делать гораздо проще, чем с использованием стандартного http.</p><pre><code>app.get('/', serveSPA);\napp.get('/product/:key_and_slug', serveSPA);</code></pre><p>Этими двумя строчками мы сообщили express.js, что GET-запросы к гласной странице (адрес /) и все запросы к страницам товаров должны обрабатываться функцией <code>serveSPA</code>. Синтаксис <code>/product/:key_and_slug</code> мы уже встречали при использовании React Router – там упоминалось, что именование параметров с помощью двоеточия является общепринятым стандартом во многих системах роутинга.</p><h2>Обработка статики и middleware</h2><p>Объект <code>app</code> – это экземпляр express-приложения, который мы создали вызовом <code>express()</code>. Кроме метода <code>get</code>, с которым мы познакомились, у него есть еще методы <code>post</code>, <code>put</code> и <code>delete</code> – для каждого метода HTTP-запроса. </p><p>Всем этим методам нужно передать URL и \"финальный\" обработчик – который, при его вызове, должен обработать запрос и сформировать ответ.</p><p>Но, кроме финальных обработчиков запроса – в express.js можно использовать промежуточные обработчики – их называют <code>middleware</code>. Отличие middleware-обработчика в том, что он не обязан формировать <code>response</code>, а может просто \"пропустить\" запрос на дальнейшую обработку.</p><p>Это очень удобная концепция, и она хорошо подходит для решения некоторых типовых задач:</p><ol><li>Ограничение доступа. Middleware проверяет, от какого пользователя пришел request. Если пользователю разрешено действие, то middleware не делает ничего и пропускает запрос на дальнейшую обработку. Если доступ не разрешен  – middleware само отправляет ответ, обработка запроса на этом заканчивается. </li><li>Получение дополнительной информации и запись в request. Например, middleware вычисляет, от кого пришел запрос, записывает эту информацию в request, и пропускает его на дельнейшую обработку. В результате всем другим обработчикам не нужно самостоятельно добывать эту информацию – она уже положена в request в удобном виде. </li><li>Избирательная обработка некоторых запросов. Например, когда в роутинге требуется более сложная логика, чем простая параметризация. В этом случае мы можем назначить middleware на обработку довольно большого круга запросов (например, вообще всех). В результате в него будет попадать много \"лишних\" запросов – но middleware с помощью более сложной логики само определит, какие запросы стоит обслужить самостоятельно, а какие \"пропустить\", позволив их дальнейшую обработку.</li></ol><p>Примером такого middleware является <code>static</code>, уже встроенный в express.js.</p><pre><code>const staticMiddleware = express.static(\"public\");\napp.use(staticMiddleware);</code></pre><p>Функция <code>express.static</code> сама не является  middleware. Вместо этого она умеет генерировать middleware для обработки статики – если ей указать папку, где лежат статические файлы.</p><p>Подключение middleware осуществляется с помощью функции <code>app.use()</code>. Она работает точно так же, как и уже знакомая нам <code>app.get</code> – первым параметром она ждет путь, вторым – функцию для обработки. Однако, мы можем пропустить первый параметр и сразу указать функцию-обработчик – в этом случае middleware будет подключен к абсолютно всем запросам.</p><p>Ровно это нам и нужно – теперь любой запрос будет предварительно попадать в middleware. Оно проверит, соответствует ли этот запрос имени файла и выдаст файл, находящийся в папке <code>public</code>. При этом, выдаст его со всеми необходимыми заголовками – в том числе с <code>Content-Type</code>. Нам больше не нужно об этом заботиться, и мы можем смело удалить нашу функцию <code>serveStatic</code>.</p><h2>Подключение API</h2><p>Наша функция API в данный момент содержит функционал для обслуживания разнотипных запросов – <code>/api/product</code> для списка товаров и <code>/api/product/:id</code> для обслуживания одного товара. </p><p>Мы сделали это, потому что организация роутинга средствами чистого JS была немного неудобной. Сейчас мы можем разделить serveAPI на две функции и, используя <code>express.js</code>, легко привязать их к необходимым маршрутам:</p><pre><code>app.get('/api/product', serveProducts);\napp.get('/api/product/:id', serveOneProduct);</code></pre><p>Внутри этих функций нужно использовать дополнительные преимущества, которые нам дает express.js:</p><ol><li>Нам не нужно использовать <code>queryString.parse</code> для превращения строки GET-параметров в объект. Объект с этими параметрами уже доступен в <code>req.query</code>.</li><li>Нам не нужно сложно \"выковыривать\" id товара из пришедшего URL. Поскольку при роутинге мы указали его в качестве параметра <code>/api/product/:id</code>, он будет доступен через выражение <code>req.params.id</code>.</li><li>Нам не нужно устанавливать специальный заголовок для json, отдельным действием конвертировать json в строку, выдавать его в response и вызывать <code>res.end()</code>. Все эти действия мы можем сделать одним простым выражением: <code>res.json(product)</code> (или <code>res.json(products)</code>);</li></ol><h2>Обработка 404</h2><p>Это тоже делается в express.js невероятно легко. Мы просто должны вызвать привязку нашего обработчика <code>serveNotFound</code> самой последней. В результате express.js перейдет к ней, только когда все остальные привязки не сработали:</p><pre><code>app.use(serveNotFound);</code></pre><h2>Задание</h2><p>Переведите ваше приложение на использование express.js. Весь существующий функционал должен сохраниться. Приберитесь в коде – из файла server.js должны быть удалены все лишние функции и не используемые теперь модули – <code>http</code>, <code>queryString</code> и другие. </p><h3>Подсказки и требования</h3><p>Если вы вдруг разместили <code>app.use(staticMiddleware);</code> выше строки, которая подписывает адрес <code>/</code> на функцию <code>serveSPA</code>, вы можете столкнуться с интересным эффектом. Вместо нормальной SPA-страницы сервер будет выдавать нам ранее сделанный <code>index.html</code>.</p><p>Это происходит из-за алгоритма работы этого встроенного в express.js middleware. Оно считает, что если в указанной ему папке существует файл <code>index.html</code>, то запрос к главной странице <code>/</code> можно считать статическим и выдает соответствующий файл. Можно просто удалить этот файл из <code>/public</code> (и из <code>/static</code>, чтобы снова не попал в <code>/public</code> при следующей сборке) – он нам больше не понадобится.</p>",
      "tKey": 1
    },
    {
      "name": "Реализация бек-офиса",
      "html": "<p>Теперь нам нужно реализовать основу для панели управления интернет-магазином. В первой версии функционал панели управления будет почти ничем не отличаться от каталога – в ней можно будет просматривать товары и заходить в них. </p><h2>Задание</h2><p>Реализуйте первую версию панели управления интернет-магазином.</p><p>В панели должны присутствовать следующие страницы:</p><table><thead><tr><th>URL</th><th>Название класса</th><th>Функционал</th></tr></thead><tbody><tr><td>./panel</td><td>PanelPage</td><td>Ссылка на каталог товаров</td></tr><tr><td>./panel/product</td><td>PanelProductsPage</td><td>Каталог товаров</td></tr><tr><td>./panel/product/:id</td><td>PanelProductPage</td><td>Страница товара</td></tr></tbody></table><p><code>AppBar</code> в панели инструментов должен быть покрашен в другой цвет, чтобы было визуально легко отличить его от обычного интерфейса магазина.</p><p>На этот раз мы реализуем URL страницы товара, основанный на mongo-идентификаторе, а не числовом ключе. URL станет менее читаемый, но в панели инструментов для внутреннего использования это не критично.</p><p>В остальном каталог товаров должен работать как на главной странице.</p>",
      "tKey": 2
    },
    {
      "name": "Формы в React – контролируемый <input>",
      "html": "<p>До этого момента мы имели дело только со статическими элементами HTML – которые показывают пользователю информацию, а не собирают информацию от пользователя. Естественно, для каталога товаров нам понадобятся такие элементы. </p><p>Чаще всего для пользовательского ввода используются теги <code>&lt;input&gt;</code> (ввод однострочного текста, чисел, дат), <code>&lt;input type=\"checkbox\"&gt;</code> (установка или снятие \"галочки\"), <code>&lt;textarea&gt;</code> (ввод многострочного текста), <code>&lt;select&gt;</code> (выбор одного варианта из нескольких).</p><p>Изучить их работу и правила написания вы можете самостоятельно. также перед наячалом работы рекомендуем посмотреть, как эти элементы стилизуются в бутстрапе: <a href=\"http://getbootstrap.com/docs/4.1/components/forms/\">http://getbootstrap.com/docs/4.1/components/forms/</a></p><p>Блок, использующий несколько элементов ввода, обычно называют формой. Поэтому, для описания какого-то API, связанного с полями ввода, всегда можете использовать ключевое слово Forms.</p><p>Поскольку эти элементы управления появлялись в HTML постепенно, они могут иметь не очень логичные и унифицированные способы работы с ними. Например, для похожих элементов – <code>&lt;input&gt;</code> и <code>&lt;textarea&gt;</code> – кардинально отличаются правила задания начального текста:</p><pre><code>&lt;input value=\"начальный текст\" /&gt;\n&lt;textarea&gt;начальный текст&lt;/textarea&gt;</code></pre><p>К счастью, React избавляет нас от этой проблемы, унифицируя способы работы со всеми элементами ввода. Подробно работа React с формами описана на странице <a href=\"https://reactjs.org/docs/forms.html\">https://reactjs.org/docs/forms.html</a></p><p>В целом, нужно знать следующие факты:</p><ol><li>Вся работа с элементами ввода происходит с использованием состояния (<code>this.state</code>) компонента. Состояние должно хранить текущее значение пользовательского ввода для всех компонентов. </li><li>В каждом элементе ввода должно быть прописано текущее значение в виде выражения, на основе <code>this.state</code>, например <code>&lt;input value={ this.state.product.title } /&gt;</code>.</li><li>Если мы оставим все как есть на предыдущем шаге – <code>&lt;input&gt;</code> не будет работать. Стоит пользователю внести туда малейшее изменение, и оно тут же откатится обратно. Это логично – мы же сами прописали, что его <code>value</code> всегда должно быть равно <code>this.state.product.title</code>. После нашего изменения происходит повторный рендеринг компонента, и внутри <code>value</code> вновь окажется <code>this.state.product.title</code>, которое с прошлого раза никак не изменилось. Значит, нам нужно после каждого изменения в <code>&lt;input&gt;</code> немедленно записывать это изменение в <code>this.state.product.title</code>. </li></ol><p>Вот простой пример обработки формы не React:</p><pre><code>class SomeComponent extends ReactComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      product: {\n        title: \"Товар 1\"\n      }\n    }\n  }\n  onChange (event) {\n    this.state.product.title = event.target.value;\n    this.forceUpdate();\n  }\n  render() {\n    return &lt;div&gt;\n      &lt;input \n        value={ this.state.product.title } \n        onChange={ this.onChange.bind(this) }\n      /&gt;\n    &lt;/div&gt;\n  }\n}</code></pre><p>Давайте проговорим, что делает этот код. В конструкторе в <code>state</code> записывается объект товара, состоящий из одного поля – <code>title</code> (в случае нашей страницы такая запись будет происходить в <code>componentDidMount</code> после получения данных). </p><p>Далее, в рендеринге мы выводим наш <code>&lt;input&gt;</code>, у которого свойство <code>value</code> всегда будет копироваться из значения в <code>this.state.product.title</code>. Кроме задания свойства <code>value</code>, мы указываем функцию в качестве свойства <code>onChange</code>. React будет вызывать эту функцию каждый раз, когда пользователь изменит значение в нашем <code>&lt;input&gt;</code>. Естественно, не забываем про биндинг функции, чтобы сохранить ей контекст <code>this</code>.</p><p>Наконец, сама функция onChange. React передаст ей в качестве аргумента объект события, из которого мы обычным способом сможем получить HTML-элемент, созданный для нашего <span>&lt;input /&gt;</span>. Мы заберем оттуда текущее значение <code>value</code> с помощью выражения <code>event.target.value</code> и запишем его внутрь <code>this.state</code>, чтобы следующий рендеринг инпута взял уже новое значение.</p><p>Важный момент – поскольку мы осуществляем запись не с помощью <code>this.setState()</code>, а вручную – мы должны дополнительно вызвать функцию <code>this.forceUpdate()</code>, которая полностью перерисовывает компонент. Если бы мы использовали <code>this.setState()</code>, он бы сделал этот вызов автоматически – но мы не можем его использовать, поскольку <code>this.setState</code> умеет модифицировать поля только на первом уровне вложенности. Скажем, <code>this.setState</code> мог бы полностью переписать объект <code>this.state.product</code>,  но нам нужно оставить его прежним, всего лишь сменив в нем одно поле <code>this.state.product.title</code>.</p><h2>Задание</h2><p>Вместо списка свойств сверстайте на странице редактирования товара форму с единственным <code>&lt;input&gt;</code>, в котором можно редактировать название товара.</p><h3>Подсказки и требования</h3><ul><li>Нужно стилизовать <code>&lt;input&gt;</code> одним из способов, описанных в <a href=\"https://getbootstrap.com/docs/4.1/components/forms\">https://getbootstrap.com/docs/4.1/components/forms</a></li><li>Когда будете копировать верстку из бутстрапа, обратите внимание – в бутстрапе <code>&lt;input&gt;</code> иногда не имеет закрывающего тега. Это связано с тем, что HTML иногда допускает для строго определенных тегов отсутствие закрывающей части – например, для <code>&lt;input&gt;</code>, <code>&lt;img&gt;</code>. Поэтому, в бутстрапе использование таких конструкций не является ошибкой. Однако, React и JSX таких вольностей не допускают, поэтому нам придется внимательно следить за закрытием таких тегов.</li><li>Вынесите рендеринг формы в отдельную функцию <code>renderForm</code> и вызывайте ее только когда товар уже загрузился и доступен <code>{ this.state.product &amp;&amp; this.renderForm() }</code>. Иначе, вы получите ошибку в самом начале работы компонента, когда товар еще не пришел с сервера, а вы уже обращаетесь к свойству несуществующего объекта <code>this.state.product.title</code>.</li><li>Убедитесь, что при внесении изменений в <code>&lt;input&gt;</code> также меняется заголовок карточки товара – поскольку он берет информацию из того же источника внутри <code>state</code>.</li></ul>",
      "tKey": 3
    },
    {
      "name": "Логика работы с несколькими <input> -ами",
      "html": "<p>Чаще всего при реализации формы приходится работать сразу с несколькими полями ввода. Реализовывать для каждого из них собственную функцию для обработки события изменения – не очень удобно. Тем более, что внутри этих функций может понадобиться какая-то дополнительная сложная логика (например, проверка корректности ввода) – тогда нам пришлось бы несколько раз писать одинаковый код.</p><p>Куда разумнее содержать всего одну функцию. Тогда внутри этой функции возникнет задача определить, какое именно поле было отредактировано. </p><p>Мы уже сталкивались с похожей задачей при обработке кликов в навигации – нам нужно просто сохранить дополнительную информацию в  атрибутах <code>&lt;input&gt;</code>, а в обработчике клика – извлечь эту информацию из <code>event.target</code>. В нашем случае этой информацией будет имя поля, которое мы хотим изменить. Для сохранения информации удобно будет воспользоваться стандартным HTML-атрибутом <code>name</code>.</p><pre><code>onChange(event) {\n  const name = event.target.name;\n  this.state.product[name] = event.target.value;\n  this.forceUpdate();\n}\n\nrenderForm() {\n  return &lt;form&gt;\n    &lt;input \n      name=\"title\" \n      value={ this.state.product.title } \n      onChange={ this.onChange.bind(this) }\n    /&gt;\n   &lt;input \n      name=\"description\" \n      value={ this.state.product.description } \n      onChange={ this.onChange.bind(this) }\n    /&gt;\n  &lt;/form&gt;\n}</code></pre><h2>Задание</h2><p>Реализуйте в вашей форме редактирование следующих атрибутов:</p><ul><li>Название <code>title</code></li><li>Описание <code>description</code> (с помощью <code>&lt;textarea&gt;</code>, а не <code>&lt;input&gt;</code>)</li><li>Ключ <code>key</code></li><li>Слаг <code>slug</code></li></ul><p>Выведите рядом с каждым полем метки <code>&lt;label&gt;</code>  с названием поля, чтобы оператору было понятно, какое поле он редактирует.</p>",
      "tKey": 4
    },
    {
      "name": "Сохранение изменений",
      "html": "<p>Теперь нам нужно научиться сохранять в базе данных сделанные изменения. Начнем с клиентской части.</p><h2>Отправка PUT-запроса</h2><p>Первое, что нужно сделать – создать функцию <code>onSave</code>, добавить в форму кнопку \"Сохранить\", и привязать к ней функцию <code>onSave</code> в качестве обработчика события <code>onClick</code>.</p><p>При этом возникнет один нюанс – поскольку мы поместили нашу кнопку внутри формы – любой клик по этой кнопке браузер будет воспринимать как инструкцию \"отправить\" форму - это устаревший способ отправки данных на сервер, неизбежно связанный с перезагрузкой страницы. Как вы понимаете, перезагрузка страницы нам совсем не нужна, поэтому мы должны заблокировать это поведение браузера, вызвав в самом начале нашей <code>onSave</code> следующую функцию:</p><pre><code>event.preventDefault();</code></pre><p>Следующий шаг – отправить из этой функции правильный запрос к серверу.</p><p>Согласно концепции REST, сохранение (модификация) должно производиться <code>PUT</code>-запросом на точно такой же адрес, который используется для получения этой модели <code>GET</code>-запросом по id.</p><pre><code>GET /api/product/5b3dd4a7542a925936ea39fb\nPUT /api/product/5b3dd4a7542a925936ea39fb</code></pre><p>Чтобы указать функции <code>fetch</code> метод, которым мы собираемся отправлять запрос, нужно передать ей второй аргумент – объект с опциями.</p><pre><code>fetch(`/api/product/${this.props.match.params.id}`, {\n  method: \"PUT\"\n})</code></pre><p>Теперь мы должны как-то указать серверу, какие именно изменения мы собираемся сделать. Для этого нужно передать вместе с запросом наш модифицированный объект <code>this.state.product</code>. Информация подобного рода (сложная или которая может занимать слишком много места) всегда передается в <em>теле</em> (<code>body</code>) запроса. </p><p>В тело запроса можно помещать несколько типов данных (в том числе буфер, если мы хотим закачать на сервер картинку), но простого объекта среди разрешенных типов данных нет. Зато есть обычная строка – поэтому мы должны превратить наш объект в строку уже известным нам <code>JSON.stringify()</code>.</p><pre><code>fetch(`/api/product/${this.props.match.params.id}`, {\n  method: \"put\",\n  body: JSON.stringify(this.state.product)\n})</code></pre><p>Остается вопрос – как серверу понять, что мы использовали именно этот тип данных внутри <code>body</code>? Для этого используется заголовок запроса с уже известным нам полем <code>Content-Type</code> (правда, до этого мы использовали заголовки только в HTTP-ответах, а не в HTTP-запросах):</p><pre><code>fetch(`/api/product/${this.props.match.params.id}`, {\n  method: \"put\",\n  body: JSON.stringify(this.state.product),\n  headers: {\n    \"Content-Type\": \"application/json\"\n  }\n})</code></pre><p>Теперь наш вызов fetch полностью \"укомплектован\" и отправляет на сервер правильные данные – пусть он пока и не умеет их обрабатывать. Не забудьте \"подписаться\" с помощью <code>then</code> на результат выполнения <code>fetch</code> – точно так же, как мы делали это для GET-запроса.</p><p>Давайте перед началом реализации функции на сервере своими глазами убедимся в ее правильном поведении. Откройте инспектор (Shift-Ctrl-F12 или Alt-Cmd-F12 на маке), вкладку Network, подвкладку XHR и нажмите кнопку Save.</p><p>В списке отправленных запросов должен появиться наш PUT-запрос. Давайте на него нажмем и убедимся, что он отправляем правильные заголовки и правильное тело запроса (Request Headers и Request Payload).</p><p><img alt=\"Заголовки и тело PUT-запроса\" src=\"/img/tasks/put-request-headers-and-body-payload.png\"></p><h2>Обработка PUT-запроса на серверной стороне</h2><p>Подписка на put-запрос в express.js осуществляется так же легко, как и на get:</p><pre><code>app.put(\"/api/product/:id\", function(req, res) {\n  ...\n});</code></pre><p>Алгоритм действий внутри функции понятен – мы должны извлечь из запроса <code>id</code> и <code>body</code>, а затем вызвать функцию для модификации товара в <code>ProductService.js</code> (которая, правда, еще не написана).</p><p>Здесь мы столкнемся с небольшой сложностью. Если мы попытаемся вывести внутри этой функции <code>req.body</code> (переменная, которая должна содержать тело запроса) – мы с разочарованием убедимся, что она содержит <code>undefined</code>.</p><pre><code>app.put(\"/api/product/:id\", function(req, res) {\n  console.log(req.body);\n});</code></pre><p>Это происходит из-за того, что express.js по умолчанию не занимается парсингом тела для всех запросов, чтобы сэкономить время обработки. </p><p>Естественно, парсинг тела запроса реализован в express.js в виде middleware. В идеальном варианте лучше бы подключать это middleware только к тем запросам, на которых оно требуется. Для учебных целей скорость обработки пока не критична, и мы можем подключить его ко всем запросам:</p><pre><code>const bodyParser = require('body-parser');\nconst jsonBodyParser = bodyParser(\"json\");\napp.use(jsonBodyParser);</code></pre><p>Модуль <code>body-parser</code> устанавливать через <code>npm install</code> не обязательно – он устанавливается автоматически вместе с express.js.</p><p>Теперь в нашем <code>req.body</code> есть вся необходимая информация, и мы можем корректно передать всю информацию в <code>ProductService.js</code>:</p><pre><code>app.put('/2api/product/:id', function(req, res) {\n  ProductService.updateProduct(req.params.id, req.body)\n    .then(function(result) {\n      res.json(result);\n    });\n});</code></pre><h2>Обновление записи в базе данных</h2><p>Осталось только реализовать функцию <code>updateProduct</code> в <code>ProductService.js</code>. </p><p>Для этого в объекте-коллекции MongoDB есть специальная функция update. Она ждет два аргумента. </p><p>Первый – это обычный фильтр для поиска записей, которые нужно модифицировать. С ним мы уже сталкивались, вызывая функцию <code>findOne</code>.</p><p>Второй – это объект с данными, которые <code>MongoDB</code> запишет в первую найденную по фильтру модель.</p><pre><code>updateProduct(id, patch) {\n  return productCollection.update(\n    { _id: ObjectID(id) },\n    patch\n  );\n}</code></pre><h3>Использование MongoDB-оператора <code>$set</code></h3><p>Здесь есть очень важный момент. Если оставить этот вызов вот в таком виде, то MongoDB полностью перезатрет всю существующую информацию в найденной записи. Если там существовали какие-то поля до этого, то они просто сотрутся. Вместо этого более разумной политикой кажется дополнить существующую модель новыми полями, оставив старые. Для этого нужно в объекте с данными использовать специальное свойство <code>$set</code>. </p><pre><code>updateProduct(id, patch) {\n  return productCollection.update(\n    { _id: ObjectID(id) },\n    {\n      $set: patch\n    }\n  );\n}</code></pre><p>Предположим, в базе был следующий товар:</p><pre><code>{\n  title: \"Товар 1\",\n  price: 1000\n}</code></pre><p>Вот каким будет становиться этот товар после апдейта без $set и с ним:</p><table><thead><tr><th>patch</th><th>После обычного update</th><th>С использованием  $set</th></tr></thead><tbody><tr><td><code>{ price:2000 }</code></td><td><code>{ price:2000 }</code></td><td><code>{ title: \"Товар 1\", price: 1000 }</code></td></tr><tr><td><code>{ key: 300 }</code></td><td><code>{ key: 300 }</code></td><td><code>{ title: \"Товар 1\", price: 2000, key: 300 }</code></td></tr></tbody></table><p>Естественно, в случае, когда мы передаем в <code>update</code> не только модифицируемые поля, а все существующие (а это как раз наш случай), можно и не применять <code>$set</code>.  Но более хорошей практикой считается все-таки использование <code>$set</code>, поскольку оно не несет риска случайного уничтожения данных – поэтому мы будем его использовать в обязательном порядке.</p><h3>Удаление id из патча</h3><blockquote><p>Мы называем объект с данными \"патчем\" (от английского patch – заплатка), потому что мы как бы накладываем его на существующую запись. Получившийся результат состоит как из ранее имевшихся данных, так и из новых, появившихся благодаря заплатке.</p></blockquote><p>Патч, который мы пытаемся применить к записи, содержит поле <code>_id</code>. Это запрещено – MongoDB считает это нашей ошибкой и откажется выполнять операцию, даже если новый _id будет полностью эквивалентен имеющемуся.</p><p>Поэтому перед выполнением операции поле  <code>_id</code> из нашего патча лучше удалить.</p><pre><code>updateProduct(id, patch) {\n  delete patch._id;\n  return productCollection.update(\n    { _id: ObjectID(id) },\n    {\n      $set: patch\n    }\n  );\n}</code></pre><blockquote><p>Имейте в виду, что это плохая практика. Мы модифицируем объект patch, который нам передали при вызове. Что, если у вызывающей функции были дальнейшие планы на этот объект, и она справедливо рассчитывала на то, что мы  не повредим его при вызове? В учебных целях мы можем пока с этой ситуацией смириться, но более правильная практика – сформировать новый объект, который содержал бы все поля, кроме <code>_id</code>. Это удобно делать с помощью функции <code>omit</code> из библиотеки <code>lodash</code> – в качестве усложнения задания можете самостоятельно ее установить и сделать по-правильному <a href=\"https://lodash.com/docs/4.17.10#omit\">https://lodash.com/docs/4.17.10#omit</a></p></blockquote><h3>Возврат модифицированной записи</h3><p>К сожалению, функция <code>productCollection.update</code> вернет нам через промис довольно бестолковый результат – в нем будет указано только количество найденных и успешно модифицированных записей. </p><p>А нам нужно, согласно стандарту REST API, вернуть в клиент модифицированную запись. Наш единственный способ – внутри функции <code>updateProduct</code> дождаться выполнения апдейта, а затем просто запросить из базы запись с этим же id – нам вернется уже новый вариант.</p><p>Естественно, теперь нам придется возвращать из нашей функции новый промис и самостоятельно вызывать <code>resolve</code> и <code>reject</code>, когда нужно. Это не самая простая задача, но на данный момент у вас достаточно знаний и примеров, чтобы с ней справиться.</p><pre><code>updateProduct(id, patch) {\n  return new Promise(function(resolve, reject) {\n    ;\n  });\n}</code></pre><h2>Задание</h2><p>Реализуйте сохранение товара после редактирования.</p>",
      "tKey": 5
    },
    {
      "name": "Добавление нового товара",
      "html": "<p>Теперь давайте реализуем добавление нового товара на странице <code>/panel/product</code>. На данный момент у нас есть почти все необходимые знания, кроме следующих:</p><ul><li>Согласно концепции REST, создание новой записи должно происходить POST-запросом на   URL вида <code>/api/product</code>. Как и в PUT-запросе, данные должны передаваться через тело запроса.</li><li>В MongoDB для создания новой записи в коллекции используется функция <code>insert</code>. Она возвращает (конечно, через промис) результат примерно следующего формата: </li></ul><pre><code>{\n  \"result\": { \"ok\":1,\"n\":1 },\n  \"ops\": [{\n    \"title\": ... ,  \n    \"key\": ... , \n    \"slug\": ... , \n    \"_id\": \"5b5c1494fd70580a662a75e9\"\n  }],\n \"insertedCount\": 1,\n \"insertedIds\": {\n    \"0\":\"5b5c1494fd70580a662a75e9\"\n  }}</code></pre><p>То есть, внутри возвращаемого объекта мы можем получить вставленную запись через массив <code>ops</code> следующим выражением:</p><pre><code>  .then(function(result) {\n    const insertedItem = result.ops[0];\n  })</code></pre><h2>Задание</h2><p>Реализуйте в верху страницы <code>/panel/product</code> форму для создания нового товара.</p><h3>Подсказки и требования</h3><ul><li>Модифицируемые поля можно записывать в объект <code>this.state.newProduct</code>. Естественно, этот объект нужно сначала прописать в конструкторе в <code>this.state</code>, заполнив все необходимые поля (title, key, slug) начальными пустыми значениями.</li><li>После успешного добавления нужно добавить новый товар, который мы получили в ответ на наш API-запрос, в конец массива <code>this.state.products</code> с помощью функции <code>push</code>. После этого надо не забыть вызвать <code>this.forceUpdate()</code>, чтобы новый тар немедленно обновился на странице.</li><li>После успешного добавления в <code>this.state.newProduct</code> нужно снова записать пустые значения – чтобы старые не мешались нам при вводе данных для нового товара.</li></ul>",
      "tKey": 6
    }
  ]
},{
  "_id": {
    "$oid": "5c03fc49957ac1d0b296a896"
  },
  "name": "Защита доступа",
  "html": "<p>На данный момент бэк-офисом нашего магазина может воспользоваться любой желающий, по своему усмотрению меняя или добавляя товары. Естественно, это ненормальная ситуация – доступ в панель инструментов должен быть открыт только для ограниченного круга сотрудников. В этом модуле мы реализуем такую защиту.</p>",
  "uKey": 9,
  "tasks": [
    {
      "name": "Работа с cookies",
      "html": "<p>Для того, чтобы ограничивать или разрешать доступ – сервер должен научиться различать, от кого именно приходит ему тот или иной HTTP-запрос. То есть, запросы от авторизованного и от неавторизованного пользователя должны различаться.</p><p>Для этого используется удобный механизм, называемый <code>cookies</code> (по-русски их называют \"куки\" в множественном числе или \"кука\" в единственном) – <a href=\"https://developer.mozilla.org/ru/docs/Web/HTTP/Куки\">https://developer.mozilla.org/ru/docs/Web/HTTP/Куки</a>. Все куки хранятся в браузере в специальном хранилище, индивидуальном для каждого домена. В куках принято хранить авторизационную информацию, с помощью которой можно отличить запросы одного пользователя от другого.</p><p>Работа с куками обычно происходит следующим образом:\n1. В ответ на определенный запрос от какого-то \"чистого\" браузера сервер в возвращаемом ответе устанавливает заголовок <code>Set-Cookie</code>, в котороем передает значение кук в специальном формате <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie</a>\n1. Браузер, получая ответ с заголовком <code>Set-Cookie</code>, сохраняет у себя все переданные сервером куки. Этот происходит автоматически – разработчику для этого ничего делать не нужно.\n1. С этой минуты, в каждый запрос страницы к такому же домену, браузер присоединяет заголовок <code>Cookie</code> и передает в нем значение всех сохраненных кук.\n1. Сервер анализирует информацию в куках запроса, идентифицирует пользователя, и решает – отдавать ему контент или ответить заголовком запрета доступа (код 403 или 401). </p><p>Современные браузеры позволяют вручную просматривать и редактировать куки для каждого домена. В хроме для этого нужно зайти на сайт с соответствующим доменом, вызвать инспектор (Shift-Ctrl-i или Alt-Cmd-i на маке), открыть вкладку Application и в появившемся слева списке нажать Cookies.</p><p>У каждой куки есть несколько параметров – они представлены в этой таблице в виде колонок. Наибольший интерес для нас представляет <code>Path</code> – это путь внутри сайта, для которого данная кука будет применяться.</p><p>Скажем, если Path установлен в <code>/api</code>, то браузер будет присоединять куку к запросам <code>/api/products</code> и <code>/api/users</code>, но не к запросу <code>/panel</code>, т.к. он не находится внутри пути <code>/api</code>.</p><p>Применение Path – это не очень распространенный метод работы с куками – обычно куку делают универсальной для всего домена, устанавливая <code>Path</code> равным <code>/</code>.</p><p>Путь можно установить с помощью передаваемого в <code>Set-Cookie</code> значения, например:</p><pre><code>&lt;cookie-name&gt;=&lt;cookie-value&gt;; Path=&lt;path-value&gt;</code></pre><p>Если в этом значении не указывать Path, то браузер установит его самостоятельно – он будет равен последней \"папке\" в URL, которым производится запрос. Например, если запрос будет производиться к URL <code>/api/set-cookie</code>, то в Path автоматически запишется <code>/api</code>. Это не очень удобно, поэтому при установке куки всегда используют Path.</p><h2>Задание</h2><p>Сделайте в приложении обработку специального API-запрос <code>/api/login</code>. Он должен устанавливать в браузер куку с названием <code>user</code> и значением в виде какого-нибудь произвольного <code>e-mail</code>.</p><blockquote><p>Реализация такого URL не соответствует концепции REST. Это нормально – в API каждого приложения есть несколько специфичных URL, предназначенных не для работы с моделями базы данных, а для других задач – поэтму, естественно, они выбиваются из общей концепции REST.</p></blockquote><p>Убедитесь с помощью инспектора, что кука действительно записывается в браузер при заходе на этот URL. Этот же URL укажите в комментариях к заданию. </p><p>Задание реализуйте с помощью HTTP-заголовка Set-Cookie. Для этого потребуется тщательно изучить формат передаваемых в этом заголовке данных:</p><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie</a></p><p>Не забудьте:</p><ul><li>после установки заголовка завершить запрос с помощью или <code>res.end()</code>.</li><li>прописать Path, чтобы кука установилась по правильному пути (нам нужен /, чтобы кука применялась ко всем запросам).</li></ul><p>После этого реализуйте метод <code>/api/login2</code>, который будет устанавливать такую же куку, но с помощью метода express.js <code>res.cookie</code>: <a href=\"https://expressjs.com/en/4x/api.html#res.cookie\">https://expressjs.com/en/4x/api.html#res.cookie</a></p><p>Express.js по умолчанию кодирует некоторые символы в значении куки, чтобы сделать их безопасными при передаче через URL. В результате вместо символа <code>@</code> в куке мы неожиданно получим <code>%40</code> – это URL-код данного символа. Поскольку мы не собираемся передавать это значение через URL, такая кодировка нам не нужна.</p><p>Изучите самостоятельно, как отменить это поведение Express.js и добиться установки правильного значения.</p><p><a href=\"http://expressjs.com/en/api.html#res.cookie\">http://expressjs.com/en/api.html#res.cookie</a>\n<a href=\"https://stackoverflow.com/questions/35298820/node-express-response-cookie-value-is-encoded\">https://stackoverflow.com/questions/35298820/node-express-response-cookie-value-is-encoded</a>.</p>",
      "tKey": 1
    },
    {
      "name": "Проверка доступа",
      "html": "<p>Наша следующая задача – научиться работать с куками на серверной стороне и отличать, авторизован каждый конкретный запрос или нет.</p><p>Во-первых, давайте убедимся, что браузер теперь передает наши куки с каждым запросом.  Откройте консоль браузера, вкладку Network, зайдите на любую страницу нашего магазина и убедитесь, что в запросе к страницам, стилям и картинкам присутствует заголовок <code>Cookie</code> с нашим e-mail.</p><blockquote><p>Естественно, кука будет присутствовать в этих запросах, если вы правильно установили Path в прошлом задании.</p></blockquote><p>В то же время, если мы откроем в консоли браузера любой запрос к API, то мы увидим, что куки в нем отсутствуют. Это связано с тем, что когда запрос отправляется функцией <code>fetch</code> – куки по умолчанию не присоединяются, чтобы сберечь сетевой трафик. В дальнейшем, когда мы перейдем к авторизации API-запросов, мы разберемся, как заставить <code>fetch</code> отправлять  куки.</p><p>Чтобы на стороне сервера определить, какие именно куки были отправлены с запросом, достаточно просто проанализировать у запроса заголовок <code>Cookie</code>. Однако, как мы уже видели, данные в нем находятся в достаточно сложном формате, которым неудобно пользоваться. </p><p>Для упрощения этой задачи мы можем воспользоваться еще одним стандартным middleware, которое называется <code>cookie-parser</code>.  (имейте в виду – оно не идет в стандартной поставке express.js, его нужно устанавливать самостоятельно с помощью <code>npm install cookie-parser --save</code>):</p><pre><code>const cookieParser = require(\"cookie-parser\");\napp.use(cookieParser());</code></pre><p>Начиная с этого момента, все пришедшие куки будут доступны нам в виде объекта с помощью выражения <code>req.cookies</code> <a href=\"https://expressjs.com/en/4x/api.html#req.cookies\">https://expressjs.com/en/4x/api.html#req.cookies</a></p><h2>Задание</h2><p>Сделайте API для проверки статуса авторизации по адресу <code>/api/me</code>. Оно должно вести себя следующим образом:</p><ul><li>Если у пользователя есть кука <code>user</code>, то API должно вывести значение этой куки (т.е., e-mail-адрес, который мы задали в предыдущем таске).</li><li>Если у пользователя нет этой куки, то API должно вывести статус 401 (Unauthorized – не авторизован) <a href=\"https://developer.mozilla.org/ru/docs/Web/HTTP/Status/401\">https://developer.mozilla.org/ru/docs/Web/HTTP/Status/401</a></li></ul>",
      "tKey": 2
    },
    {
      "name": "Хранение пользователей в БД",
      "html": "<p>Очевидно, нам нужно научиться разрешать доступ не всем пользователям, которые указали в своей куке email – а только пользователям из определенного списка. Естественно, этот список нужно хранить в базе данных, в новой коллекции <code>user</code>.</p><p>Функционал нашего <code>ProductService.js</code> придется расширить – теперь он будет отвечать не только за товары, но и за пользователей. Поэтому давайте переименуем сам файл в <code>DBService.js</code>, и заменим в server.js все упоминания <code>ProductService</code> на новое название <code>DBService</code>.  Теперь в этом сервисе будет храниться весь функционал, связанный с доступом к базе данных (Data Base Service – отсюда сокращение DBService).</p><p>Теперь давайте опишем новую коллекцию, в котором будем хранить пользователей. По аналогии с <code>productCollection</code> создайте в модуле переменную <code>userCollection</code> и проинициализируйте ее в функции <code>init()</code>. </p><p>Следующий шаг – добавить в модуль функцию <code>getUserByEmail</code>, которая должна принимать в качестве аргумента email пользователя и выдавать промис с объектом этого пользователя, найденного в базе данных.</p><p>Теперь все готово для выполнения задания.</p><h2>Задание</h2><p>Модифицируйте наше API <code>/api/me</code> так, чтобы оно срабатывало только для пользователей, находящихся в базе данных. Если в куке прописать пользователя, которого нет в базе (т.е. функция <code>getUserByEmail</code> возвращает <code>null</code>), то API должно выдать статус 403 Forbidden (доступ запрещен).\n<a href=\"https://developer.mozilla.org/ru/docs/Web/HTTP/Status/403\">https://developer.mozilla.org/ru/docs/Web/HTTP/Status/403</a></p>",
      "tKey": 3
    },
    {
      "name": "Знакомство с JWT-токенами",
      "html": "<p>В данный момент в нашу систему авторизации может легко войти любой посторонний. Ему достаточно как-то узнать e-mail любого из сотрудников, прописанных в базе, и вручную установить себе соответствующую куку. Доступ на адрес <code>/api/me</code>, который мы стараемся защитить, будет таким образом легко получен.</p><p>Решение этой проблемы – <em>подпись</em> авторизационных данных. То есть, при запросе к <code>/api/login/</code> сервер должен выдать в качестве куки не просто e-mail пользователя, а более сложную структуру – которую будет невозможно подделать.</p><p>В качестве такой структуры мы будем использовать JWT (JSON Web Token) – технологию, ставшую за последнее время стандартом де-факто для передачи защищенной информации.</p><p>Для более глубокого понимания JWT вы можете изучить информацию по следующим ссылкам:\n<a href=\"https://jwt.io/\">https://jwt.io/</a>\n<a href=\"https://ru.wikipedia.org/wiki/JSON_Web_Token\">https://ru.wikipedia.org/wiki/JSON_Web_Token</a>\n<a href=\"https://habr.com/post/340146/\">https://habr.com/post/340146/</a></p><p>В целом, принцип работы JWT следующий:</p><ol><li>На серверной стороне задается случайный секретный ключ – который ни в коем случае не должен попасть к злоумышленнику. Ключ представляет собой простую строку с произвольным набором символов.</li><li>Когда на сервер поступает запрос авторизации, и сервер принимает решение выдать доступ этому конкретному пользователю, он начинает формировать токен:<ol><li>Выбираются данные, которые нужно хранить внутри токена – в нашем случае это просто email, но может быть и имя пользователя, ссылка на фото и т.п. Этот набор данных называется <code>payload</code> и представляет собой обычный js-объект.</li><li>Выбирается срок, в течение которого данный токен будет считаться действительным. Время генерации токена <code>iat</code> (issued at) и время, до которого он годен <code>exp</code> (expiration time) автоматически добавляются в <code>payload</code>.</li><li>К токену добавляется строка подписи. Подпись – это строка, сгенерированная сложным алгоритмом, использующим на входе весь <code>payload</code> и секретный ключ. </li><li>Подпись присоединяется к payload, результат проводится через кодировку base64 и на выходе получается строка, которая и называется JWT-токеном.</li></ol></li><li>Браузер записывает токен в куку. Браузер не знает секретного ключа, но <code>payload</code> в токене не зашифрован – так что браузеру доступна вся информация о пользователе и он может ее отобразить на странице.</li><li>К каждому запросу, требующему авторизации, браузер теперь прикрепляет токен.</li><li>Сервер анализирует токен, проверяет подпись и срок его действия и принимает решение о разрешении доступа или отказе.</li></ol><h2>Подпись токена</h2><p>Для продолжения работы крайне желательно хорошо усвоить следующие свойства, которыми обладает подпись JWT-токена:</p><ul><li>Не зная секретный ключ, ее невозможно сгенерировать.</li><li>Не зная секретный ключ, невозможно даже проверить правильность существующей подписи.</li><li>Из подписи и payload, невозможно восстановить SECRET.</li><li>Подпись полностью соответствует <code>payload</code> – если мы изменим в нем малейшее поле (например, e-mail или дату \"годности\"), то подпись перестанет ему соответствовать и она не пройдет проверку.</li><li>Даже если злоумышленник получит доступ к чужому токену – он сможет пользоваться им только ограниченное время. Токен быстро \"протухнет\", и доступ закончится.</li></ul><p>В связи с последним пунктом возникает некоторый конфликт между удобством и безопасностью. Если сделать срок жизни токена небольшим, это будет более безопасно, но пользователю придется заново логиниться каждый несколько минут – что очень неудобно. </p><p>Поэтому на практике применяют двухступенчатую авторизацию – у пользователя есть один длительный токен, который редко передается по сети и подвержен меньшей опасности. С помощью этого длительного токена браузер довольно редко (раз в несколько минут) получает \"короткие\" токены, у которых небольшое время жизни. И именно эти \"короткие\" токены используются для сопровождения основной массы запросов. Если злоумышленник сможет перехватить сообщение по сети, то скорее всего в нем будет \"короткий\" токен, который протухнет очень быстро.</p><h2>Работа с токеном</h2><p>Для работы с токеном используется модуль <code>jsonwebtoken</code>, который нужно предварительно установить. Документация: <a href=\"https://www.npmjs.com/package/jsonwebtoken\">https://www.npmjs.com/package/jsonwebtoken</a></p><p>После этого его можно использовать:</p><pre><code>const jwt = require(\"jsonwebtoken\");\nconst SECRET = \"Любая строка со случайным набором символов\";\n\nconst payload = {\n  email: \"some_user@hutorium.ru\"\n};\nconst token = jwt.sign(payload, SECRET, {\n  expiresIn: \"5m\"\n});</code></pre><p>Объект <code>{ expiresIn: \"5m\" }</code> – это настройки генерируемого токена. Мы указали только одну настройку – время жизни. Всего через 5 минут после создания данный токен будет считаться недействительным.</p><h2>Задание</h2><p>Сделайте, чтобы по запросу <code>/api/login</code> пользователю устанавливалась кука не с email, а JWT-токен, содержащий этот e-mail. Сама кука должна называться <code>token</code>, а не <code>user</code>.</p><p>После задания декодируйте полученный токен на сайте <a href=\"https://jwt.io/\">https://jwt.io/</a> и просмотрите, какую информацию он содержит в payload.</p>",
      "tKey": 4
    },
    {
      "name": "Проверка JWT-токена",
      "html": "<p>Теперь нам нужно научиться проверять токен на \"валидность\" – то есть, на правильность подписи и на годность по времени. Для этого используется тот же модуль <code>jsonwebtoken</code>, который мы установили в предыдущем таске.</p><pre><code>const payload = jwt.verify(token, SECRET);</code></pre><p>В случае, если подпись токена валидна (т.е. его payload соответствует секрету), и он не просрочен по времени – эта функция вернет полезную нагрузку, хранящуюся в токене.</p><p>В случае, если токен просрочен или его подпись подделана – произойдет стандартное javascript-исключение (ошибка), которое мы можем \"поймать\" с помощью механизма <code>try...catch</code>.</p><pre><code>try {\n  const payload = jwt.verify(token, SECRET);\n  // здесь спокойно пользуемся payload-ом\n} catch(err) {\n  // здесь отказываем пользователю в доступе\n}</code></pre><h2>Задание</h2><p>Реализуйте в обработчике запроса <code>/api/me</code> проверку токена и извлечение из него имени пользователя. Всю дальнейшую обработку (поиск пользователя по базе и т.п.) оставьте прежней.</p><p>В случае любых проблем в токене верните ответ 403. Убедитесь, что после получения токен действует строго определенное время (тот срок, который вы указали при его генерации), и что система не принимает токены, сделанные с другим секретом (их можно сгенерировать на <a href=\"https://jwt.io/\">https://jwt.io/</a>).</p>",
      "tKey": 5
    },
    {
      "name": "Использование пароля",
      "html": "<p>К нашему API по-прежнему может получить доступ любой желающий – для этого достаточно зайти на <code>/api/login</code>, и сервер сам установит нам куку с необходимым токеном.</p><p>Для решения этой задачи нам нужно заставить пользователя вводить индивидуальный для каждого пароль при запросе к <code>/api/login</code>. На сервере мы будем проверять, правильный ли пароль введен – и только в этом случае устанавливать куку с необходимым токеном.</p><blockquote><p>Внимание! В этом таске мы исключительно в учебных целях сделаем две вещи, которые ни в коем случае не должны применяться на практике. (естественно, в следующих тасках мы научимся делать их правильно). Во-первых, пароли никогда не должны храниться в базе данных. Во-вторых, логин не должен выполняться GET-запросом. </p></blockquote><p>Откройте новое окно терминала, зайдите в клиентский интерфейс MongoDB (команда <code>mongo</code>) и модифицируйте запись с вашим пользователем, добавив ему какой-нибудь пароль (имейте в виду, что вам придется публиковать этот пароль в комментарии при отправке таска на проверку).</p><pre><code>mongo\nuse shop\ndb.user.update({ _id: ObjectId(\"_тут_mongo-id_пользователя_\") }, { $set: { password: \"1234\" } })</code></pre><h2>Задание</h2><p>Доработайте обработчик <code>/api/login</code> так, чтобы он отдавал токен только при передаче правильных значений в GET-параметрах <code>email</code> и <code>password</code> (т.е. при запросе вида <code>/api/login?email=user@hutorium.ru&amp;password=1234</code>).</p><h3>Подсказки и требования</h3><ul><li>Напомним, что в express.js GET-параметры сразу же доступны в <code>req.query</code> в виде объекта </li><li>Во всех ситуациях, когда мы не можем авторизовать пользователя (email не передан, в базе нет пользователя с таким email, введен неверный пароль) – нужно возвращать статус 403 и минимальный текст, описывающий суть ошибки.</li><li>Используйте при генерации токена не статичную строку с прописанным email, а берите email из параметров запроса или полученного из БД пользователя.</li><li>В комментарии к заданию укажите URL с правильным email и password.</li></ul>",
      "tKey": 6
    },
    {
      "name": "Шифрование паролей с помощью bcrypt",
      "html": "<p>Основная причина, по которой нельзя хранить пароли в открытом виде – пользователи часто используют один и тот же пароль на нескольких сервисах. В случае, если к вашей базе получит доступ злоумышленник, вы нанесете колоссальный вред своим пользователям – не только в рамках пользования вашим сервисом.</p><h2>Одностороннее шифрование</h2><p>Эту проблему обычно решают с помощью принципа одностороннего шифрования. В базе при этом хранят не сам пароль, а его хэш – специальную строку, сгенерированную на основе пароля по одному из популярных алгоритмов.</p><p>Односторонним это шифрование называют, потому что преобразование в обратную сторону алгоритмически невозможно – то есть, мы можем спокойно хранить хэш пароля в нашей базе, не подставляя пользователей.</p><h2>Проверка паролей при одностороннем шифровании.</h2><p>Возникает вопрос – как же тогда проверить пароль, введенный пользователем на стадии логина, с хэшем пароля, сохраненным в базе?</p><p>Ответ на этот вопрос зависит от алгоритма, которым мы пользуемся. </p><p>Если алгоритм – детерминированный (т.е. функция хэширования всегда возвращает одинаковое значение для одинакового пароля) – то можно просто взять хэш от пароля, пришедшего в API-запросе на логин, и сравнить хэш с хранящимся в базе. Такие алгоритмы были популярны в начале 2000-х (например <a href=\"https://ru.wikipedia.org/wiki/MD5\">https://ru.wikipedia.org/wiki/MD5</a>), но сейчас признаны устаревшими и недостаточно безопасными. При современных компьютерных мощностях злоумышленник, получивший доступ к базе, может путем простого перебора по таблице самых распространенных паролей вычислить, какие из этих паролей соответствуют хэшам в нашей базе – и узнать таким  образом пароли у определенного процента пользователей.</p><p>Поэтом сейчас используются стохастические алгоритмы шифрования пароля – т.е. такие алгоритмы, которые частично базируются на случайном факторе. В результате хэш т одного и того же пароля может быть разным при каждом следующем вызове.</p><p>В таких алгоритмах есть специальные функции для проверки подлинности пароля. Как именно они работают – зависит от конкретного алгоритма. Этот процесс достаточно сложен, но для успешного применения этих алгоритмов понимать детали на глубоком уровне не обязательно.</p><h2>Алгоритм bcrypt</h2><p>Мы для шифрования паролей будем пользоваться алгоритмом bcrypt, как одним из наиболее распространенных на данный момент.</p><p>Для его работы потребуется установить (через <code>npm install bcrypt --save</code>) и подключить модуль <code>bcrypt</code>.</p><pre><code>const bcrypt = require(\"bcrypt\");\nconst saltRounds = 10;\n\nconst hash = bcrypt.hashSync(\"1234\", saltRounds);\n\n// в result запишется true\nconst result = bcrypt.compareSync(\"1234\", hash); \n\n// в result2 запишется false,\n// т.к. 12345 не сответствует хэшу\nconst result2 = bcrypt.compareSync(\"12345\", hash); </code></pre><p>В переменной <code>saltRounds</code> хранится количество внутренних циклов, которые будут проходиться алгоритмом bcrypt для формирования хэша. Вы можете поставить сюда любое число – чем оно больше, тем сложнее будет подбор пароля, соответствующего хэшу - но тем дольше времени будет занимать генерация пароля.</p><p>Обратите также внимание, что мы используем синхронные версии функций <code>bcrypt</code>, с суффиксом  <code>sync</code>. Это очень удобно и подходит для учебных целей, но отнимает больше ресурсов системы. На практике старайтесь использовать обычные асинхронные версии.</p><p>Документацию по bcrypt можно найти здесь:\n<a href=\"https://www.npmjs.com/package/bcrypt\">https://www.npmjs.com/package/bcrypt</a></p><h2>Задание</h2><p>Удалите из базы пароль и поместите вместо этого поле <code>passwordHash</code> c bcrypt-хэшем. Адаптируйте обработку логина, перестроив ее на <code>bcrypt.compareSync</code>.</p><h3>Требования и подсказки</h3><ul><li>Создайте специальное служебное API <code>/api/bcrypt</code>. Оно должно получать пароль через GET-параметр <code>password</code> и возвращать bcrypt-хэш для этого пароля.  </li><li>Сохраните в базе <code>passwordHash</code> для вашего пользователя. Чтобы получить значение хэша, воспользуйтесь только что созданным API.</li><li>В результате API для логина должно работать точно так же, как и раньше. Не забудьте в комментарии к заданию указать пароль для проверки</li></ul>",
      "tKey": 7
    },
    {
      "name": "Защита определенных маршрутов с помощью middleware",
      "html": "<p>Теперь давайте перейдем к практическому применению нашей системы защиты. Нам нужно, чтобы несколько API-маршрутов, используемых только в бек-офисе, были защищены авторизацией, а все остальные запросы – по-прежнему оставались публичными.</p><p>Для этого нужно научиться применять нашу функцию проверки токена не как финальный обработчик, а как <code>middleware</code>. Напомним, основное отличие <code>middleware</code> в том, что оно может выполнить определенные действия, но не возвращать ответ, а передать управление последующим <code>middleware</code> или обработчикам.</p><p>Для этого в нашей функции нужно начать использовать третий аргумент – его обычно называют <code>next</code> или <code>callback</code>. Express.js передаст нам в него функцию, которую необходимо будет вызвать для последующей обработки.</p><pre><code>function checkToken(req, res, next) {\n  // При определенных условиях – вернуть ответ\n  if (someCondition) {\n    res.write(\"Response text\");\n    res.end();\n    return;\n  }\n\n  // Иначе – поместить полезную информацию \n  // в req, чтобы ей могли пользоваться следующие обработчики\n  // и передать управление\n  req.someData = { processed: true };\n  next();\n}</code></pre><p>После этого наш <code>middleware</code> можно будет назначить на какой-нибудь URL обычным способом – как и любой финальный обработчик.</p><pre><code>app.put(\"/api/product/:id\", checkToken);\napp.put(\"/api/product/:id\", function serveUpdate(req, res) {\n  // тут финальный обработчик\n);</code></pre><p>При работе с <code>middleware</code> очень важен порядок, в котором вы \"подписываете\" их на определенные маршруты. Именно в таком порядке они и будут применяться. Например, если вы в приведенном примере поменяете вызовы местами, то <code>middleware</code>  не будет вызываться никогда – потому что в начале вызовется финальный обработчик, который никогда не вызовет функцию <code>next()</code> и не передаст управление следующим подписанным обработчикам.</p><h2>Задание</h2><p>Защитите от доступа неавторизованным пользователем все маршруты API, необходимые для работы панели инструментов. При этом маршруты, необходимые для работы самого магазина, должны остаться открытыми.</p><ul><li>GET <code>/api/product/:id</code></li><li>PUT <code>/api/product/:id</code></li><li>POST <code>/api/product</code></li></ul><p>Также, должен быть защищен маршрут <code>/api/me</code>, и он должен сохранить прежнее поведение – т.е. выводить e-mail авторизованного пользователя. При этом было бы неправильно дублировать в нем функционал проверки и расшифровки токена – это лишняя нагрузка и лишний код.</p><p>Вместо этого в <code>middleware</code> проверки токена, в случае успеха просто запишите полученного пользователя внутрь объекта <code>req</code> – а в обработчике <code>/api/me</code> воспользуйтесь этой информацией.</p>",
      "tKey": 8
    },
    {
      "name": "Страница логина на клиенте",
      "html": "<p>Вводить авторизационные данные в GET-параметры URL страшно неудобно. К тому же, из-за отправки авторизации GET-запросом, пароль сотрудника нашего магазина может увидеть любой человек, случайно оказавшийся у него за спиной.</p><p>Очевидно, что нам нужна специальная страница логина, где пользователь сможет вводить логин и пароль в специальную форму.</p><h3>fetch и куки</h3><p>Это очень важный момент. Отправка запроса fetch отличается от обычной отправки запроса браузером. По умолчанию работа с куками в fetch отключена. </p><p>Во-первых, браузер не отправляет куки вместе с API-запросами fetch. Поэтому сервер может запрещать им доступ, несмотря на присутствие куки в браузере. Во-вторых – при получении результата fetch не устанавливает куки в браузер пр получении заголовка <code>Set-Cookie</code>.</p><p>Чтобы заставить fetch работать с куками, необходимо в объекте опций, который мы предаем вторым аргументом, добавить поле <code>credentials</code> со значением <code>\"same-origin\"</code>:</p><pre><code>fetch(\"/api/something\", {\n  method: \"ANY METHOD\",\n  credentials: \"same-origin\"\n})</code></pre><h2>Задание</h2><p>Создайте в панели новую страницу с функционалом логина. Она должна располагаться по адресу <code>/panel/login</code>. Кроме того, переделайте API-запросы на всех страницах бэк-офиса, чтобы они отправляли <code>credentials: \"same-origin\"</code>. Убедитесь, что они успешно работают после авторизации.</p><h3>Подсказки и требования</h3><ul><li>На сервере нужно будет переделать маршрут логина с GET-запроса на POST-запрос <code>/api/login</code>. Не забудьте, что теперь нужно доставать данные не из <code>req.query</code>, а из <code>req.body</code>.</li><li>В случае успеха это API теперь должно возвращать json, а не просто строку – т.к. на клиенте мы ожидаем получения json.</li><li>Функционал страницы будет во многом похож на страницу создания товара, можно скопировать часть функционала оттуда.</li><li>Чтобы вводимый пароль нельзя было случайно подсмотреть, для его ввода воспользуйтесь атрибутом <code>type=\"password\"</code> для инпута: <code>&lt;input type=\"password\" /&gt;</code></li><li>В случае ошибочного ввода e-mail или пароля выведите на странице специальный блок с сообщением, стилизованный на основе <a href=\"https://getbootstrap.com/docs/4.1/components/alerts/\">https://getbootstrap.com/docs/4.1/components/alerts/</a></li><li>Обычно ситуацию, когда пользователь ввел несуществующий в базе e-mail или неверный для данного e-mail пароль, для клиента отображают абсолютно одинаково. Это делается для того, чтобы не предоставлять потенциальному злоумышленнику лишней информации – в противном случае он легко смжет узнать, зарегистрирован ли у нас в системе пользователь с определенным e-mail.</li></ul><h3>Рекомендации по управлению state внутри компонента.</h3><p>Удобнее всего будет держать <code>this.state</code> в виде следующей структуры:</p><pre><code>{\n  status: \"idle\", \n  credentials: {\n    login: \"user@hutorium.ru\",\n    password: \"1234\"\n  }\n}</code></pre><p>В status всегда один из вариантов \"idle\", \"pending\", \"error\", \"logged\". В качестве начального значения задается idle. Когда отправляете форму – устанавливаете \"pending\". Когда приходит ответ – \"error\" или \"logged\" .</p><p>Благодаря наличию информации в <code>this.state.status</code> очень удобно отрисовать вверху страницы плашку с классом <code>alert alert-info</code>, и вывести в ней текст, соответствующий статусу.</p><p>Кроме того, мы можем скрывать форму с вводом данных после успешного логина – это очень удобно для пользователя.</p><pre><code>{ this.state.status !== \"logged\" &amp;&amp; this.renderForm() }</code></pre>",
      "tKey": 9
    },
    {
      "name": "Логаут и определение статуса авторизации на клиенте",
      "html": "<p>В любой системе авторизации должна быть возможность удалить текущие авторизационные данные – например, после работы на гостевом компьютере. Мы реализуем такую возможность прямо ан странице логина. </p><p>Естественно, сначала нам нужно научиться определять состояние авторизации. Если мы авторизованы, нужно отрисовать кнопку выхода (логаута). Если нет – обычную форму логина для ввода авторизационных данных.</p><p>Первое, что приходит в голову – это отправка на сервер запроса к <code>/api/me</code>. Но – это лишний сетевой запрос, к тому же он асинхронный, что вызовет определенные неудобства. Есть решение проще – в браузере записана кука с токеном, который содержит всю авторизационную информацию. </p><p>Конечно, мы не сможем достоверно проверить валидность токена на клиенте, т.к. на клиенте нет доступа к секретному ключу. Но строгая проверка здесь и не требуется. Да, если злоумышленник попытается подделать токен, то клиентская страница отобразит ему состояние нормальной авторизации. Но при дальнейшей работе клиент начнет отправлять API-запросы, которые, естественно, будут отвергнуты сервером.</p><p>Для парсинга кук на клиенте нам потребуется установить дополнительный модуль <code>npm install cookie --save</code>.</p><p>Кроме того, на странице логина потребуется модуль <code>jsonwebtoken</code> – он уже установлен, нужно только подключить его обычным образом с помощью require.</p><pre><code>const Cookie = require('cookie');\nconst jwt = require('jsonwebtoken');</code></pre><p>В конструкторе страницы мы устанавливаем в <code>state</code> начальное значение <code>status</code> равным <code>idle</code>.   Однако, теперь возможны ситуации, когда начальным значением должно стать сразу <code>logged</code>. Для этого нам нужно сделать следующее:</p><ul><li>Распарсить объект со всеми куками документа (т.е. HTML-страницы).</li><li>Найти куку token, если она есть</li><li>С помощью jwt-модуля извлечь из нее значение payload</li><li>Сравнить ее срок годности <code>exp</code> с текущей датой.</li></ul><p>В случае, если токен еще актуален, мы должны перезаписать начальное значение статуса <code>this.state.status = \"logged\";</code></p><p>Кроме того, весь наш блок кода нужно обернуть в <code>try...catch</code>. При парсинге токена легко может произойти исключение – например, в случае, если он был поврежден вручную. Возникновения необработанного исключения остановит наш компонент и на странице будет пусто – это недпустимая ситуация – поэтому исключение обязательно нужно \"ловить\".</p><h3>Парсинг кук и проверка срока годности токена</h3><p>Парсинг кук присходит следующим образом:</p><pre><code>const cookies = Cookie.parse(document.cookie);</code></pre><p>После этого в переменной cookies будет объект со всеми куками, к которым можно обращаться по имени (например, <code>cookies.token</code>).  Теперь мы можем декодировать информацию из нашего токена с помощью функции <code>decode</code>. Обратите внимание – в отличие от <code>verify</code> функция <code>decode</code> не обращает внимания на валидность подписи или срок действия токена – она просто извлекает информацию.</p><pre><code>const payload = jwt.decode(cookies.token);</code></pre><p>Теперь в <code>payload.exp</code> хранится срок годности. Этот срок хранится в формате TIMESTAMP, который представляет собой количество секунд, прошедших с определенной даты, называемой началом UNIX-эпохи (1 января 1970 года). </p><p>Нам нужно сравнить ее с текущей датой. Для получения текущего timestamp можно использовать следующий код:</p><pre><code>const timestampInMilliseconds = new Date(0.getTime();</code></pre><p>Важный момент – полученный таким образом timestamp хранит не количество секунд, а количество миллисекунд с начала UNIX-эпохи. Поэтому для сравнения с <code>payload.exp</code> нужно либо умножить его на 1000, либо разделить на 1000 текущее значение.</p><h3>Логаут и удаление куки</h3><p>Для логаута нам достаточно просто удалить куку из браузера.  Это делается не самым очевидным образом:</p><pre><code>document.cookie = 'token=; Path=/; Max-Age=0;';.</code></pre><p>Фактически, мы просто перезаписываем значение и параметр <code>Max-Age</code> у данной куки. Значение пустое (до точки с запятой <code>token=;</code>), а Max-Age устанавливается в 0. Этот параметр отвечает за максимальный \"возраст\" хранения куки. Т.к. мы устанавливаем его в 0, браузер решает, что кука устарела и ее нужно стереть.</p><p>Важный момент – мы должны указать <code>Path</code> точно таким же, как и у удаляемой куки. Куки с одинаковым именем, но разными параметрами <code>Path</code> считаются отдельными записями в реестре кук – поэтому, если <code>Path</code> будет не совпадать, удаления не произойдет.</p><h2>Задание</h2><p>Реализуйте на странице логина функционал логаута с вышеописанными требованиями. Коме плашки с статусом, страница в любой момент времени должна отображать либо форму логина, либо кнопку логаута. После выполнения логаута должна сразу же появляться форма логина, и наоборот.</p>",
      "tKey": 10
    },
    {
      "name": "Обработка ошибок авторизации в API",
      "html": "<p>Поскольку наш токен устаревает каждые 5 минут, вполне реалистична ситуация, когда наш оператор  работает в бэк-офисе, и авторизация заканчивается прямо во время работы со страницей. </p><p>При текущей реализации следующий API-запрос завершится неудачей без объяснения причин и способов решения проблемы. Это не совсем корректно по отношению к пользователю. </p><p>Одно из решений проблемы – отлавливать ошибки 401 или 403 и при их возникновении переводить браузер на страницу авторизации.</p><blockquote><p>На самом деле это не очень хорошее решение, и мы делаем его только в учебных целях. У пользователя могла быть введена информация в различные формы, и при переходе на другую страницу он ее безвозвратно потеряет. Более правильное решение – кроме страницы авторизации, создавать еще отдельное окошко авторизации, которое можно вывести на любой странице поверх основного контента. Или показывать плашку с сообщением о \"протухшей\" авторизации и ссылкой на страницу логина, которую можно открыть в новой вкладке.</p></blockquote><p>Статус <code>response</code> можно отследить в промисе, который возвращает <code>fetch</code>:</p><pre><code>fetch(url, options)\n  .then(function(res) {\n    console.log(res.status); // Выведет код статуса\n  });</code></pre><p>Для перевода браузера на другой URL можно воспользоваться командой</p><pre><code>window.location = \"/panel/login\";</code></pre><h2>Задание</h2><p>На всех страницах бэк-офиса, при возвращении из API ошибки со статусом 401 или 403 переводить браузер на страницу логина.</p><p>Это должно относиться ко всем запросам – как на получение, так и на изменение/создание данных.</p>",
      "tKey": 11
    },
    {
      "name": "Авторизация в React Router",
      "html": "<p>Наша система авторизации все еще не слишком удобна для пользователя. Он может обнаружить, что не авторизован, только когда зайдет внутрь бэкофиса и воспользуется каким-то API, которое недоступно без авторизации. Логично было бы не пускать его внутрь бэкофиса на уровне страницы – чтобы уже при попытке зайти на <code>/panel</code> неавторизованный пользователь столкнулся с необходимостью ввода логина и пароля.</p><p>Этого эффекта можно легко достичь с помощью React Router с помощью следующей методики:</p><ol><li>Создадим обертку маршрута – новый компонент в папке <code>components</code>, назовем его <code>ProtectedRoute.jsx</code>. Он будет использоваться в <code>app.jsx</code> вместо <code>&lt;Route&gt;</code> для тех маршрутов, которые доступны только авторизованным пользователям.</li><li>В конструкторе этого компонента нужно вычислить, авторизован ли пользователь, и поместить результат в переменную <code>this.state.isAuthorized</code>, чтобы она в итоге содержала true или false.</li><li>При рендеринге <code>&lt;ProtectedRoute&gt;</code> мы должны проверить значение <code>this.state.isAuthorized</code>. <ul><li>Если оно <code>true</code> и пользователь авторизован – то мы должны отрисовать обычный <code>&lt;Route&gt;</code>, пробросив в него все свойства, переданные нам в <code>this.props</code>.</li><li>Если оно <code>false</code>, т.е. пользователь неавторизован – мы должны вывести <code>&lt;Redirect&gt;</code> – инструкцию для React Router перейти на указанную страницу.</li></ul></li></ol><p>В результате, если пользователь авторизован, то вместо наших <code>&lt;ProtectedRoute&gt;</code> внутри <code>&lt;Switch&gt;</code> будут выведены обычные <code>&lt;Route&gt;</code>, и маршрутизация будет работать как раньше. Если нет - то вместо наших <code>&lt;ProtectedRoute&gt;</code> внутри <code>&lt;Switch&gt;</code> будут выведены редиректы – первый из них, соответствующий текущему  URL, сработает и перекинет браузер на страницу авторизации.</p><p>Поскольку мы собираемся использовать наш <code>&lt;ProtectedRoute&gt;</code> вместо обычного <code>&lt;Route&gt;</code>, мы, естественно,  будем назначать ему те же самые свойства.  Поэтому возникает задача – когда он будет  рендерить внутри себя обычный <code>&lt;Route&gt;</code>, ему нужно будет передать ему все собственные свойства. Это дстигается так называемым spread-оператором (<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax</a>), появившемся в javascript сравнительно недавно:</p><pre><code>// Все, что находится внутри this.props, \n// будет передано дочернему Route\n&lt;Route { ...this.props  } /&gt;</code></pre><p>Кроме того, нам понадобится корректно настроить <code>&lt;Redirect&gt;</code>, с которым мы ранее не сталкивались. Нам понадобятся только два самых важных параметра:</p><ol><li>Параметр <code>\"to\"</code> – на какой URL нужно редиректить пользователя;</li><li>Параметр <code>\"from\"</code> – редирект будет срабатывать, только если в браузере в данный момент введен этот URL.</li></ol><p>Поскольку наш родительский компонент <code>&lt;ProtectedRoute&gt;</code> получает точно такие же свойства, как и обычный <code>&lt;Route&gt;</code>, нам доступно свойство <code>path</code> – в котором как раз и находится необходимый нам URL. Поэтому наш <code>&lt;Redirect&gt;</code> удобно рендерить в следующем виде:</p><pre><code>&lt;Redirect to=\"/panel/login\" from={ this.props.path } /&gt;</code></pre><h2>Задание</h2><p>Реализуйте защиту всех страниц внутри бэк-офиса с помощью React Router. Заход на любую страницу без авторизации должен приводить к мгновенному редиректу на страницу <code>/panel/login</code>.</p>",
      "tKey": 12
    }
  ]
}]